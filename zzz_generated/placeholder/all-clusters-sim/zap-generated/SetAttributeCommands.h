/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include "commands/common/Command.h"
#include "commands/common/Commands.h"
#include <app-common/zap-generated/attributes/Accessors.h>
#include <platform/CHIPDeviceLayer.h>

#include <string>

using namespace ::chip::app::Clusters;

class SetIdentifyIdentifyTimeAttributeCommand : public Command
{
public:
    SetIdentifyIdentifyTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "identify-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &identifyTime, "Set the Value of on IdentifyTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: IdentifyTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetIdentifyTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t identifyTime;
    chip::EndpointId mEndPointId;

private:
    static void SetIdentifyTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIdentifyIdentifyTimeAttributeCommand * command = reinterpret_cast<SetIdentifyIdentifyTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Identify::Attributes::IdentifyTime::Set(command->mEndPointId, command->identifyTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute IdentifyTime");
        }
    }
};
class SetIdentifyIdentifyTypeAttributeCommand : public Command
{
public:
    SetIdentifyIdentifyTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "identify-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &identifyType, "Set the Value of on IdentifyType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: IdentifyType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetIdentifyType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t identifyType;
    chip::EndpointId mEndPointId;

private:
    static void SetIdentifyType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIdentifyIdentifyTypeAttributeCommand * command = reinterpret_cast<SetIdentifyIdentifyTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Identify::Attributes::IdentifyType::Set(command->mEndPointId, command->identifyType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute IdentifyType");
        }
    }
};
class SetIdentifyFeatureMapAttributeCommand : public Command
{
public:
    SetIdentifyFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIdentifyFeatureMapAttributeCommand * command = reinterpret_cast<SetIdentifyFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Identify::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetIdentifyClusterRevisionAttributeCommand : public Command
{
public:
    SetIdentifyClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIdentifyClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetIdentifyClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Identify::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetGroupsNameSupportAttributeCommand : public Command
{
public:
    SetGroupsNameSupportAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "name-support", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &nameSupport, "Set the Value of on NameSupport.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NameSupport");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNameSupport, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t nameSupport;
    chip::EndpointId mEndPointId;

private:
    static void SetNameSupport(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGroupsNameSupportAttributeCommand * command = reinterpret_cast<SetGroupsNameSupportAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Groups::Attributes::NameSupport::Set(command->mEndPointId, command->nameSupport);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NameSupport");
        }
    }
};
class SetGroupsFeatureMapAttributeCommand : public Command
{
public:
    SetGroupsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGroupsFeatureMapAttributeCommand * command = reinterpret_cast<SetGroupsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Groups::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetGroupsClusterRevisionAttributeCommand : public Command
{
public:
    SetGroupsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGroupsClusterRevisionAttributeCommand * command = reinterpret_cast<SetGroupsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Groups::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetScenesSceneCountAttributeCommand : public Command
{
public:
    SetScenesSceneCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "scene-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &sceneCount, "Set the Value of on SceneCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SceneCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSceneCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t sceneCount;
    chip::EndpointId mEndPointId;

private:
    static void SetSceneCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesSceneCountAttributeCommand * command = reinterpret_cast<SetScenesSceneCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Scenes::Attributes::SceneCount::Set(command->mEndPointId, command->sceneCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SceneCount");
        }
    }
};
class SetScenesCurrentSceneAttributeCommand : public Command
{
public:
    SetScenesCurrentSceneAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-scene", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentScene, "Set the Value of on CurrentScene.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentScene");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentScene, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentScene;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentScene(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesCurrentSceneAttributeCommand * command = reinterpret_cast<SetScenesCurrentSceneAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Scenes::Attributes::CurrentScene::Set(command->mEndPointId, command->currentScene);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentScene");
        }
    }
};
class SetScenesCurrentGroupAttributeCommand : public Command
{
public:
    SetScenesCurrentGroupAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-group", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentGroup, "Set the Value of on CurrentGroup.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentGroup");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentGroup, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::GroupId currentGroup;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentGroup(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesCurrentGroupAttributeCommand * command = reinterpret_cast<SetScenesCurrentGroupAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Scenes::Attributes::CurrentGroup::Set(command->mEndPointId, command->currentGroup);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentGroup");
        }
    }
};
class SetScenesSceneValidAttributeCommand : public Command
{
public:
    SetScenesSceneValidAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "scene-valid", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &sceneValid, "Set the Value of on SceneValid.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SceneValid");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSceneValid, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool sceneValid;
    chip::EndpointId mEndPointId;

private:
    static void SetSceneValid(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesSceneValidAttributeCommand * command = reinterpret_cast<SetScenesSceneValidAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Scenes::Attributes::SceneValid::Set(command->mEndPointId, command->sceneValid);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SceneValid");
        }
    }
};
class SetScenesNameSupportAttributeCommand : public Command
{
public:
    SetScenesNameSupportAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "name-support", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &nameSupport, "Set the Value of on NameSupport.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NameSupport");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNameSupport, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t nameSupport;
    chip::EndpointId mEndPointId;

private:
    static void SetNameSupport(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesNameSupportAttributeCommand * command = reinterpret_cast<SetScenesNameSupportAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Scenes::Attributes::NameSupport::Set(command->mEndPointId, command->nameSupport);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NameSupport");
        }
    }
};
class SetScenesLastConfiguredByAttributeCommand : public Command
{
public:
    SetScenesLastConfiguredByAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "last-configured-by", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &lastConfiguredBy, "Set the Value of on LastConfiguredBy.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LastConfiguredBy");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLastConfiguredBy, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::NodeId> lastConfiguredBy;
    chip::EndpointId mEndPointId;

private:
    static void SetLastConfiguredBy(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesLastConfiguredByAttributeCommand * command =
            reinterpret_cast<SetScenesLastConfiguredByAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Scenes::Attributes::LastConfiguredBy::Set(command->mEndPointId, command->lastConfiguredBy);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LastConfiguredBy");
        }
    }
};
class SetScenesFeatureMapAttributeCommand : public Command
{
public:
    SetScenesFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesFeatureMapAttributeCommand * command = reinterpret_cast<SetScenesFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Scenes::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetScenesClusterRevisionAttributeCommand : public Command
{
public:
    SetScenesClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetScenesClusterRevisionAttributeCommand * command = reinterpret_cast<SetScenesClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Scenes::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetOnOffOnOffAttributeCommand : public Command
{
public:
    SetOnOffOnOffAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "on-off", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &onOff, "Set the Value of on OnOff.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OnOff");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOnOff, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool onOff;
    chip::EndpointId mEndPointId;

private:
    static void SetOnOff(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffOnOffAttributeCommand * command = reinterpret_cast<SetOnOffOnOffAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OnOff::Attributes::OnOff::Set(command->mEndPointId, command->onOff);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OnOff");
        }
    }
};
class SetOnOffGlobalSceneControlAttributeCommand : public Command
{
public:
    SetOnOffGlobalSceneControlAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "global-scene-control", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &globalSceneControl, "Set the Value of on GlobalSceneControl.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: GlobalSceneControl");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetGlobalSceneControl, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool globalSceneControl;
    chip::EndpointId mEndPointId;

private:
    static void SetGlobalSceneControl(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffGlobalSceneControlAttributeCommand * command =
            reinterpret_cast<SetOnOffGlobalSceneControlAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OnOff::Attributes::GlobalSceneControl::Set(command->mEndPointId, command->globalSceneControl);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute GlobalSceneControl");
        }
    }
};
class SetOnOffOnTimeAttributeCommand : public Command
{
public:
    SetOnOffOnTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "on-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &onTime, "Set the Value of on OnTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OnTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOnTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t onTime;
    chip::EndpointId mEndPointId;

private:
    static void SetOnTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffOnTimeAttributeCommand * command = reinterpret_cast<SetOnOffOnTimeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OnOff::Attributes::OnTime::Set(command->mEndPointId, command->onTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OnTime");
        }
    }
};
class SetOnOffOffWaitTimeAttributeCommand : public Command
{
public:
    SetOnOffOffWaitTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "off-wait-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &offWaitTime, "Set the Value of on OffWaitTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OffWaitTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOffWaitTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t offWaitTime;
    chip::EndpointId mEndPointId;

private:
    static void SetOffWaitTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffOffWaitTimeAttributeCommand * command = reinterpret_cast<SetOnOffOffWaitTimeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OnOff::Attributes::OffWaitTime::Set(command->mEndPointId, command->offWaitTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OffWaitTime");
        }
    }
};
class SetOnOffStartUpOnOffAttributeCommand : public Command
{
public:
    SetOnOffStartUpOnOffAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "start-up-on-off", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &startUpOnOff, "Set the Value of on StartUpOnOff.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StartUpOnOff");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStartUpOnOff, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::OnOffStartUpOnOff> startUpOnOff;
    chip::EndpointId mEndPointId;

private:
    static void SetStartUpOnOff(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffStartUpOnOffAttributeCommand * command = reinterpret_cast<SetOnOffStartUpOnOffAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OnOff::Attributes::StartUpOnOff::Set(command->mEndPointId, command->startUpOnOff);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StartUpOnOff");
        }
    }
};
class SetOnOffFeatureMapAttributeCommand : public Command
{
public:
    SetOnOffFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffFeatureMapAttributeCommand * command = reinterpret_cast<SetOnOffFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OnOff::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetOnOffClusterRevisionAttributeCommand : public Command
{
public:
    SetOnOffClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffClusterRevisionAttributeCommand * command = reinterpret_cast<SetOnOffClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OnOff::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetOnOffSwitchConfigurationSwitchTypeAttributeCommand : public Command
{
public:
    SetOnOffSwitchConfigurationSwitchTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "switch-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &switchType, "Set the Value of on SwitchType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SwitchType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSwitchType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t switchType;
    chip::EndpointId mEndPointId;

private:
    static void SetSwitchType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffSwitchConfigurationSwitchTypeAttributeCommand * command =
            reinterpret_cast<SetOnOffSwitchConfigurationSwitchTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OnOffSwitchConfiguration::Attributes::SwitchType::Set(command->mEndPointId, command->switchType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SwitchType");
        }
    }
};
class SetOnOffSwitchConfigurationSwitchActionsAttributeCommand : public Command
{
public:
    SetOnOffSwitchConfigurationSwitchActionsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "switch-actions", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &switchActions, "Set the Value of on SwitchActions.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SwitchActions");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSwitchActions, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t switchActions;
    chip::EndpointId mEndPointId;

private:
    static void SetSwitchActions(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffSwitchConfigurationSwitchActionsAttributeCommand * command =
            reinterpret_cast<SetOnOffSwitchConfigurationSwitchActionsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OnOffSwitchConfiguration::Attributes::SwitchActions::Set(
            command->mEndPointId, command->switchActions);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SwitchActions");
        }
    }
};
class SetOnOffSwitchConfigurationFeatureMapAttributeCommand : public Command
{
public:
    SetOnOffSwitchConfigurationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffSwitchConfigurationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetOnOffSwitchConfigurationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OnOffSwitchConfiguration::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetOnOffSwitchConfigurationClusterRevisionAttributeCommand : public Command
{
public:
    SetOnOffSwitchConfigurationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOnOffSwitchConfigurationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetOnOffSwitchConfigurationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OnOffSwitchConfiguration::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetLevelControlCurrentLevelAttributeCommand : public Command
{
public:
    SetLevelControlCurrentLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentLevel, "Set the Value of on CurrentLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> currentLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlCurrentLevelAttributeCommand * command =
            reinterpret_cast<SetLevelControlCurrentLevelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::CurrentLevel::Set(command->mEndPointId, command->currentLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentLevel");
        }
    }
};
class SetLevelControlRemainingTimeAttributeCommand : public Command
{
public:
    SetLevelControlRemainingTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "remaining-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &remainingTime, "Set the Value of on RemainingTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RemainingTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRemainingTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t remainingTime;
    chip::EndpointId mEndPointId;

private:
    static void SetRemainingTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlRemainingTimeAttributeCommand * command =
            reinterpret_cast<SetLevelControlRemainingTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::RemainingTime::Set(command->mEndPointId, command->remainingTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RemainingTime");
        }
    }
};
class SetLevelControlMinLevelAttributeCommand : public Command
{
public:
    SetLevelControlMinLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &minLevel, "Set the Value of on MinLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t minLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetMinLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlMinLevelAttributeCommand * command = reinterpret_cast<SetLevelControlMinLevelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::MinLevel::Set(command->mEndPointId, command->minLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinLevel");
        }
    }
};
class SetLevelControlMaxLevelAttributeCommand : public Command
{
public:
    SetLevelControlMaxLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &maxLevel, "Set the Value of on MaxLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t maxLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlMaxLevelAttributeCommand * command = reinterpret_cast<SetLevelControlMaxLevelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::MaxLevel::Set(command->mEndPointId, command->maxLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxLevel");
        }
    }
};
class SetLevelControlCurrentFrequencyAttributeCommand : public Command
{
public:
    SetLevelControlCurrentFrequencyAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-frequency", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentFrequency, "Set the Value of on CurrentFrequency.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentFrequency");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentFrequency, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t currentFrequency;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentFrequency(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlCurrentFrequencyAttributeCommand * command =
            reinterpret_cast<SetLevelControlCurrentFrequencyAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::CurrentFrequency::Set(command->mEndPointId, command->currentFrequency);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentFrequency");
        }
    }
};
class SetLevelControlMinFrequencyAttributeCommand : public Command
{
public:
    SetLevelControlMinFrequencyAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-frequency", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &minFrequency, "Set the Value of on MinFrequency.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinFrequency");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinFrequency, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t minFrequency;
    chip::EndpointId mEndPointId;

private:
    static void SetMinFrequency(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlMinFrequencyAttributeCommand * command =
            reinterpret_cast<SetLevelControlMinFrequencyAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::MinFrequency::Set(command->mEndPointId, command->minFrequency);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinFrequency");
        }
    }
};
class SetLevelControlMaxFrequencyAttributeCommand : public Command
{
public:
    SetLevelControlMaxFrequencyAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-frequency", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxFrequency, "Set the Value of on MaxFrequency.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxFrequency");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxFrequency, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t maxFrequency;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxFrequency(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlMaxFrequencyAttributeCommand * command =
            reinterpret_cast<SetLevelControlMaxFrequencyAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::MaxFrequency::Set(command->mEndPointId, command->maxFrequency);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxFrequency");
        }
    }
};
class SetLevelControlOptionsAttributeCommand : public Command
{
public:
    SetLevelControlOptionsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "options", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &options, "Set the Value of on Options.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Options");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOptions, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::LevelControl::LevelControlOptions> options;
    chip::EndpointId mEndPointId;

private:
    static void SetOptions(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlOptionsAttributeCommand * command = reinterpret_cast<SetLevelControlOptionsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::LevelControl::Attributes::Options::Set(command->mEndPointId, command->options);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Options");
        }
    }
};
class SetLevelControlOnOffTransitionTimeAttributeCommand : public Command
{
public:
    SetLevelControlOnOffTransitionTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "on-off-transition-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &onOffTransitionTime, "Set the Value of on OnOffTransitionTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OnOffTransitionTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOnOffTransitionTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t onOffTransitionTime;
    chip::EndpointId mEndPointId;

private:
    static void SetOnOffTransitionTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlOnOffTransitionTimeAttributeCommand * command =
            reinterpret_cast<SetLevelControlOnOffTransitionTimeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::LevelControl::Attributes::OnOffTransitionTime::Set(
            command->mEndPointId, command->onOffTransitionTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OnOffTransitionTime");
        }
    }
};
class SetLevelControlOnLevelAttributeCommand : public Command
{
public:
    SetLevelControlOnLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "on-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &onLevel, "Set the Value of on OnLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OnLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOnLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> onLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetOnLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlOnLevelAttributeCommand * command = reinterpret_cast<SetLevelControlOnLevelAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::LevelControl::Attributes::OnLevel::Set(command->mEndPointId, command->onLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OnLevel");
        }
    }
};
class SetLevelControlOnTransitionTimeAttributeCommand : public Command
{
public:
    SetLevelControlOnTransitionTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "on-transition-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &onTransitionTime, "Set the Value of on OnTransitionTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OnTransitionTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOnTransitionTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> onTransitionTime;
    chip::EndpointId mEndPointId;

private:
    static void SetOnTransitionTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlOnTransitionTimeAttributeCommand * command =
            reinterpret_cast<SetLevelControlOnTransitionTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::OnTransitionTime::Set(command->mEndPointId, command->onTransitionTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OnTransitionTime");
        }
    }
};
class SetLevelControlOffTransitionTimeAttributeCommand : public Command
{
public:
    SetLevelControlOffTransitionTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "off-transition-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &offTransitionTime, "Set the Value of on OffTransitionTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OffTransitionTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOffTransitionTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> offTransitionTime;
    chip::EndpointId mEndPointId;

private:
    static void SetOffTransitionTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlOffTransitionTimeAttributeCommand * command =
            reinterpret_cast<SetLevelControlOffTransitionTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::OffTransitionTime::Set(command->mEndPointId, command->offTransitionTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OffTransitionTime");
        }
    }
};
class SetLevelControlDefaultMoveRateAttributeCommand : public Command
{
public:
    SetLevelControlDefaultMoveRateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "default-move-rate", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &defaultMoveRate, "Set the Value of on DefaultMoveRate.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DefaultMoveRate");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDefaultMoveRate, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> defaultMoveRate;
    chip::EndpointId mEndPointId;

private:
    static void SetDefaultMoveRate(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlDefaultMoveRateAttributeCommand * command =
            reinterpret_cast<SetLevelControlDefaultMoveRateAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::DefaultMoveRate::Set(command->mEndPointId, command->defaultMoveRate);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DefaultMoveRate");
        }
    }
};
class SetLevelControlStartUpCurrentLevelAttributeCommand : public Command
{
public:
    SetLevelControlStartUpCurrentLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "start-up-current-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &startUpCurrentLevel, "Set the Value of on StartUpCurrentLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StartUpCurrentLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStartUpCurrentLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> startUpCurrentLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetStartUpCurrentLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlStartUpCurrentLevelAttributeCommand * command =
            reinterpret_cast<SetLevelControlStartUpCurrentLevelAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::LevelControl::Attributes::StartUpCurrentLevel::Set(
            command->mEndPointId, command->startUpCurrentLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StartUpCurrentLevel");
        }
    }
};
class SetLevelControlFeatureMapAttributeCommand : public Command
{
public:
    SetLevelControlFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlFeatureMapAttributeCommand * command =
            reinterpret_cast<SetLevelControlFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetLevelControlClusterRevisionAttributeCommand : public Command
{
public:
    SetLevelControlClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLevelControlClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetLevelControlClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LevelControl::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetBinaryInputBasicActiveTextAttributeCommand : public Command
{
public:
    SetBinaryInputBasicActiveTextAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-text", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &activeText, "Set the Value of on ActiveText.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveText");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveText, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan activeText;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveText(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicActiveTextAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicActiveTextAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::ActiveText::Set(command->mEndPointId, command->activeText);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveText");
        }
    }
};
class SetBinaryInputBasicDescriptionAttributeCommand : public Command
{
public:
    SetBinaryInputBasicDescriptionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "description", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &description, "Set the Value of on Description.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Description");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDescription, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan description;
    chip::EndpointId mEndPointId;

private:
    static void SetDescription(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicDescriptionAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicDescriptionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::Description::Set(command->mEndPointId, command->description);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Description");
        }
    }
};
class SetBinaryInputBasicInactiveTextAttributeCommand : public Command
{
public:
    SetBinaryInputBasicInactiveTextAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "inactive-text", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &inactiveText, "Set the Value of on InactiveText.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InactiveText");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInactiveText, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan inactiveText;
    chip::EndpointId mEndPointId;

private:
    static void SetInactiveText(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicInactiveTextAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicInactiveTextAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::InactiveText::Set(command->mEndPointId, command->inactiveText);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InactiveText");
        }
    }
};
class SetBinaryInputBasicOutOfServiceAttributeCommand : public Command
{
public:
    SetBinaryInputBasicOutOfServiceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "out-of-service", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &outOfService, "Set the Value of on OutOfService.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OutOfService");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOutOfService, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool outOfService;
    chip::EndpointId mEndPointId;

private:
    static void SetOutOfService(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicOutOfServiceAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicOutOfServiceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::OutOfService::Set(command->mEndPointId, command->outOfService);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OutOfService");
        }
    }
};
class SetBinaryInputBasicPolarityAttributeCommand : public Command
{
public:
    SetBinaryInputBasicPolarityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "polarity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &polarity, "Set the Value of on Polarity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Polarity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPolarity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t polarity;
    chip::EndpointId mEndPointId;

private:
    static void SetPolarity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicPolarityAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicPolarityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::Polarity::Set(command->mEndPointId, command->polarity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Polarity");
        }
    }
};
class SetBinaryInputBasicPresentValueAttributeCommand : public Command
{
public:
    SetBinaryInputBasicPresentValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "present-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &presentValue, "Set the Value of on PresentValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PresentValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPresentValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool presentValue;
    chip::EndpointId mEndPointId;

private:
    static void SetPresentValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicPresentValueAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicPresentValueAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::PresentValue::Set(command->mEndPointId, command->presentValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PresentValue");
        }
    }
};
class SetBinaryInputBasicReliabilityAttributeCommand : public Command
{
public:
    SetBinaryInputBasicReliabilityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reliability", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &reliability, "Set the Value of on Reliability.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Reliability");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReliability, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t reliability;
    chip::EndpointId mEndPointId;

private:
    static void SetReliability(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicReliabilityAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicReliabilityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::Reliability::Set(command->mEndPointId, command->reliability);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Reliability");
        }
    }
};
class SetBinaryInputBasicStatusFlagsAttributeCommand : public Command
{
public:
    SetBinaryInputBasicStatusFlagsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "status-flags", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &statusFlags, "Set the Value of on StatusFlags.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StatusFlags");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStatusFlags, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t statusFlags;
    chip::EndpointId mEndPointId;

private:
    static void SetStatusFlags(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicStatusFlagsAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicStatusFlagsAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::StatusFlags::Set(command->mEndPointId, command->statusFlags);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StatusFlags");
        }
    }
};
class SetBinaryInputBasicApplicationTypeAttributeCommand : public Command
{
public:
    SetBinaryInputBasicApplicationTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "application-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &applicationType, "Set the Value of on ApplicationType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ApplicationType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetApplicationType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t applicationType;
    chip::EndpointId mEndPointId;

private:
    static void SetApplicationType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicApplicationTypeAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicApplicationTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::ApplicationType::Set(command->mEndPointId, command->applicationType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ApplicationType");
        }
    }
};
class SetBinaryInputBasicFeatureMapAttributeCommand : public Command
{
public:
    SetBinaryInputBasicFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicFeatureMapAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetBinaryInputBasicClusterRevisionAttributeCommand : public Command
{
public:
    SetBinaryInputBasicClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBinaryInputBasicClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetBinaryInputBasicClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BinaryInputBasic::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetPulseWidthModulationFeatureMapAttributeCommand : public Command
{
public:
    SetPulseWidthModulationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPulseWidthModulationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetPulseWidthModulationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PulseWidthModulation::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetPulseWidthModulationClusterRevisionAttributeCommand : public Command
{
public:
    SetPulseWidthModulationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPulseWidthModulationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetPulseWidthModulationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PulseWidthModulation::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetDescriptorFeatureMapAttributeCommand : public Command
{
public:
    SetDescriptorFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDescriptorFeatureMapAttributeCommand * command = reinterpret_cast<SetDescriptorFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Descriptor::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetDescriptorClusterRevisionAttributeCommand : public Command
{
public:
    SetDescriptorClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDescriptorClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetDescriptorClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Descriptor::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetBindingFeatureMapAttributeCommand : public Command
{
public:
    SetBindingFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBindingFeatureMapAttributeCommand * command = reinterpret_cast<SetBindingFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Binding::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetBindingClusterRevisionAttributeCommand : public Command
{
public:
    SetBindingClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBindingClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetBindingClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Binding::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetAccessControlSubjectsPerAccessControlEntryAttributeCommand : public Command
{
public:
    SetAccessControlSubjectsPerAccessControlEntryAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "subjects-per-access-control-entry", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &subjectsPerAccessControlEntry,
                    "Set the Value of on SubjectsPerAccessControlEntry.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SubjectsPerAccessControlEntry");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSubjectsPerAccessControlEntry, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t subjectsPerAccessControlEntry;
    chip::EndpointId mEndPointId;

private:
    static void SetSubjectsPerAccessControlEntry(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAccessControlSubjectsPerAccessControlEntryAttributeCommand * command =
            reinterpret_cast<SetAccessControlSubjectsPerAccessControlEntryAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::AccessControl::Attributes::SubjectsPerAccessControlEntry::Set(
            command->mEndPointId, command->subjectsPerAccessControlEntry);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SubjectsPerAccessControlEntry");
        }
    }
};
class SetAccessControlTargetsPerAccessControlEntryAttributeCommand : public Command
{
public:
    SetAccessControlTargetsPerAccessControlEntryAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "targets-per-access-control-entry", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &targetsPerAccessControlEntry,
                    "Set the Value of on TargetsPerAccessControlEntry.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TargetsPerAccessControlEntry");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTargetsPerAccessControlEntry, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t targetsPerAccessControlEntry;
    chip::EndpointId mEndPointId;

private:
    static void SetTargetsPerAccessControlEntry(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAccessControlTargetsPerAccessControlEntryAttributeCommand * command =
            reinterpret_cast<SetAccessControlTargetsPerAccessControlEntryAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::AccessControl::Attributes::TargetsPerAccessControlEntry::Set(
            command->mEndPointId, command->targetsPerAccessControlEntry);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TargetsPerAccessControlEntry");
        }
    }
};
class SetAccessControlAccessControlEntriesPerFabricAttributeCommand : public Command
{
public:
    SetAccessControlAccessControlEntriesPerFabricAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "access-control-entries-per-fabric", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &accessControlEntriesPerFabric,
                    "Set the Value of on AccessControlEntriesPerFabric.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AccessControlEntriesPerFabric");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAccessControlEntriesPerFabric, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t accessControlEntriesPerFabric;
    chip::EndpointId mEndPointId;

private:
    static void SetAccessControlEntriesPerFabric(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAccessControlAccessControlEntriesPerFabricAttributeCommand * command =
            reinterpret_cast<SetAccessControlAccessControlEntriesPerFabricAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::AccessControl::Attributes::AccessControlEntriesPerFabric::Set(
            command->mEndPointId, command->accessControlEntriesPerFabric);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AccessControlEntriesPerFabric");
        }
    }
};
class SetAccessControlFeatureMapAttributeCommand : public Command
{
public:
    SetAccessControlFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAccessControlFeatureMapAttributeCommand * command =
            reinterpret_cast<SetAccessControlFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AccessControl::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetAccessControlClusterRevisionAttributeCommand : public Command
{
public:
    SetAccessControlClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAccessControlClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetAccessControlClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AccessControl::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetActionsSetupURLAttributeCommand : public Command
{
public:
    SetActionsSetupURLAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "setup-url", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &setupURL, "Set the Value of on SetupURL.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SetupURL");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSetupURL, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan setupURL;
    chip::EndpointId mEndPointId;

private:
    static void SetSetupURL(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetActionsSetupURLAttributeCommand * command = reinterpret_cast<SetActionsSetupURLAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Actions::Attributes::SetupURL::Set(command->mEndPointId, command->setupURL);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SetupURL");
        }
    }
};
class SetActionsFeatureMapAttributeCommand : public Command
{
public:
    SetActionsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetActionsFeatureMapAttributeCommand * command = reinterpret_cast<SetActionsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Actions::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetActionsClusterRevisionAttributeCommand : public Command
{
public:
    SetActionsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetActionsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetActionsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Actions::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetBasicInformationDataModelRevisionAttributeCommand : public Command
{
public:
    SetBasicInformationDataModelRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "data-model-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &dataModelRevision, "Set the Value of on DataModelRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DataModelRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDataModelRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t dataModelRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetDataModelRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationDataModelRevisionAttributeCommand * command =
            reinterpret_cast<SetBasicInformationDataModelRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BasicInformation::Attributes::DataModelRevision::Set(
            command->mEndPointId, command->dataModelRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DataModelRevision");
        }
    }
};
class SetBasicInformationVendorNameAttributeCommand : public Command
{
public:
    SetBasicInformationVendorNameAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "vendor-name", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &vendorName, "Set the Value of on VendorName.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VendorName");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVendorName, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan vendorName;
    chip::EndpointId mEndPointId;

private:
    static void SetVendorName(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationVendorNameAttributeCommand * command =
            reinterpret_cast<SetBasicInformationVendorNameAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::VendorName::Set(command->mEndPointId, command->vendorName);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VendorName");
        }
    }
};
class SetBasicInformationVendorIDAttributeCommand : public Command
{
public:
    SetBasicInformationVendorIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "vendor-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &vendorID, "Set the Value of on VendorID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VendorID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVendorID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::VendorId vendorID;
    chip::EndpointId mEndPointId;

private:
    static void SetVendorID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationVendorIDAttributeCommand * command =
            reinterpret_cast<SetBasicInformationVendorIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::VendorID::Set(command->mEndPointId, command->vendorID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VendorID");
        }
    }
};
class SetBasicInformationProductNameAttributeCommand : public Command
{
public:
    SetBasicInformationProductNameAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-name", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &productName, "Set the Value of on ProductName.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductName");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductName, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan productName;
    chip::EndpointId mEndPointId;

private:
    static void SetProductName(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationProductNameAttributeCommand * command =
            reinterpret_cast<SetBasicInformationProductNameAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::ProductName::Set(command->mEndPointId, command->productName);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductName");
        }
    }
};
class SetBasicInformationProductIDAttributeCommand : public Command
{
public:
    SetBasicInformationProductIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &productID, "Set the Value of on ProductID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t productID;
    chip::EndpointId mEndPointId;

private:
    static void SetProductID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationProductIDAttributeCommand * command =
            reinterpret_cast<SetBasicInformationProductIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::ProductID::Set(command->mEndPointId, command->productID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductID");
        }
    }
};
class SetBasicInformationNodeLabelAttributeCommand : public Command
{
public:
    SetBasicInformationNodeLabelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "node-label", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &nodeLabel, "Set the Value of on NodeLabel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NodeLabel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNodeLabel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan nodeLabel;
    chip::EndpointId mEndPointId;

private:
    static void SetNodeLabel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationNodeLabelAttributeCommand * command =
            reinterpret_cast<SetBasicInformationNodeLabelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::NodeLabel::Set(command->mEndPointId, command->nodeLabel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NodeLabel");
        }
    }
};
class SetBasicInformationLocationAttributeCommand : public Command
{
public:
    SetBasicInformationLocationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "location", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &location, "Set the Value of on Location.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Location");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLocation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan location;
    chip::EndpointId mEndPointId;

private:
    static void SetLocation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationLocationAttributeCommand * command =
            reinterpret_cast<SetBasicInformationLocationAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::Location::Set(command->mEndPointId, command->location);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Location");
        }
    }
};
class SetBasicInformationHardwareVersionAttributeCommand : public Command
{
public:
    SetBasicInformationHardwareVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "hardware-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &hardwareVersion, "Set the Value of on HardwareVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: HardwareVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetHardwareVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t hardwareVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetHardwareVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationHardwareVersionAttributeCommand * command =
            reinterpret_cast<SetBasicInformationHardwareVersionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::HardwareVersion::Set(command->mEndPointId, command->hardwareVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute HardwareVersion");
        }
    }
};
class SetBasicInformationHardwareVersionStringAttributeCommand : public Command
{
public:
    SetBasicInformationHardwareVersionStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "hardware-version-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &hardwareVersionString, "Set the Value of on HardwareVersionString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: HardwareVersionString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetHardwareVersionString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan hardwareVersionString;
    chip::EndpointId mEndPointId;

private:
    static void SetHardwareVersionString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationHardwareVersionStringAttributeCommand * command =
            reinterpret_cast<SetBasicInformationHardwareVersionStringAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BasicInformation::Attributes::HardwareVersionString::Set(
            command->mEndPointId, command->hardwareVersionString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute HardwareVersionString");
        }
    }
};
class SetBasicInformationSoftwareVersionAttributeCommand : public Command
{
public:
    SetBasicInformationSoftwareVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "software-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &softwareVersion, "Set the Value of on SoftwareVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SoftwareVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSoftwareVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t softwareVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetSoftwareVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationSoftwareVersionAttributeCommand * command =
            reinterpret_cast<SetBasicInformationSoftwareVersionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::SoftwareVersion::Set(command->mEndPointId, command->softwareVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SoftwareVersion");
        }
    }
};
class SetBasicInformationSoftwareVersionStringAttributeCommand : public Command
{
public:
    SetBasicInformationSoftwareVersionStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "software-version-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &softwareVersionString, "Set the Value of on SoftwareVersionString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SoftwareVersionString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSoftwareVersionString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan softwareVersionString;
    chip::EndpointId mEndPointId;

private:
    static void SetSoftwareVersionString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationSoftwareVersionStringAttributeCommand * command =
            reinterpret_cast<SetBasicInformationSoftwareVersionStringAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BasicInformation::Attributes::SoftwareVersionString::Set(
            command->mEndPointId, command->softwareVersionString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SoftwareVersionString");
        }
    }
};
class SetBasicInformationManufacturingDateAttributeCommand : public Command
{
public:
    SetBasicInformationManufacturingDateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "manufacturing-date", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &manufacturingDate, "Set the Value of on ManufacturingDate.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ManufacturingDate");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetManufacturingDate, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan manufacturingDate;
    chip::EndpointId mEndPointId;

private:
    static void SetManufacturingDate(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationManufacturingDateAttributeCommand * command =
            reinterpret_cast<SetBasicInformationManufacturingDateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BasicInformation::Attributes::ManufacturingDate::Set(
            command->mEndPointId, command->manufacturingDate);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ManufacturingDate");
        }
    }
};
class SetBasicInformationPartNumberAttributeCommand : public Command
{
public:
    SetBasicInformationPartNumberAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "part-number", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &partNumber, "Set the Value of on PartNumber.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PartNumber");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPartNumber, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan partNumber;
    chip::EndpointId mEndPointId;

private:
    static void SetPartNumber(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationPartNumberAttributeCommand * command =
            reinterpret_cast<SetBasicInformationPartNumberAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::PartNumber::Set(command->mEndPointId, command->partNumber);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PartNumber");
        }
    }
};
class SetBasicInformationProductURLAttributeCommand : public Command
{
public:
    SetBasicInformationProductURLAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-url", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &productURL, "Set the Value of on ProductURL.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductURL");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductURL, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan productURL;
    chip::EndpointId mEndPointId;

private:
    static void SetProductURL(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationProductURLAttributeCommand * command =
            reinterpret_cast<SetBasicInformationProductURLAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::ProductURL::Set(command->mEndPointId, command->productURL);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductURL");
        }
    }
};
class SetBasicInformationProductLabelAttributeCommand : public Command
{
public:
    SetBasicInformationProductLabelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-label", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &productLabel, "Set the Value of on ProductLabel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductLabel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductLabel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan productLabel;
    chip::EndpointId mEndPointId;

private:
    static void SetProductLabel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationProductLabelAttributeCommand * command =
            reinterpret_cast<SetBasicInformationProductLabelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::ProductLabel::Set(command->mEndPointId, command->productLabel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductLabel");
        }
    }
};
class SetBasicInformationSerialNumberAttributeCommand : public Command
{
public:
    SetBasicInformationSerialNumberAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "serial-number", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &serialNumber, "Set the Value of on SerialNumber.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SerialNumber");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSerialNumber, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan serialNumber;
    chip::EndpointId mEndPointId;

private:
    static void SetSerialNumber(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationSerialNumberAttributeCommand * command =
            reinterpret_cast<SetBasicInformationSerialNumberAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::SerialNumber::Set(command->mEndPointId, command->serialNumber);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SerialNumber");
        }
    }
};
class SetBasicInformationLocalConfigDisabledAttributeCommand : public Command
{
public:
    SetBasicInformationLocalConfigDisabledAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "local-config-disabled", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &localConfigDisabled, "Set the Value of on LocalConfigDisabled.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LocalConfigDisabled");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLocalConfigDisabled, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool localConfigDisabled;
    chip::EndpointId mEndPointId;

private:
    static void SetLocalConfigDisabled(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationLocalConfigDisabledAttributeCommand * command =
            reinterpret_cast<SetBasicInformationLocalConfigDisabledAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BasicInformation::Attributes::LocalConfigDisabled::Set(
            command->mEndPointId, command->localConfigDisabled);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LocalConfigDisabled");
        }
    }
};
class SetBasicInformationReachableAttributeCommand : public Command
{
public:
    SetBasicInformationReachableAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reachable", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &reachable, "Set the Value of on Reachable.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Reachable");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReachable, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool reachable;
    chip::EndpointId mEndPointId;

private:
    static void SetReachable(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationReachableAttributeCommand * command =
            reinterpret_cast<SetBasicInformationReachableAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::Reachable::Set(command->mEndPointId, command->reachable);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Reachable");
        }
    }
};
class SetBasicInformationUniqueIDAttributeCommand : public Command
{
public:
    SetBasicInformationUniqueIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unique-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &uniqueID, "Set the Value of on UniqueID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UniqueID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUniqueID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan uniqueID;
    chip::EndpointId mEndPointId;

private:
    static void SetUniqueID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationUniqueIDAttributeCommand * command =
            reinterpret_cast<SetBasicInformationUniqueIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::UniqueID::Set(command->mEndPointId, command->uniqueID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UniqueID");
        }
    }
};
class SetBasicInformationFeatureMapAttributeCommand : public Command
{
public:
    SetBasicInformationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetBasicInformationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetBasicInformationClusterRevisionAttributeCommand : public Command
{
public:
    SetBasicInformationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBasicInformationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetBasicInformationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BasicInformation::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetOtaSoftwareUpdateProviderFeatureMapAttributeCommand : public Command
{
public:
    SetOtaSoftwareUpdateProviderFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOtaSoftwareUpdateProviderFeatureMapAttributeCommand * command =
            reinterpret_cast<SetOtaSoftwareUpdateProviderFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OtaSoftwareUpdateProvider::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetOtaSoftwareUpdateProviderClusterRevisionAttributeCommand : public Command
{
public:
    SetOtaSoftwareUpdateProviderClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOtaSoftwareUpdateProviderClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetOtaSoftwareUpdateProviderClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OtaSoftwareUpdateProvider::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetOtaSoftwareUpdateRequestorUpdatePossibleAttributeCommand : public Command
{
public:
    SetOtaSoftwareUpdateRequestorUpdatePossibleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "update-possible", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &updatePossible, "Set the Value of on UpdatePossible.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UpdatePossible");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUpdatePossible, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool updatePossible;
    chip::EndpointId mEndPointId;

private:
    static void SetUpdatePossible(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOtaSoftwareUpdateRequestorUpdatePossibleAttributeCommand * command =
            reinterpret_cast<SetOtaSoftwareUpdateRequestorUpdatePossibleAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OtaSoftwareUpdateRequestor::Attributes::UpdatePossible::Set(
            command->mEndPointId, command->updatePossible);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UpdatePossible");
        }
    }
};
class SetOtaSoftwareUpdateRequestorUpdateStateAttributeCommand : public Command
{
public:
    SetOtaSoftwareUpdateRequestorUpdateStateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "update-state", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &updateState, "Set the Value of on UpdateState.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UpdateState");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUpdateState, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::OtaSoftwareUpdateRequestor::OTAUpdateStateEnum updateState;
    chip::EndpointId mEndPointId;

private:
    static void SetUpdateState(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOtaSoftwareUpdateRequestorUpdateStateAttributeCommand * command =
            reinterpret_cast<SetOtaSoftwareUpdateRequestorUpdateStateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OtaSoftwareUpdateRequestor::Attributes::UpdateState::Set(command->mEndPointId,
                                                                                                             command->updateState);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UpdateState");
        }
    }
};
class SetOtaSoftwareUpdateRequestorUpdateStateProgressAttributeCommand : public Command
{
public:
    SetOtaSoftwareUpdateRequestorUpdateStateProgressAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "update-state-progress", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &updateStateProgress, "Set the Value of on UpdateStateProgress.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UpdateStateProgress");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUpdateStateProgress, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> updateStateProgress;
    chip::EndpointId mEndPointId;

private:
    static void SetUpdateStateProgress(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOtaSoftwareUpdateRequestorUpdateStateProgressAttributeCommand * command =
            reinterpret_cast<SetOtaSoftwareUpdateRequestorUpdateStateProgressAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OtaSoftwareUpdateRequestor::Attributes::UpdateStateProgress::Set(
            command->mEndPointId, command->updateStateProgress);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UpdateStateProgress");
        }
    }
};
class SetOtaSoftwareUpdateRequestorFeatureMapAttributeCommand : public Command
{
public:
    SetOtaSoftwareUpdateRequestorFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOtaSoftwareUpdateRequestorFeatureMapAttributeCommand * command =
            reinterpret_cast<SetOtaSoftwareUpdateRequestorFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OtaSoftwareUpdateRequestor::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetOtaSoftwareUpdateRequestorClusterRevisionAttributeCommand : public Command
{
public:
    SetOtaSoftwareUpdateRequestorClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOtaSoftwareUpdateRequestorClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetOtaSoftwareUpdateRequestorClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OtaSoftwareUpdateRequestor::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetLocalizationConfigurationActiveLocaleAttributeCommand : public Command
{
public:
    SetLocalizationConfigurationActiveLocaleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-locale", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &activeLocale, "Set the Value of on ActiveLocale.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveLocale");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveLocale, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan activeLocale;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveLocale(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLocalizationConfigurationActiveLocaleAttributeCommand * command =
            reinterpret_cast<SetLocalizationConfigurationActiveLocaleAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::LocalizationConfiguration::Attributes::ActiveLocale::Set(command->mEndPointId,
                                                                                                             command->activeLocale);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveLocale");
        }
    }
};
class SetLocalizationConfigurationFeatureMapAttributeCommand : public Command
{
public:
    SetLocalizationConfigurationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLocalizationConfigurationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetLocalizationConfigurationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LocalizationConfiguration::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetLocalizationConfigurationClusterRevisionAttributeCommand : public Command
{
public:
    SetLocalizationConfigurationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLocalizationConfigurationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetLocalizationConfigurationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::LocalizationConfiguration::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetTimeFormatLocalizationHourFormatAttributeCommand : public Command
{
public:
    SetTimeFormatLocalizationHourFormatAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "hour-format", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &hourFormat, "Set the Value of on HourFormat.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: HourFormat");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetHourFormat, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::TimeFormatLocalization::HourFormat hourFormat;
    chip::EndpointId mEndPointId;

private:
    static void SetHourFormat(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeFormatLocalizationHourFormatAttributeCommand * command =
            reinterpret_cast<SetTimeFormatLocalizationHourFormatAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeFormatLocalization::Attributes::HourFormat::Set(command->mEndPointId, command->hourFormat);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute HourFormat");
        }
    }
};
class SetTimeFormatLocalizationActiveCalendarTypeAttributeCommand : public Command
{
public:
    SetTimeFormatLocalizationActiveCalendarTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-calendar-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &activeCalendarType, "Set the Value of on ActiveCalendarType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveCalendarType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveCalendarType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::TimeFormatLocalization::CalendarType activeCalendarType;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveCalendarType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeFormatLocalizationActiveCalendarTypeAttributeCommand * command =
            reinterpret_cast<SetTimeFormatLocalizationActiveCalendarTypeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TimeFormatLocalization::Attributes::ActiveCalendarType::Set(
            command->mEndPointId, command->activeCalendarType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveCalendarType");
        }
    }
};
class SetTimeFormatLocalizationFeatureMapAttributeCommand : public Command
{
public:
    SetTimeFormatLocalizationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeFormatLocalizationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetTimeFormatLocalizationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeFormatLocalization::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetTimeFormatLocalizationClusterRevisionAttributeCommand : public Command
{
public:
    SetTimeFormatLocalizationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeFormatLocalizationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetTimeFormatLocalizationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TimeFormatLocalization::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetUnitLocalizationTemperatureUnitAttributeCommand : public Command
{
public:
    SetUnitLocalizationTemperatureUnitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "temperature-unit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &temperatureUnit, "Set the Value of on TemperatureUnit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TemperatureUnit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTemperatureUnit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::UnitLocalization::TempUnit temperatureUnit;
    chip::EndpointId mEndPointId;

private:
    static void SetTemperatureUnit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitLocalizationTemperatureUnitAttributeCommand * command =
            reinterpret_cast<SetUnitLocalizationTemperatureUnitAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitLocalization::Attributes::TemperatureUnit::Set(command->mEndPointId, command->temperatureUnit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TemperatureUnit");
        }
    }
};
class SetUnitLocalizationFeatureMapAttributeCommand : public Command
{
public:
    SetUnitLocalizationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitLocalizationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetUnitLocalizationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitLocalization::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetUnitLocalizationClusterRevisionAttributeCommand : public Command
{
public:
    SetUnitLocalizationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitLocalizationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetUnitLocalizationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitLocalization::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetPowerSourceConfigurationFeatureMapAttributeCommand : public Command
{
public:
    SetPowerSourceConfigurationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceConfigurationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetPowerSourceConfigurationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSourceConfiguration::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetPowerSourceConfigurationClusterRevisionAttributeCommand : public Command
{
public:
    SetPowerSourceConfigurationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceConfigurationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetPowerSourceConfigurationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSourceConfiguration::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetPowerSourceStatusAttributeCommand : public Command
{
public:
    SetPowerSourceStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &status, "Set the Value of on Status.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Status");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PowerSource::PowerSourceStatusEnum status;
    chip::EndpointId mEndPointId;

private:
    static void SetStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceStatusAttributeCommand * command = reinterpret_cast<SetPowerSourceStatusAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::Status::Set(command->mEndPointId, command->status);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Status");
        }
    }
};
class SetPowerSourceOrderAttributeCommand : public Command
{
public:
    SetPowerSourceOrderAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "order", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &order, "Set the Value of on Order.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Order");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOrder, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t order;
    chip::EndpointId mEndPointId;

private:
    static void SetOrder(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceOrderAttributeCommand * command = reinterpret_cast<SetPowerSourceOrderAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::Order::Set(command->mEndPointId, command->order);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Order");
        }
    }
};
class SetPowerSourceDescriptionAttributeCommand : public Command
{
public:
    SetPowerSourceDescriptionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "description", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &description, "Set the Value of on Description.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Description");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDescription, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan description;
    chip::EndpointId mEndPointId;

private:
    static void SetDescription(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceDescriptionAttributeCommand * command =
            reinterpret_cast<SetPowerSourceDescriptionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::Description::Set(command->mEndPointId, command->description);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Description");
        }
    }
};
class SetPowerSourceWiredAssessedInputVoltageAttributeCommand : public Command
{
public:
    SetPowerSourceWiredAssessedInputVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wired-assessed-input-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &wiredAssessedInputVoltage, "Set the Value of on WiredAssessedInputVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiredAssessedInputVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiredAssessedInputVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> wiredAssessedInputVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetWiredAssessedInputVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceWiredAssessedInputVoltageAttributeCommand * command =
            reinterpret_cast<SetPowerSourceWiredAssessedInputVoltageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::WiredAssessedInputVoltage::Set(
            command->mEndPointId, command->wiredAssessedInputVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiredAssessedInputVoltage");
        }
    }
};
class SetPowerSourceWiredAssessedInputFrequencyAttributeCommand : public Command
{
public:
    SetPowerSourceWiredAssessedInputFrequencyAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wired-assessed-input-frequency", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &wiredAssessedInputFrequency,
                    "Set the Value of on WiredAssessedInputFrequency.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiredAssessedInputFrequency");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiredAssessedInputFrequency, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> wiredAssessedInputFrequency;
    chip::EndpointId mEndPointId;

private:
    static void SetWiredAssessedInputFrequency(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceWiredAssessedInputFrequencyAttributeCommand * command =
            reinterpret_cast<SetPowerSourceWiredAssessedInputFrequencyAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::WiredAssessedInputFrequency::Set(
            command->mEndPointId, command->wiredAssessedInputFrequency);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiredAssessedInputFrequency");
        }
    }
};
class SetPowerSourceWiredCurrentTypeAttributeCommand : public Command
{
public:
    SetPowerSourceWiredCurrentTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wired-current-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &wiredCurrentType, "Set the Value of on WiredCurrentType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiredCurrentType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiredCurrentType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PowerSource::WiredCurrentTypeEnum wiredCurrentType;
    chip::EndpointId mEndPointId;

private:
    static void SetWiredCurrentType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceWiredCurrentTypeAttributeCommand * command =
            reinterpret_cast<SetPowerSourceWiredCurrentTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::WiredCurrentType::Set(command->mEndPointId, command->wiredCurrentType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiredCurrentType");
        }
    }
};
class SetPowerSourceWiredAssessedCurrentAttributeCommand : public Command
{
public:
    SetPowerSourceWiredAssessedCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wired-assessed-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &wiredAssessedCurrent, "Set the Value of on WiredAssessedCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiredAssessedCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiredAssessedCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> wiredAssessedCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetWiredAssessedCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceWiredAssessedCurrentAttributeCommand * command =
            reinterpret_cast<SetPowerSourceWiredAssessedCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::WiredAssessedCurrent::Set(
            command->mEndPointId, command->wiredAssessedCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiredAssessedCurrent");
        }
    }
};
class SetPowerSourceWiredNominalVoltageAttributeCommand : public Command
{
public:
    SetPowerSourceWiredNominalVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wired-nominal-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &wiredNominalVoltage, "Set the Value of on WiredNominalVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiredNominalVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiredNominalVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t wiredNominalVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetWiredNominalVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceWiredNominalVoltageAttributeCommand * command =
            reinterpret_cast<SetPowerSourceWiredNominalVoltageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::WiredNominalVoltage::Set(command->mEndPointId,
                                                                                                      command->wiredNominalVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiredNominalVoltage");
        }
    }
};
class SetPowerSourceWiredMaximumCurrentAttributeCommand : public Command
{
public:
    SetPowerSourceWiredMaximumCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wired-maximum-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &wiredMaximumCurrent, "Set the Value of on WiredMaximumCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiredMaximumCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiredMaximumCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t wiredMaximumCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetWiredMaximumCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceWiredMaximumCurrentAttributeCommand * command =
            reinterpret_cast<SetPowerSourceWiredMaximumCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::WiredMaximumCurrent::Set(command->mEndPointId,
                                                                                                      command->wiredMaximumCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiredMaximumCurrent");
        }
    }
};
class SetPowerSourceWiredPresentAttributeCommand : public Command
{
public:
    SetPowerSourceWiredPresentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wired-present", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &wiredPresent, "Set the Value of on WiredPresent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiredPresent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiredPresent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool wiredPresent;
    chip::EndpointId mEndPointId;

private:
    static void SetWiredPresent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceWiredPresentAttributeCommand * command =
            reinterpret_cast<SetPowerSourceWiredPresentAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::WiredPresent::Set(command->mEndPointId, command->wiredPresent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiredPresent");
        }
    }
};
class SetPowerSourceBatVoltageAttributeCommand : public Command
{
public:
    SetPowerSourceBatVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &batVoltage, "Set the Value of on BatVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> batVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetBatVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatVoltageAttributeCommand * command = reinterpret_cast<SetPowerSourceBatVoltageAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatVoltage::Set(command->mEndPointId, command->batVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatVoltage");
        }
    }
};
class SetPowerSourceBatPercentRemainingAttributeCommand : public Command
{
public:
    SetPowerSourceBatPercentRemainingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-percent-remaining", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &batPercentRemaining, "Set the Value of on BatPercentRemaining.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatPercentRemaining");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatPercentRemaining, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> batPercentRemaining;
    chip::EndpointId mEndPointId;

private:
    static void SetBatPercentRemaining(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatPercentRemainingAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatPercentRemainingAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatPercentRemaining::Set(command->mEndPointId,
                                                                                                      command->batPercentRemaining);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatPercentRemaining");
        }
    }
};
class SetPowerSourceBatTimeRemainingAttributeCommand : public Command
{
public:
    SetPowerSourceBatTimeRemainingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-time-remaining", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &batTimeRemaining, "Set the Value of on BatTimeRemaining.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatTimeRemaining");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatTimeRemaining, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> batTimeRemaining;
    chip::EndpointId mEndPointId;

private:
    static void SetBatTimeRemaining(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatTimeRemainingAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatTimeRemainingAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatTimeRemaining::Set(command->mEndPointId, command->batTimeRemaining);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatTimeRemaining");
        }
    }
};
class SetPowerSourceBatChargeLevelAttributeCommand : public Command
{
public:
    SetPowerSourceBatChargeLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-charge-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &batChargeLevel, "Set the Value of on BatChargeLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatChargeLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatChargeLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PowerSource::BatChargeLevelEnum batChargeLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetBatChargeLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatChargeLevelAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatChargeLevelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatChargeLevel::Set(command->mEndPointId, command->batChargeLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatChargeLevel");
        }
    }
};
class SetPowerSourceBatReplacementNeededAttributeCommand : public Command
{
public:
    SetPowerSourceBatReplacementNeededAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-replacement-needed", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &batReplacementNeeded, "Set the Value of on BatReplacementNeeded.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatReplacementNeeded");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatReplacementNeeded, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool batReplacementNeeded;
    chip::EndpointId mEndPointId;

private:
    static void SetBatReplacementNeeded(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatReplacementNeededAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatReplacementNeededAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatReplacementNeeded::Set(
            command->mEndPointId, command->batReplacementNeeded);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatReplacementNeeded");
        }
    }
};
class SetPowerSourceBatReplaceabilityAttributeCommand : public Command
{
public:
    SetPowerSourceBatReplaceabilityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-replaceability", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &batReplaceability, "Set the Value of on BatReplaceability.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatReplaceability");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatReplaceability, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PowerSource::BatReplaceabilityEnum batReplaceability;
    chip::EndpointId mEndPointId;

private:
    static void SetBatReplaceability(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatReplaceabilityAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatReplaceabilityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatReplaceability::Set(command->mEndPointId, command->batReplaceability);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatReplaceability");
        }
    }
};
class SetPowerSourceBatPresentAttributeCommand : public Command
{
public:
    SetPowerSourceBatPresentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-present", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &batPresent, "Set the Value of on BatPresent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatPresent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatPresent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool batPresent;
    chip::EndpointId mEndPointId;

private:
    static void SetBatPresent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatPresentAttributeCommand * command = reinterpret_cast<SetPowerSourceBatPresentAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatPresent::Set(command->mEndPointId, command->batPresent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatPresent");
        }
    }
};
class SetPowerSourceBatReplacementDescriptionAttributeCommand : public Command
{
public:
    SetPowerSourceBatReplacementDescriptionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-replacement-description", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &batReplacementDescription, "Set the Value of on BatReplacementDescription.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatReplacementDescription");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatReplacementDescription, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan batReplacementDescription;
    chip::EndpointId mEndPointId;

private:
    static void SetBatReplacementDescription(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatReplacementDescriptionAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatReplacementDescriptionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatReplacementDescription::Set(
            command->mEndPointId, command->batReplacementDescription);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatReplacementDescription");
        }
    }
};
class SetPowerSourceBatCommonDesignationAttributeCommand : public Command
{
public:
    SetPowerSourceBatCommonDesignationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-common-designation", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &batCommonDesignation, "Set the Value of on BatCommonDesignation.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatCommonDesignation");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatCommonDesignation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PowerSource::BatCommonDesignationEnum batCommonDesignation;
    chip::EndpointId mEndPointId;

private:
    static void SetBatCommonDesignation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatCommonDesignationAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatCommonDesignationAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatCommonDesignation::Set(
            command->mEndPointId, command->batCommonDesignation);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatCommonDesignation");
        }
    }
};
class SetPowerSourceBatANSIDesignationAttributeCommand : public Command
{
public:
    SetPowerSourceBatANSIDesignationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-ansidesignation", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &batANSIDesignation, "Set the Value of on BatANSIDesignation.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatANSIDesignation");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatANSIDesignation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan batANSIDesignation;
    chip::EndpointId mEndPointId;

private:
    static void SetBatANSIDesignation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatANSIDesignationAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatANSIDesignationAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatANSIDesignation::Set(command->mEndPointId,
                                                                                                     command->batANSIDesignation);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatANSIDesignation");
        }
    }
};
class SetPowerSourceBatIECDesignationAttributeCommand : public Command
{
public:
    SetPowerSourceBatIECDesignationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-iecdesignation", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &batIECDesignation, "Set the Value of on BatIECDesignation.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatIECDesignation");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatIECDesignation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan batIECDesignation;
    chip::EndpointId mEndPointId;

private:
    static void SetBatIECDesignation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatIECDesignationAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatIECDesignationAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatIECDesignation::Set(command->mEndPointId, command->batIECDesignation);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatIECDesignation");
        }
    }
};
class SetPowerSourceBatApprovedChemistryAttributeCommand : public Command
{
public:
    SetPowerSourceBatApprovedChemistryAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-approved-chemistry", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &batApprovedChemistry, "Set the Value of on BatApprovedChemistry.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatApprovedChemistry");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatApprovedChemistry, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PowerSource::BatApprovedChemistryEnum batApprovedChemistry;
    chip::EndpointId mEndPointId;

private:
    static void SetBatApprovedChemistry(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatApprovedChemistryAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatApprovedChemistryAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatApprovedChemistry::Set(
            command->mEndPointId, command->batApprovedChemistry);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatApprovedChemistry");
        }
    }
};
class SetPowerSourceBatCapacityAttributeCommand : public Command
{
public:
    SetPowerSourceBatCapacityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-capacity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &batCapacity, "Set the Value of on BatCapacity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatCapacity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatCapacity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t batCapacity;
    chip::EndpointId mEndPointId;

private:
    static void SetBatCapacity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatCapacityAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatCapacityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatCapacity::Set(command->mEndPointId, command->batCapacity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatCapacity");
        }
    }
};
class SetPowerSourceBatQuantityAttributeCommand : public Command
{
public:
    SetPowerSourceBatQuantityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-quantity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &batQuantity, "Set the Value of on BatQuantity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatQuantity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatQuantity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t batQuantity;
    chip::EndpointId mEndPointId;

private:
    static void SetBatQuantity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatQuantityAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatQuantityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatQuantity::Set(command->mEndPointId, command->batQuantity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatQuantity");
        }
    }
};
class SetPowerSourceBatChargeStateAttributeCommand : public Command
{
public:
    SetPowerSourceBatChargeStateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-charge-state", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &batChargeState, "Set the Value of on BatChargeState.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatChargeState");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatChargeState, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PowerSource::BatChargeStateEnum batChargeState;
    chip::EndpointId mEndPointId;

private:
    static void SetBatChargeState(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatChargeStateAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatChargeStateAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::BatChargeState::Set(command->mEndPointId, command->batChargeState);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatChargeState");
        }
    }
};
class SetPowerSourceBatTimeToFullChargeAttributeCommand : public Command
{
public:
    SetPowerSourceBatTimeToFullChargeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-time-to-full-charge", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &batTimeToFullCharge, "Set the Value of on BatTimeToFullCharge.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatTimeToFullCharge");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatTimeToFullCharge, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> batTimeToFullCharge;
    chip::EndpointId mEndPointId;

private:
    static void SetBatTimeToFullCharge(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatTimeToFullChargeAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatTimeToFullChargeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatTimeToFullCharge::Set(command->mEndPointId,
                                                                                                      command->batTimeToFullCharge);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatTimeToFullCharge");
        }
    }
};
class SetPowerSourceBatFunctionalWhileChargingAttributeCommand : public Command
{
public:
    SetPowerSourceBatFunctionalWhileChargingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-functional-while-charging", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &batFunctionalWhileCharging, "Set the Value of on BatFunctionalWhileCharging.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatFunctionalWhileCharging");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatFunctionalWhileCharging, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool batFunctionalWhileCharging;
    chip::EndpointId mEndPointId;

private:
    static void SetBatFunctionalWhileCharging(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatFunctionalWhileChargingAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatFunctionalWhileChargingAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatFunctionalWhileCharging::Set(
            command->mEndPointId, command->batFunctionalWhileCharging);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatFunctionalWhileCharging");
        }
    }
};
class SetPowerSourceBatChargingCurrentAttributeCommand : public Command
{
public:
    SetPowerSourceBatChargingCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bat-charging-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &batChargingCurrent, "Set the Value of on BatChargingCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BatChargingCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBatChargingCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> batChargingCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetBatChargingCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceBatChargingCurrentAttributeCommand * command =
            reinterpret_cast<SetPowerSourceBatChargingCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PowerSource::Attributes::BatChargingCurrent::Set(command->mEndPointId,
                                                                                                     command->batChargingCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BatChargingCurrent");
        }
    }
};
class SetPowerSourceFeatureMapAttributeCommand : public Command
{
public:
    SetPowerSourceFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceFeatureMapAttributeCommand * command = reinterpret_cast<SetPowerSourceFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetPowerSourceClusterRevisionAttributeCommand : public Command
{
public:
    SetPowerSourceClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPowerSourceClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetPowerSourceClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PowerSource::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetGeneralCommissioningBreadcrumbAttributeCommand : public Command
{
public:
    SetGeneralCommissioningBreadcrumbAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "breadcrumb", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &breadcrumb, "Set the Value of on Breadcrumb.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Breadcrumb");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBreadcrumb, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t breadcrumb;
    chip::EndpointId mEndPointId;

private:
    static void SetBreadcrumb(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralCommissioningBreadcrumbAttributeCommand * command =
            reinterpret_cast<SetGeneralCommissioningBreadcrumbAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::GeneralCommissioning::Attributes::Breadcrumb::Set(command->mEndPointId, command->breadcrumb);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Breadcrumb");
        }
    }
};
class SetGeneralCommissioningRegulatoryConfigAttributeCommand : public Command
{
public:
    SetGeneralCommissioningRegulatoryConfigAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "regulatory-config", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &regulatoryConfig, "Set the Value of on RegulatoryConfig.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RegulatoryConfig");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRegulatoryConfig, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::GeneralCommissioning::RegulatoryLocationType regulatoryConfig;
    chip::EndpointId mEndPointId;

private:
    static void SetRegulatoryConfig(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralCommissioningRegulatoryConfigAttributeCommand * command =
            reinterpret_cast<SetGeneralCommissioningRegulatoryConfigAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GeneralCommissioning::Attributes::RegulatoryConfig::Set(
            command->mEndPointId, command->regulatoryConfig);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RegulatoryConfig");
        }
    }
};
class SetGeneralCommissioningLocationCapabilityAttributeCommand : public Command
{
public:
    SetGeneralCommissioningLocationCapabilityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "location-capability", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &locationCapability, "Set the Value of on LocationCapability.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LocationCapability");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLocationCapability, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::GeneralCommissioning::RegulatoryLocationType locationCapability;
    chip::EndpointId mEndPointId;

private:
    static void SetLocationCapability(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralCommissioningLocationCapabilityAttributeCommand * command =
            reinterpret_cast<SetGeneralCommissioningLocationCapabilityAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GeneralCommissioning::Attributes::LocationCapability::Set(
            command->mEndPointId, command->locationCapability);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LocationCapability");
        }
    }
};
class SetGeneralCommissioningSupportsConcurrentConnectionAttributeCommand : public Command
{
public:
    SetGeneralCommissioningSupportsConcurrentConnectionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "supports-concurrent-connection", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &supportsConcurrentConnection, "Set the Value of on SupportsConcurrentConnection.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SupportsConcurrentConnection");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSupportsConcurrentConnection, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool supportsConcurrentConnection;
    chip::EndpointId mEndPointId;

private:
    static void SetSupportsConcurrentConnection(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralCommissioningSupportsConcurrentConnectionAttributeCommand * command =
            reinterpret_cast<SetGeneralCommissioningSupportsConcurrentConnectionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GeneralCommissioning::Attributes::SupportsConcurrentConnection::Set(
            command->mEndPointId, command->supportsConcurrentConnection);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SupportsConcurrentConnection");
        }
    }
};
class SetGeneralCommissioningFeatureMapAttributeCommand : public Command
{
public:
    SetGeneralCommissioningFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralCommissioningFeatureMapAttributeCommand * command =
            reinterpret_cast<SetGeneralCommissioningFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::GeneralCommissioning::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetGeneralCommissioningClusterRevisionAttributeCommand : public Command
{
public:
    SetGeneralCommissioningClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralCommissioningClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetGeneralCommissioningClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GeneralCommissioning::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetNetworkCommissioningMaxNetworksAttributeCommand : public Command
{
public:
    SetNetworkCommissioningMaxNetworksAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-networks", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &maxNetworks, "Set the Value of on MaxNetworks.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxNetworks");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxNetworks, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t maxNetworks;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxNetworks(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningMaxNetworksAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningMaxNetworksAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::NetworkCommissioning::Attributes::MaxNetworks::Set(command->mEndPointId, command->maxNetworks);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxNetworks");
        }
    }
};
class SetNetworkCommissioningScanMaxTimeSecondsAttributeCommand : public Command
{
public:
    SetNetworkCommissioningScanMaxTimeSecondsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "scan-max-time-seconds", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &scanMaxTimeSeconds, "Set the Value of on ScanMaxTimeSeconds.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ScanMaxTimeSeconds");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetScanMaxTimeSeconds, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t scanMaxTimeSeconds;
    chip::EndpointId mEndPointId;

private:
    static void SetScanMaxTimeSeconds(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningScanMaxTimeSecondsAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningScanMaxTimeSecondsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::NetworkCommissioning::Attributes::ScanMaxTimeSeconds::Set(
            command->mEndPointId, command->scanMaxTimeSeconds);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ScanMaxTimeSeconds");
        }
    }
};
class SetNetworkCommissioningConnectMaxTimeSecondsAttributeCommand : public Command
{
public:
    SetNetworkCommissioningConnectMaxTimeSecondsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "connect-max-time-seconds", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &connectMaxTimeSeconds, "Set the Value of on ConnectMaxTimeSeconds.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ConnectMaxTimeSeconds");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetConnectMaxTimeSeconds, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t connectMaxTimeSeconds;
    chip::EndpointId mEndPointId;

private:
    static void SetConnectMaxTimeSeconds(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningConnectMaxTimeSecondsAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningConnectMaxTimeSecondsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::NetworkCommissioning::Attributes::ConnectMaxTimeSeconds::Set(
            command->mEndPointId, command->connectMaxTimeSeconds);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ConnectMaxTimeSeconds");
        }
    }
};
class SetNetworkCommissioningInterfaceEnabledAttributeCommand : public Command
{
public:
    SetNetworkCommissioningInterfaceEnabledAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "interface-enabled", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &interfaceEnabled, "Set the Value of on InterfaceEnabled.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InterfaceEnabled");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInterfaceEnabled, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool interfaceEnabled;
    chip::EndpointId mEndPointId;

private:
    static void SetInterfaceEnabled(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningInterfaceEnabledAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningInterfaceEnabledAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::NetworkCommissioning::Attributes::InterfaceEnabled::Set(
            command->mEndPointId, command->interfaceEnabled);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InterfaceEnabled");
        }
    }
};
class SetNetworkCommissioningLastNetworkingStatusAttributeCommand : public Command
{
public:
    SetNetworkCommissioningLastNetworkingStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "last-networking-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &lastNetworkingStatus, "Set the Value of on LastNetworkingStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LastNetworkingStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLastNetworkingStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatus> lastNetworkingStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetLastNetworkingStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningLastNetworkingStatusAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningLastNetworkingStatusAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::NetworkCommissioning::Attributes::LastNetworkingStatus::Set(
            command->mEndPointId, command->lastNetworkingStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LastNetworkingStatus");
        }
    }
};
class SetNetworkCommissioningLastNetworkIDAttributeCommand : public Command
{
public:
    SetNetworkCommissioningLastNetworkIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "last-network-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &lastNetworkID, "Set the Value of on LastNetworkID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LastNetworkID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLastNetworkID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::ByteSpan> lastNetworkID;
    chip::EndpointId mEndPointId;

private:
    static void SetLastNetworkID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningLastNetworkIDAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningLastNetworkIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::NetworkCommissioning::Attributes::LastNetworkID::Set(command->mEndPointId, command->lastNetworkID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LastNetworkID");
        }
    }
};
class SetNetworkCommissioningLastConnectErrorValueAttributeCommand : public Command
{
public:
    SetNetworkCommissioningLastConnectErrorValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "last-connect-error-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT32_MIN, INT32_MAX, &lastConnectErrorValue, "Set the Value of on LastConnectErrorValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LastConnectErrorValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLastConnectErrorValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int32_t> lastConnectErrorValue;
    chip::EndpointId mEndPointId;

private:
    static void SetLastConnectErrorValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningLastConnectErrorValueAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningLastConnectErrorValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::NetworkCommissioning::Attributes::LastConnectErrorValue::Set(
            command->mEndPointId, command->lastConnectErrorValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LastConnectErrorValue");
        }
    }
};
class SetNetworkCommissioningFeatureMapAttributeCommand : public Command
{
public:
    SetNetworkCommissioningFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningFeatureMapAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::NetworkCommissioning::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetNetworkCommissioningClusterRevisionAttributeCommand : public Command
{
public:
    SetNetworkCommissioningClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetNetworkCommissioningClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetNetworkCommissioningClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::NetworkCommissioning::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetDiagnosticLogsFeatureMapAttributeCommand : public Command
{
public:
    SetDiagnosticLogsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDiagnosticLogsFeatureMapAttributeCommand * command =
            reinterpret_cast<SetDiagnosticLogsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DiagnosticLogs::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetDiagnosticLogsClusterRevisionAttributeCommand : public Command
{
public:
    SetDiagnosticLogsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDiagnosticLogsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetDiagnosticLogsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DiagnosticLogs::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetGeneralDiagnosticsRebootCountAttributeCommand : public Command
{
public:
    SetGeneralDiagnosticsRebootCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reboot-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rebootCount, "Set the Value of on RebootCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RebootCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRebootCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rebootCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRebootCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralDiagnosticsRebootCountAttributeCommand * command =
            reinterpret_cast<SetGeneralDiagnosticsRebootCountAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::GeneralDiagnostics::Attributes::RebootCount::Set(command->mEndPointId, command->rebootCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RebootCount");
        }
    }
};
class SetGeneralDiagnosticsUpTimeAttributeCommand : public Command
{
public:
    SetGeneralDiagnosticsUpTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "up-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &upTime, "Set the Value of on UpTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UpTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUpTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t upTime;
    chip::EndpointId mEndPointId;

private:
    static void SetUpTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralDiagnosticsUpTimeAttributeCommand * command =
            reinterpret_cast<SetGeneralDiagnosticsUpTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::GeneralDiagnostics::Attributes::UpTime::Set(command->mEndPointId, command->upTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UpTime");
        }
    }
};
class SetGeneralDiagnosticsTotalOperationalHoursAttributeCommand : public Command
{
public:
    SetGeneralDiagnosticsTotalOperationalHoursAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "total-operational-hours", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &totalOperationalHours, "Set the Value of on TotalOperationalHours.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TotalOperationalHours");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTotalOperationalHours, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t totalOperationalHours;
    chip::EndpointId mEndPointId;

private:
    static void SetTotalOperationalHours(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralDiagnosticsTotalOperationalHoursAttributeCommand * command =
            reinterpret_cast<SetGeneralDiagnosticsTotalOperationalHoursAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GeneralDiagnostics::Attributes::TotalOperationalHours::Set(
            command->mEndPointId, command->totalOperationalHours);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TotalOperationalHours");
        }
    }
};
class SetGeneralDiagnosticsBootReasonAttributeCommand : public Command
{
public:
    SetGeneralDiagnosticsBootReasonAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "boot-reason", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &bootReason, "Set the Value of on BootReason.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BootReason");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBootReason, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::GeneralDiagnostics::BootReasonEnum bootReason;
    chip::EndpointId mEndPointId;

private:
    static void SetBootReason(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralDiagnosticsBootReasonAttributeCommand * command =
            reinterpret_cast<SetGeneralDiagnosticsBootReasonAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::GeneralDiagnostics::Attributes::BootReason::Set(command->mEndPointId, command->bootReason);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BootReason");
        }
    }
};
class SetGeneralDiagnosticsTestEventTriggersEnabledAttributeCommand : public Command
{
public:
    SetGeneralDiagnosticsTestEventTriggersEnabledAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "test-event-triggers-enabled", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &testEventTriggersEnabled, "Set the Value of on TestEventTriggersEnabled.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TestEventTriggersEnabled");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTestEventTriggersEnabled, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool testEventTriggersEnabled;
    chip::EndpointId mEndPointId;

private:
    static void SetTestEventTriggersEnabled(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralDiagnosticsTestEventTriggersEnabledAttributeCommand * command =
            reinterpret_cast<SetGeneralDiagnosticsTestEventTriggersEnabledAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GeneralDiagnostics::Attributes::TestEventTriggersEnabled::Set(
            command->mEndPointId, command->testEventTriggersEnabled);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TestEventTriggersEnabled");
        }
    }
};
class SetGeneralDiagnosticsFeatureMapAttributeCommand : public Command
{
public:
    SetGeneralDiagnosticsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralDiagnosticsFeatureMapAttributeCommand * command =
            reinterpret_cast<SetGeneralDiagnosticsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::GeneralDiagnostics::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetGeneralDiagnosticsClusterRevisionAttributeCommand : public Command
{
public:
    SetGeneralDiagnosticsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGeneralDiagnosticsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetGeneralDiagnosticsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GeneralDiagnostics::Attributes::ClusterRevision::Set(command->mEndPointId,
                                                                                                         command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetSoftwareDiagnosticsCurrentHeapFreeAttributeCommand : public Command
{
public:
    SetSoftwareDiagnosticsCurrentHeapFreeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-heap-free", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &currentHeapFree, "Set the Value of on CurrentHeapFree.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentHeapFree");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentHeapFree, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t currentHeapFree;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentHeapFree(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSoftwareDiagnosticsCurrentHeapFreeAttributeCommand * command =
            reinterpret_cast<SetSoftwareDiagnosticsCurrentHeapFreeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapFree::Set(command->mEndPointId,
                                                                                                          command->currentHeapFree);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentHeapFree");
        }
    }
};
class SetSoftwareDiagnosticsCurrentHeapUsedAttributeCommand : public Command
{
public:
    SetSoftwareDiagnosticsCurrentHeapUsedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-heap-used", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &currentHeapUsed, "Set the Value of on CurrentHeapUsed.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentHeapUsed");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentHeapUsed, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t currentHeapUsed;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentHeapUsed(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSoftwareDiagnosticsCurrentHeapUsedAttributeCommand * command =
            reinterpret_cast<SetSoftwareDiagnosticsCurrentHeapUsedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapUsed::Set(command->mEndPointId,
                                                                                                          command->currentHeapUsed);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentHeapUsed");
        }
    }
};
class SetSoftwareDiagnosticsCurrentHeapHighWatermarkAttributeCommand : public Command
{
public:
    SetSoftwareDiagnosticsCurrentHeapHighWatermarkAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-heap-high-watermark", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &currentHeapHighWatermark, "Set the Value of on CurrentHeapHighWatermark.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentHeapHighWatermark");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentHeapHighWatermark, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t currentHeapHighWatermark;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentHeapHighWatermark(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSoftwareDiagnosticsCurrentHeapHighWatermarkAttributeCommand * command =
            reinterpret_cast<SetSoftwareDiagnosticsCurrentHeapHighWatermarkAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::SoftwareDiagnostics::Attributes::CurrentHeapHighWatermark::Set(
            command->mEndPointId, command->currentHeapHighWatermark);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentHeapHighWatermark");
        }
    }
};
class SetSoftwareDiagnosticsFeatureMapAttributeCommand : public Command
{
public:
    SetSoftwareDiagnosticsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSoftwareDiagnosticsFeatureMapAttributeCommand * command =
            reinterpret_cast<SetSoftwareDiagnosticsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::SoftwareDiagnostics::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetSoftwareDiagnosticsClusterRevisionAttributeCommand : public Command
{
public:
    SetSoftwareDiagnosticsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSoftwareDiagnosticsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetSoftwareDiagnosticsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::SoftwareDiagnostics::Attributes::ClusterRevision::Set(command->mEndPointId,
                                                                                                          command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetThreadNetworkDiagnosticsChannelAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsChannelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "channel", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &channel, "Set the Value of on Channel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Channel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetChannel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> channel;
    chip::EndpointId mEndPointId;

private:
    static void SetChannel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsChannelAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsChannelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::Channel::Set(command->mEndPointId, command->channel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Channel");
        }
    }
};
class SetThreadNetworkDiagnosticsRoutingRoleAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRoutingRoleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "routing-role", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &routingRole, "Set the Value of on RoutingRole.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RoutingRole");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRoutingRole, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRole> routingRole;
    chip::EndpointId mEndPointId;

private:
    static void SetRoutingRole(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRoutingRoleAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRoutingRoleAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RoutingRole::Set(command->mEndPointId, command->routingRole);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RoutingRole");
        }
    }
};
class SetThreadNetworkDiagnosticsNetworkNameAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsNetworkNameAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "network-name", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &networkName, "Set the Value of on NetworkName.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NetworkName");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNetworkName, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::CharSpan> networkName;
    chip::EndpointId mEndPointId;

private:
    static void SetNetworkName(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsNetworkNameAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsNetworkNameAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::NetworkName::Set(command->mEndPointId, command->networkName);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NetworkName");
        }
    }
};
class SetThreadNetworkDiagnosticsPanIdAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsPanIdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "pan-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &panId, "Set the Value of on PanId.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PanId");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPanId, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> panId;
    chip::EndpointId mEndPointId;

private:
    static void SetPanId(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsPanIdAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsPanIdAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::PanId::Set(command->mEndPointId, command->panId);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PanId");
        }
    }
};
class SetThreadNetworkDiagnosticsExtendedPanIdAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsExtendedPanIdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "extended-pan-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &extendedPanId, "Set the Value of on ExtendedPanId.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ExtendedPanId");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetExtendedPanId, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> extendedPanId;
    chip::EndpointId mEndPointId;

private:
    static void SetExtendedPanId(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsExtendedPanIdAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsExtendedPanIdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ExtendedPanId::Set(
            command->mEndPointId, command->extendedPanId);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ExtendedPanId");
        }
    }
};
class SetThreadNetworkDiagnosticsMeshLocalPrefixAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsMeshLocalPrefixAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "mesh-local-prefix", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &meshLocalPrefix, "Set the Value of on MeshLocalPrefix.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeshLocalPrefix");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeshLocalPrefix, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::ByteSpan> meshLocalPrefix;
    chip::EndpointId mEndPointId;

private:
    static void SetMeshLocalPrefix(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsMeshLocalPrefixAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsMeshLocalPrefixAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::MeshLocalPrefix::Set(
            command->mEndPointId, command->meshLocalPrefix);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeshLocalPrefix");
        }
    }
};
class SetThreadNetworkDiagnosticsOverrunCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsOverrunCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "overrun-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &overrunCount, "Set the Value of on OverrunCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OverrunCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOverrunCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t overrunCount;
    chip::EndpointId mEndPointId;

private:
    static void SetOverrunCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsOverrunCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsOverrunCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::OverrunCount::Set(command->mEndPointId,
                                                                                                            command->overrunCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OverrunCount");
        }
    }
};
class SetThreadNetworkDiagnosticsPartitionIdAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsPartitionIdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "partition-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &partitionId, "Set the Value of on PartitionId.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PartitionId");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPartitionId, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> partitionId;
    chip::EndpointId mEndPointId;

private:
    static void SetPartitionId(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsPartitionIdAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsPartitionIdAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::PartitionId::Set(command->mEndPointId, command->partitionId);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PartitionId");
        }
    }
};
class SetThreadNetworkDiagnosticsWeightingAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsWeightingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "weighting", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &weighting, "Set the Value of on Weighting.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Weighting");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWeighting, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> weighting;
    chip::EndpointId mEndPointId;

private:
    static void SetWeighting(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsWeightingAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsWeightingAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::Weighting::Set(command->mEndPointId, command->weighting);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Weighting");
        }
    }
};
class SetThreadNetworkDiagnosticsDataVersionAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsDataVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "data-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &dataVersion, "Set the Value of on DataVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DataVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDataVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> dataVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetDataVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsDataVersionAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsDataVersionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::DataVersion::Set(command->mEndPointId, command->dataVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DataVersion");
        }
    }
};
class SetThreadNetworkDiagnosticsStableDataVersionAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsStableDataVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "stable-data-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &stableDataVersion, "Set the Value of on StableDataVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StableDataVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStableDataVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> stableDataVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetStableDataVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsStableDataVersionAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsStableDataVersionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::StableDataVersion::Set(
            command->mEndPointId, command->stableDataVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StableDataVersion");
        }
    }
};
class SetThreadNetworkDiagnosticsLeaderRouterIdAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsLeaderRouterIdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "leader-router-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &leaderRouterId, "Set the Value of on LeaderRouterId.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LeaderRouterId");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLeaderRouterId, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> leaderRouterId;
    chip::EndpointId mEndPointId;

private:
    static void SetLeaderRouterId(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsLeaderRouterIdAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsLeaderRouterIdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::LeaderRouterId::Set(
            command->mEndPointId, command->leaderRouterId);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LeaderRouterId");
        }
    }
};
class SetThreadNetworkDiagnosticsDetachedRoleCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsDetachedRoleCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "detached-role-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &detachedRoleCount, "Set the Value of on DetachedRoleCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DetachedRoleCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDetachedRoleCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t detachedRoleCount;
    chip::EndpointId mEndPointId;

private:
    static void SetDetachedRoleCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsDetachedRoleCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsDetachedRoleCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::DetachedRoleCount::Set(
            command->mEndPointId, command->detachedRoleCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DetachedRoleCount");
        }
    }
};
class SetThreadNetworkDiagnosticsChildRoleCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsChildRoleCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "child-role-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &childRoleCount, "Set the Value of on ChildRoleCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ChildRoleCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetChildRoleCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t childRoleCount;
    chip::EndpointId mEndPointId;

private:
    static void SetChildRoleCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsChildRoleCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsChildRoleCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ChildRoleCount::Set(
            command->mEndPointId, command->childRoleCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ChildRoleCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRouterRoleCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRouterRoleCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "router-role-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &routerRoleCount, "Set the Value of on RouterRoleCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RouterRoleCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRouterRoleCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t routerRoleCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRouterRoleCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRouterRoleCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRouterRoleCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RouterRoleCount::Set(
            command->mEndPointId, command->routerRoleCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RouterRoleCount");
        }
    }
};
class SetThreadNetworkDiagnosticsLeaderRoleCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsLeaderRoleCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "leader-role-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &leaderRoleCount, "Set the Value of on LeaderRoleCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LeaderRoleCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLeaderRoleCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t leaderRoleCount;
    chip::EndpointId mEndPointId;

private:
    static void SetLeaderRoleCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsLeaderRoleCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsLeaderRoleCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::LeaderRoleCount::Set(
            command->mEndPointId, command->leaderRoleCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LeaderRoleCount");
        }
    }
};
class SetThreadNetworkDiagnosticsAttachAttemptCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsAttachAttemptCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "attach-attempt-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &attachAttemptCount, "Set the Value of on AttachAttemptCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AttachAttemptCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAttachAttemptCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t attachAttemptCount;
    chip::EndpointId mEndPointId;

private:
    static void SetAttachAttemptCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsAttachAttemptCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsAttachAttemptCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::AttachAttemptCount::Set(
            command->mEndPointId, command->attachAttemptCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AttachAttemptCount");
        }
    }
};
class SetThreadNetworkDiagnosticsPartitionIdChangeCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsPartitionIdChangeCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "partition-id-change-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &partitionIdChangeCount, "Set the Value of on PartitionIdChangeCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PartitionIdChangeCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPartitionIdChangeCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t partitionIdChangeCount;
    chip::EndpointId mEndPointId;

private:
    static void SetPartitionIdChangeCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsPartitionIdChangeCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsPartitionIdChangeCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::PartitionIdChangeCount::Set(
            command->mEndPointId, command->partitionIdChangeCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PartitionIdChangeCount");
        }
    }
};
class SetThreadNetworkDiagnosticsBetterPartitionAttachAttemptCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsBetterPartitionAttachAttemptCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "better-partition-attach-attempt-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &betterPartitionAttachAttemptCount,
                    "Set the Value of on BetterPartitionAttachAttemptCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BetterPartitionAttachAttemptCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBetterPartitionAttachAttemptCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t betterPartitionAttachAttemptCount;
    chip::EndpointId mEndPointId;

private:
    static void SetBetterPartitionAttachAttemptCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsBetterPartitionAttachAttemptCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsBetterPartitionAttachAttemptCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::BetterPartitionAttachAttemptCount::Set(
            command->mEndPointId, command->betterPartitionAttachAttemptCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BetterPartitionAttachAttemptCount");
        }
    }
};
class SetThreadNetworkDiagnosticsParentChangeCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsParentChangeCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "parent-change-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &parentChangeCount, "Set the Value of on ParentChangeCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ParentChangeCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetParentChangeCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t parentChangeCount;
    chip::EndpointId mEndPointId;

private:
    static void SetParentChangeCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsParentChangeCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsParentChangeCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ParentChangeCount::Set(
            command->mEndPointId, command->parentChangeCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ParentChangeCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxTotalCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxTotalCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-total-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txTotalCount, "Set the Value of on TxTotalCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxTotalCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxTotalCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txTotalCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxTotalCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxTotalCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxTotalCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxTotalCount::Set(command->mEndPointId,
                                                                                                            command->txTotalCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxTotalCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxUnicastCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxUnicastCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-unicast-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txUnicastCount, "Set the Value of on TxUnicastCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxUnicastCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxUnicastCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txUnicastCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxUnicastCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxUnicastCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxUnicastCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxUnicastCount::Set(
            command->mEndPointId, command->txUnicastCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxUnicastCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxBroadcastCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxBroadcastCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-broadcast-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txBroadcastCount, "Set the Value of on TxBroadcastCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxBroadcastCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxBroadcastCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txBroadcastCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxBroadcastCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxBroadcastCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxBroadcastCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxBroadcastCount::Set(
            command->mEndPointId, command->txBroadcastCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxBroadcastCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxAckRequestedCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxAckRequestedCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-ack-requested-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txAckRequestedCount, "Set the Value of on TxAckRequestedCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxAckRequestedCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxAckRequestedCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txAckRequestedCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxAckRequestedCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxAckRequestedCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxAckRequestedCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxAckRequestedCount::Set(
            command->mEndPointId, command->txAckRequestedCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxAckRequestedCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxAckedCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxAckedCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-acked-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txAckedCount, "Set the Value of on TxAckedCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxAckedCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxAckedCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txAckedCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxAckedCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxAckedCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxAckedCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxAckedCount::Set(command->mEndPointId,
                                                                                                            command->txAckedCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxAckedCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxNoAckRequestedCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxNoAckRequestedCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-no-ack-requested-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txNoAckRequestedCount, "Set the Value of on TxNoAckRequestedCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxNoAckRequestedCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxNoAckRequestedCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txNoAckRequestedCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxNoAckRequestedCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxNoAckRequestedCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxNoAckRequestedCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxNoAckRequestedCount::Set(
            command->mEndPointId, command->txNoAckRequestedCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxNoAckRequestedCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxDataCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxDataCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-data-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txDataCount, "Set the Value of on TxDataCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxDataCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxDataCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txDataCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxDataCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxDataCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxDataCountAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxDataCount::Set(command->mEndPointId, command->txDataCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxDataCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxDataPollCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxDataPollCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-data-poll-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txDataPollCount, "Set the Value of on TxDataPollCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxDataPollCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxDataPollCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txDataPollCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxDataPollCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxDataPollCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxDataPollCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxDataPollCount::Set(
            command->mEndPointId, command->txDataPollCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxDataPollCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxBeaconCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxBeaconCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-beacon-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txBeaconCount, "Set the Value of on TxBeaconCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxBeaconCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxBeaconCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txBeaconCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxBeaconCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxBeaconCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxBeaconCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxBeaconCount::Set(
            command->mEndPointId, command->txBeaconCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxBeaconCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxBeaconRequestCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxBeaconRequestCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-beacon-request-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txBeaconRequestCount, "Set the Value of on TxBeaconRequestCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxBeaconRequestCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxBeaconRequestCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txBeaconRequestCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxBeaconRequestCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxBeaconRequestCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxBeaconRequestCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxBeaconRequestCount::Set(
            command->mEndPointId, command->txBeaconRequestCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxBeaconRequestCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxOtherCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxOtherCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-other-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txOtherCount, "Set the Value of on TxOtherCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxOtherCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxOtherCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txOtherCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxOtherCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxOtherCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxOtherCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxOtherCount::Set(command->mEndPointId,
                                                                                                            command->txOtherCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxOtherCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxRetryCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxRetryCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-retry-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txRetryCount, "Set the Value of on TxRetryCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxRetryCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxRetryCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txRetryCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxRetryCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxRetryCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxRetryCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxRetryCount::Set(command->mEndPointId,
                                                                                                            command->txRetryCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxRetryCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-direct-max-retry-expiry-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txDirectMaxRetryExpiryCount,
                    "Set the Value of on TxDirectMaxRetryExpiryCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxDirectMaxRetryExpiryCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxDirectMaxRetryExpiryCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txDirectMaxRetryExpiryCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxDirectMaxRetryExpiryCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxDirectMaxRetryExpiryCount::Set(
            command->mEndPointId, command->txDirectMaxRetryExpiryCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxDirectMaxRetryExpiryCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-indirect-max-retry-expiry-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txIndirectMaxRetryExpiryCount,
                    "Set the Value of on TxIndirectMaxRetryExpiryCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxIndirectMaxRetryExpiryCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxIndirectMaxRetryExpiryCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txIndirectMaxRetryExpiryCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxIndirectMaxRetryExpiryCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxIndirectMaxRetryExpiryCount::Set(
            command->mEndPointId, command->txIndirectMaxRetryExpiryCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxIndirectMaxRetryExpiryCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxErrCcaCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxErrCcaCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-err-cca-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txErrCcaCount, "Set the Value of on TxErrCcaCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxErrCcaCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxErrCcaCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txErrCcaCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxErrCcaCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxErrCcaCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxErrCcaCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxErrCcaCount::Set(
            command->mEndPointId, command->txErrCcaCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxErrCcaCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxErrAbortCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxErrAbortCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-err-abort-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txErrAbortCount, "Set the Value of on TxErrAbortCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxErrAbortCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxErrAbortCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txErrAbortCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxErrAbortCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxErrAbortCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxErrAbortCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxErrAbortCount::Set(
            command->mEndPointId, command->txErrAbortCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxErrAbortCount");
        }
    }
};
class SetThreadNetworkDiagnosticsTxErrBusyChannelCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsTxErrBusyChannelCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-err-busy-channel-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &txErrBusyChannelCount, "Set the Value of on TxErrBusyChannelCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxErrBusyChannelCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxErrBusyChannelCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t txErrBusyChannelCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxErrBusyChannelCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsTxErrBusyChannelCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsTxErrBusyChannelCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::TxErrBusyChannelCount::Set(
            command->mEndPointId, command->txErrBusyChannelCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxErrBusyChannelCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxTotalCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxTotalCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-total-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxTotalCount, "Set the Value of on RxTotalCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxTotalCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxTotalCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxTotalCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxTotalCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxTotalCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxTotalCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxTotalCount::Set(command->mEndPointId,
                                                                                                            command->rxTotalCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxTotalCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxUnicastCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxUnicastCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-unicast-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxUnicastCount, "Set the Value of on RxUnicastCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxUnicastCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxUnicastCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxUnicastCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxUnicastCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxUnicastCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxUnicastCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxUnicastCount::Set(
            command->mEndPointId, command->rxUnicastCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxUnicastCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxBroadcastCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxBroadcastCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-broadcast-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxBroadcastCount, "Set the Value of on RxBroadcastCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxBroadcastCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxBroadcastCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxBroadcastCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxBroadcastCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxBroadcastCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxBroadcastCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxBroadcastCount::Set(
            command->mEndPointId, command->rxBroadcastCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxBroadcastCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxDataCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxDataCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-data-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxDataCount, "Set the Value of on RxDataCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxDataCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxDataCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxDataCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxDataCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxDataCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxDataCountAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxDataCount::Set(command->mEndPointId, command->rxDataCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxDataCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxDataPollCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxDataPollCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-data-poll-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxDataPollCount, "Set the Value of on RxDataPollCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxDataPollCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxDataPollCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxDataPollCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxDataPollCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxDataPollCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxDataPollCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxDataPollCount::Set(
            command->mEndPointId, command->rxDataPollCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxDataPollCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxBeaconCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxBeaconCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-beacon-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxBeaconCount, "Set the Value of on RxBeaconCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxBeaconCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxBeaconCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxBeaconCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxBeaconCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxBeaconCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxBeaconCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxBeaconCount::Set(
            command->mEndPointId, command->rxBeaconCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxBeaconCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxBeaconRequestCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxBeaconRequestCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-beacon-request-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxBeaconRequestCount, "Set the Value of on RxBeaconRequestCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxBeaconRequestCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxBeaconRequestCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxBeaconRequestCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxBeaconRequestCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxBeaconRequestCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxBeaconRequestCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxBeaconRequestCount::Set(
            command->mEndPointId, command->rxBeaconRequestCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxBeaconRequestCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxOtherCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxOtherCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-other-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxOtherCount, "Set the Value of on RxOtherCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxOtherCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxOtherCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxOtherCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxOtherCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxOtherCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxOtherCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxOtherCount::Set(command->mEndPointId,
                                                                                                            command->rxOtherCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxOtherCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxAddressFilteredCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxAddressFilteredCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-address-filtered-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxAddressFilteredCount, "Set the Value of on RxAddressFilteredCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxAddressFilteredCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxAddressFilteredCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxAddressFilteredCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxAddressFilteredCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxAddressFilteredCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxAddressFilteredCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxAddressFilteredCount::Set(
            command->mEndPointId, command->rxAddressFilteredCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxAddressFilteredCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxDestAddrFilteredCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxDestAddrFilteredCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-dest-addr-filtered-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxDestAddrFilteredCount, "Set the Value of on RxDestAddrFilteredCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxDestAddrFilteredCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxDestAddrFilteredCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxDestAddrFilteredCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxDestAddrFilteredCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxDestAddrFilteredCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxDestAddrFilteredCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxDestAddrFilteredCount::Set(
            command->mEndPointId, command->rxDestAddrFilteredCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxDestAddrFilteredCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxDuplicatedCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxDuplicatedCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-duplicated-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxDuplicatedCount, "Set the Value of on RxDuplicatedCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxDuplicatedCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxDuplicatedCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxDuplicatedCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxDuplicatedCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxDuplicatedCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxDuplicatedCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxDuplicatedCount::Set(
            command->mEndPointId, command->rxDuplicatedCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxDuplicatedCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxErrNoFrameCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxErrNoFrameCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-err-no-frame-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxErrNoFrameCount, "Set the Value of on RxErrNoFrameCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxErrNoFrameCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxErrNoFrameCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxErrNoFrameCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxErrNoFrameCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxErrNoFrameCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxErrNoFrameCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxErrNoFrameCount::Set(
            command->mEndPointId, command->rxErrNoFrameCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxErrNoFrameCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxErrUnknownNeighborCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxErrUnknownNeighborCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-err-unknown-neighbor-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxErrUnknownNeighborCount, "Set the Value of on RxErrUnknownNeighborCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxErrUnknownNeighborCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxErrUnknownNeighborCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxErrUnknownNeighborCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxErrUnknownNeighborCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxErrUnknownNeighborCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxErrUnknownNeighborCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxErrUnknownNeighborCount::Set(
            command->mEndPointId, command->rxErrUnknownNeighborCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxErrUnknownNeighborCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxErrInvalidSrcAddrCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxErrInvalidSrcAddrCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-err-invalid-src-addr-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxErrInvalidSrcAddrCount, "Set the Value of on RxErrInvalidSrcAddrCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxErrInvalidSrcAddrCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxErrInvalidSrcAddrCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxErrInvalidSrcAddrCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxErrInvalidSrcAddrCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxErrInvalidSrcAddrCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxErrInvalidSrcAddrCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxErrInvalidSrcAddrCount::Set(
            command->mEndPointId, command->rxErrInvalidSrcAddrCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxErrInvalidSrcAddrCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxErrSecCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxErrSecCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-err-sec-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxErrSecCount, "Set the Value of on RxErrSecCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxErrSecCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxErrSecCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxErrSecCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxErrSecCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxErrSecCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxErrSecCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxErrSecCount::Set(
            command->mEndPointId, command->rxErrSecCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxErrSecCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxErrFcsCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxErrFcsCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-err-fcs-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxErrFcsCount, "Set the Value of on RxErrFcsCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxErrFcsCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxErrFcsCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxErrFcsCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxErrFcsCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxErrFcsCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxErrFcsCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxErrFcsCount::Set(
            command->mEndPointId, command->rxErrFcsCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxErrFcsCount");
        }
    }
};
class SetThreadNetworkDiagnosticsRxErrOtherCountAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsRxErrOtherCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rx-err-other-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &rxErrOtherCount, "Set the Value of on RxErrOtherCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RxErrOtherCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRxErrOtherCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t rxErrOtherCount;
    chip::EndpointId mEndPointId;

private:
    static void SetRxErrOtherCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsRxErrOtherCountAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsRxErrOtherCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::RxErrOtherCount::Set(
            command->mEndPointId, command->rxErrOtherCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RxErrOtherCount");
        }
    }
};
class SetThreadNetworkDiagnosticsActiveTimestampAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsActiveTimestampAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-timestamp", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &activeTimestamp, "Set the Value of on ActiveTimestamp.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveTimestamp");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveTimestamp, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> activeTimestamp;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveTimestamp(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsActiveTimestampAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsActiveTimestampAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ActiveTimestamp::Set(
            command->mEndPointId, command->activeTimestamp);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveTimestamp");
        }
    }
};
class SetThreadNetworkDiagnosticsPendingTimestampAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsPendingTimestampAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "pending-timestamp", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &pendingTimestamp, "Set the Value of on PendingTimestamp.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PendingTimestamp");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPendingTimestamp, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> pendingTimestamp;
    chip::EndpointId mEndPointId;

private:
    static void SetPendingTimestamp(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsPendingTimestampAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsPendingTimestampAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::PendingTimestamp::Set(
            command->mEndPointId, command->pendingTimestamp);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PendingTimestamp");
        }
    }
};
class SetThreadNetworkDiagnosticsDelayAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsDelayAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "delay", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &delay, "Set the Value of on Delay.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Delay");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDelay, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> delay;
    chip::EndpointId mEndPointId;

private:
    static void SetDelay(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsDelayAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsDelayAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::Delay::Set(command->mEndPointId, command->delay);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Delay");
        }
    }
};
class SetThreadNetworkDiagnosticsChannelPage0MaskAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsChannelPage0MaskAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "channel-page0mask", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &channelPage0Mask, "Set the Value of on ChannelPage0Mask.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ChannelPage0Mask");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetChannelPage0Mask, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::ByteSpan> channelPage0Mask;
    chip::EndpointId mEndPointId;

private:
    static void SetChannelPage0Mask(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsChannelPage0MaskAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsChannelPage0MaskAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ChannelPage0Mask::Set(
            command->mEndPointId, command->channelPage0Mask);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ChannelPage0Mask");
        }
    }
};
class SetThreadNetworkDiagnosticsFeatureMapAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsFeatureMapAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetThreadNetworkDiagnosticsClusterRevisionAttributeCommand : public Command
{
public:
    SetThreadNetworkDiagnosticsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThreadNetworkDiagnosticsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetThreadNetworkDiagnosticsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThreadNetworkDiagnostics::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetWiFiNetworkDiagnosticsBssidAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsBssidAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bssid", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &bssid, "Set the Value of on Bssid.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Bssid");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBssid, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::ByteSpan> bssid;
    chip::EndpointId mEndPointId;

private:
    static void SetBssid(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsBssidAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsBssidAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::Bssid::Set(command->mEndPointId, command->bssid);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Bssid");
        }
    }
};
class SetWiFiNetworkDiagnosticsSecurityTypeAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsSecurityTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "security-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &securityType, "Set the Value of on SecurityType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SecurityType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSecurityType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityTypeEnum> securityType;
    chip::EndpointId mEndPointId;

private:
    static void SetSecurityType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsSecurityTypeAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsSecurityTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::SecurityType::Set(command->mEndPointId, command->securityType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SecurityType");
        }
    }
};
class SetWiFiNetworkDiagnosticsWiFiVersionAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsWiFiVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wi-fi-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &wiFiVersion, "Set the Value of on WiFiVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WiFiVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWiFiVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionEnum> wiFiVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetWiFiVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsWiFiVersionAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsWiFiVersionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::WiFiVersion::Set(command->mEndPointId, command->wiFiVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WiFiVersion");
        }
    }
};
class SetWiFiNetworkDiagnosticsChannelNumberAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsChannelNumberAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "channel-number", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &channelNumber, "Set the Value of on ChannelNumber.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ChannelNumber");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetChannelNumber, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> channelNumber;
    chip::EndpointId mEndPointId;

private:
    static void SetChannelNumber(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsChannelNumberAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsChannelNumberAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::ChannelNumber::Set(command->mEndPointId,
                                                                                                           command->channelNumber);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ChannelNumber");
        }
    }
};
class SetWiFiNetworkDiagnosticsRssiAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsRssiAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rssi", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &rssi, "Set the Value of on Rssi.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Rssi");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRssi, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int8_t> rssi;
    chip::EndpointId mEndPointId;

private:
    static void SetRssi(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsRssiAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsRssiAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::Rssi::Set(command->mEndPointId, command->rssi);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Rssi");
        }
    }
};
class SetWiFiNetworkDiagnosticsBeaconLostCountAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsBeaconLostCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "beacon-lost-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &beaconLostCount, "Set the Value of on BeaconLostCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BeaconLostCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBeaconLostCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> beaconLostCount;
    chip::EndpointId mEndPointId;

private:
    static void SetBeaconLostCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsBeaconLostCountAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsBeaconLostCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::BeaconLostCount::Set(
            command->mEndPointId, command->beaconLostCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BeaconLostCount");
        }
    }
};
class SetWiFiNetworkDiagnosticsBeaconRxCountAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsBeaconRxCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "beacon-rx-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &beaconRxCount, "Set the Value of on BeaconRxCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BeaconRxCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBeaconRxCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> beaconRxCount;
    chip::EndpointId mEndPointId;

private:
    static void SetBeaconRxCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsBeaconRxCountAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsBeaconRxCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::BeaconRxCount::Set(command->mEndPointId,
                                                                                                           command->beaconRxCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BeaconRxCount");
        }
    }
};
class SetWiFiNetworkDiagnosticsPacketMulticastRxCountAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsPacketMulticastRxCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "packet-multicast-rx-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &packetMulticastRxCount, "Set the Value of on PacketMulticastRxCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PacketMulticastRxCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPacketMulticastRxCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> packetMulticastRxCount;
    chip::EndpointId mEndPointId;

private:
    static void SetPacketMulticastRxCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsPacketMulticastRxCountAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsPacketMulticastRxCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::PacketMulticastRxCount::Set(
            command->mEndPointId, command->packetMulticastRxCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PacketMulticastRxCount");
        }
    }
};
class SetWiFiNetworkDiagnosticsPacketMulticastTxCountAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsPacketMulticastTxCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "packet-multicast-tx-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &packetMulticastTxCount, "Set the Value of on PacketMulticastTxCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PacketMulticastTxCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPacketMulticastTxCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> packetMulticastTxCount;
    chip::EndpointId mEndPointId;

private:
    static void SetPacketMulticastTxCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsPacketMulticastTxCountAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsPacketMulticastTxCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::PacketMulticastTxCount::Set(
            command->mEndPointId, command->packetMulticastTxCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PacketMulticastTxCount");
        }
    }
};
class SetWiFiNetworkDiagnosticsPacketUnicastRxCountAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsPacketUnicastRxCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "packet-unicast-rx-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &packetUnicastRxCount, "Set the Value of on PacketUnicastRxCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PacketUnicastRxCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPacketUnicastRxCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> packetUnicastRxCount;
    chip::EndpointId mEndPointId;

private:
    static void SetPacketUnicastRxCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsPacketUnicastRxCountAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsPacketUnicastRxCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::PacketUnicastRxCount::Set(
            command->mEndPointId, command->packetUnicastRxCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PacketUnicastRxCount");
        }
    }
};
class SetWiFiNetworkDiagnosticsPacketUnicastTxCountAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsPacketUnicastTxCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "packet-unicast-tx-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &packetUnicastTxCount, "Set the Value of on PacketUnicastTxCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PacketUnicastTxCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPacketUnicastTxCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> packetUnicastTxCount;
    chip::EndpointId mEndPointId;

private:
    static void SetPacketUnicastTxCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsPacketUnicastTxCountAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsPacketUnicastTxCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::PacketUnicastTxCount::Set(
            command->mEndPointId, command->packetUnicastTxCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PacketUnicastTxCount");
        }
    }
};
class SetWiFiNetworkDiagnosticsCurrentMaxRateAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsCurrentMaxRateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-max-rate", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &currentMaxRate, "Set the Value of on CurrentMaxRate.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentMaxRate");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentMaxRate, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> currentMaxRate;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentMaxRate(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsCurrentMaxRateAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsCurrentMaxRateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::CurrentMaxRate::Set(
            command->mEndPointId, command->currentMaxRate);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentMaxRate");
        }
    }
};
class SetWiFiNetworkDiagnosticsOverrunCountAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsOverrunCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "overrun-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &overrunCount, "Set the Value of on OverrunCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OverrunCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOverrunCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> overrunCount;
    chip::EndpointId mEndPointId;

private:
    static void SetOverrunCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsOverrunCountAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsOverrunCountAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::OverrunCount::Set(command->mEndPointId, command->overrunCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OverrunCount");
        }
    }
};
class SetWiFiNetworkDiagnosticsFeatureMapAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsFeatureMapAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetWiFiNetworkDiagnosticsClusterRevisionAttributeCommand : public Command
{
public:
    SetWiFiNetworkDiagnosticsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWiFiNetworkDiagnosticsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetWiFiNetworkDiagnosticsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WiFiNetworkDiagnostics::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetEthernetNetworkDiagnosticsPHYRateAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsPHYRateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "phyrate", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &PHYRate, "Set the Value of on PHYRate.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PHYRate");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPHYRate, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateEnum> PHYRate;
    chip::EndpointId mEndPointId;

private:
    static void SetPHYRate(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsPHYRateAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsPHYRateAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::PHYRate::Set(command->mEndPointId, command->PHYRate);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PHYRate");
        }
    }
};
class SetEthernetNetworkDiagnosticsFullDuplexAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsFullDuplexAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "full-duplex", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &fullDuplex, "Set the Value of on FullDuplex.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FullDuplex");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFullDuplex, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<bool> fullDuplex;
    chip::EndpointId mEndPointId;

private:
    static void SetFullDuplex(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsFullDuplexAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsFullDuplexAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::FullDuplex::Set(command->mEndPointId, command->fullDuplex);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FullDuplex");
        }
    }
};
class SetEthernetNetworkDiagnosticsPacketRxCountAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsPacketRxCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "packet-rx-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &packetRxCount, "Set the Value of on PacketRxCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PacketRxCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPacketRxCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t packetRxCount;
    chip::EndpointId mEndPointId;

private:
    static void SetPacketRxCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsPacketRxCountAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsPacketRxCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::PacketRxCount::Set(
            command->mEndPointId, command->packetRxCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PacketRxCount");
        }
    }
};
class SetEthernetNetworkDiagnosticsPacketTxCountAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsPacketTxCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "packet-tx-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &packetTxCount, "Set the Value of on PacketTxCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PacketTxCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPacketTxCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t packetTxCount;
    chip::EndpointId mEndPointId;

private:
    static void SetPacketTxCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsPacketTxCountAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsPacketTxCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::PacketTxCount::Set(
            command->mEndPointId, command->packetTxCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PacketTxCount");
        }
    }
};
class SetEthernetNetworkDiagnosticsTxErrCountAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsTxErrCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tx-err-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &txErrCount, "Set the Value of on TxErrCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TxErrCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTxErrCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t txErrCount;
    chip::EndpointId mEndPointId;

private:
    static void SetTxErrCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsTxErrCountAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsTxErrCountAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::TxErrCount::Set(command->mEndPointId, command->txErrCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TxErrCount");
        }
    }
};
class SetEthernetNetworkDiagnosticsCollisionCountAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsCollisionCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "collision-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &collisionCount, "Set the Value of on CollisionCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CollisionCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCollisionCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t collisionCount;
    chip::EndpointId mEndPointId;

private:
    static void SetCollisionCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsCollisionCountAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsCollisionCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::CollisionCount::Set(
            command->mEndPointId, command->collisionCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CollisionCount");
        }
    }
};
class SetEthernetNetworkDiagnosticsOverrunCountAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsOverrunCountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "overrun-count", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &overrunCount, "Set the Value of on OverrunCount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OverrunCount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOverrunCount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t overrunCount;
    chip::EndpointId mEndPointId;

private:
    static void SetOverrunCount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsOverrunCountAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsOverrunCountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::OverrunCount::Set(
            command->mEndPointId, command->overrunCount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OverrunCount");
        }
    }
};
class SetEthernetNetworkDiagnosticsCarrierDetectAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsCarrierDetectAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "carrier-detect", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &carrierDetect, "Set the Value of on CarrierDetect.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CarrierDetect");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCarrierDetect, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<bool> carrierDetect;
    chip::EndpointId mEndPointId;

private:
    static void SetCarrierDetect(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsCarrierDetectAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsCarrierDetectAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::CarrierDetect::Set(
            command->mEndPointId, command->carrierDetect);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CarrierDetect");
        }
    }
};
class SetEthernetNetworkDiagnosticsTimeSinceResetAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsTimeSinceResetAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "time-since-reset", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &timeSinceReset, "Set the Value of on TimeSinceReset.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TimeSinceReset");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTimeSinceReset, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t timeSinceReset;
    chip::EndpointId mEndPointId;

private:
    static void SetTimeSinceReset(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsTimeSinceResetAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsTimeSinceResetAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::TimeSinceReset::Set(
            command->mEndPointId, command->timeSinceReset);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TimeSinceReset");
        }
    }
};
class SetEthernetNetworkDiagnosticsFeatureMapAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsFeatureMapAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetEthernetNetworkDiagnosticsClusterRevisionAttributeCommand : public Command
{
public:
    SetEthernetNetworkDiagnosticsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetEthernetNetworkDiagnosticsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetEthernetNetworkDiagnosticsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::EthernetNetworkDiagnostics::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetTimeSynchronizationUTCTimeAttributeCommand : public Command
{
public:
    SetTimeSynchronizationUTCTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "utctime", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &UTCTime, "Set the Value of on UTCTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UTCTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUTCTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> UTCTime;
    chip::EndpointId mEndPointId;

private:
    static void SetUTCTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationUTCTimeAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationUTCTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeSynchronization::Attributes::UTCTime::Set(command->mEndPointId, command->UTCTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UTCTime");
        }
    }
};
class SetTimeSynchronizationGranularityAttributeCommand : public Command
{
public:
    SetTimeSynchronizationGranularityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "granularity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &granularity, "Set the Value of on Granularity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Granularity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetGranularity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::TimeSynchronization::GranularityEnum granularity;
    chip::EndpointId mEndPointId;

private:
    static void SetGranularity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationGranularityAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationGranularityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeSynchronization::Attributes::Granularity::Set(command->mEndPointId, command->granularity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Granularity");
        }
    }
};
class SetTimeSynchronizationTimeSourceAttributeCommand : public Command
{
public:
    SetTimeSynchronizationTimeSourceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "time-source", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &timeSource, "Set the Value of on TimeSource.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TimeSource");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTimeSource, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::TimeSynchronization::TimeSourceEnum timeSource;
    chip::EndpointId mEndPointId;

private:
    static void SetTimeSource(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationTimeSourceAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationTimeSourceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeSynchronization::Attributes::TimeSource::Set(command->mEndPointId, command->timeSource);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TimeSource");
        }
    }
};
class SetTimeSynchronizationTrustedTimeNodeIdAttributeCommand : public Command
{
public:
    SetTimeSynchronizationTrustedTimeNodeIdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "trusted-time-node-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &trustedTimeNodeId, "Set the Value of on TrustedTimeNodeId.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TrustedTimeNodeId");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTrustedTimeNodeId, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::NodeId> trustedTimeNodeId;
    chip::EndpointId mEndPointId;

private:
    static void SetTrustedTimeNodeId(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationTrustedTimeNodeIdAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationTrustedTimeNodeIdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TimeSynchronization::Attributes::TrustedTimeNodeId::Set(
            command->mEndPointId, command->trustedTimeNodeId);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TrustedTimeNodeId");
        }
    }
};
class SetTimeSynchronizationDefaultNtpAttributeCommand : public Command
{
public:
    SetTimeSynchronizationDefaultNtpAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "default-ntp", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &defaultNtp, "Set the Value of on DefaultNtp.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DefaultNtp");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDefaultNtp, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::CharSpan> defaultNtp;
    chip::EndpointId mEndPointId;

private:
    static void SetDefaultNtp(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationDefaultNtpAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationDefaultNtpAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeSynchronization::Attributes::DefaultNtp::Set(command->mEndPointId, command->defaultNtp);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DefaultNtp");
        }
    }
};
class SetTimeSynchronizationLocalTimeAttributeCommand : public Command
{
public:
    SetTimeSynchronizationLocalTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "local-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &localTime, "Set the Value of on LocalTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LocalTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLocalTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> localTime;
    chip::EndpointId mEndPointId;

private:
    static void SetLocalTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationLocalTimeAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationLocalTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeSynchronization::Attributes::LocalTime::Set(command->mEndPointId, command->localTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LocalTime");
        }
    }
};
class SetTimeSynchronizationTimeZoneDatabaseAttributeCommand : public Command
{
public:
    SetTimeSynchronizationTimeZoneDatabaseAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "time-zone-database", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &timeZoneDatabase, "Set the Value of on TimeZoneDatabase.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TimeZoneDatabase");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTimeZoneDatabase, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool timeZoneDatabase;
    chip::EndpointId mEndPointId;

private:
    static void SetTimeZoneDatabase(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationTimeZoneDatabaseAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationTimeZoneDatabaseAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TimeSynchronization::Attributes::TimeZoneDatabase::Set(
            command->mEndPointId, command->timeZoneDatabase);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TimeZoneDatabase");
        }
    }
};
class SetTimeSynchronizationNtpServerPortAttributeCommand : public Command
{
public:
    SetTimeSynchronizationNtpServerPortAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ntp-server-port", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &ntpServerPort, "Set the Value of on NtpServerPort.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NtpServerPort");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNtpServerPort, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> ntpServerPort;
    chip::EndpointId mEndPointId;

private:
    static void SetNtpServerPort(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationNtpServerPortAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationNtpServerPortAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeSynchronization::Attributes::NtpServerPort::Set(command->mEndPointId, command->ntpServerPort);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NtpServerPort");
        }
    }
};
class SetTimeSynchronizationFeatureMapAttributeCommand : public Command
{
public:
    SetTimeSynchronizationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TimeSynchronization::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetTimeSynchronizationClusterRevisionAttributeCommand : public Command
{
public:
    SetTimeSynchronizationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTimeSynchronizationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetTimeSynchronizationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TimeSynchronization::Attributes::ClusterRevision::Set(command->mEndPointId,
                                                                                                          command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetBridgedDeviceBasicInformationVendorNameAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationVendorNameAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "vendor-name", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &vendorName, "Set the Value of on VendorName.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VendorName");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVendorName, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan vendorName;
    chip::EndpointId mEndPointId;

private:
    static void SetVendorName(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationVendorNameAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationVendorNameAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::VendorName::Set(command->mEndPointId,
                                                                                                               command->vendorName);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VendorName");
        }
    }
};
class SetBridgedDeviceBasicInformationVendorIDAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationVendorIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "vendor-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &vendorID, "Set the Value of on VendorID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VendorID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVendorID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::VendorId vendorID;
    chip::EndpointId mEndPointId;

private:
    static void SetVendorID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationVendorIDAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationVendorIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::VendorID::Set(command->mEndPointId, command->vendorID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VendorID");
        }
    }
};
class SetBridgedDeviceBasicInformationProductNameAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationProductNameAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-name", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &productName, "Set the Value of on ProductName.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductName");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductName, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan productName;
    chip::EndpointId mEndPointId;

private:
    static void SetProductName(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationProductNameAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationProductNameAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::ProductName::Set(
            command->mEndPointId, command->productName);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductName");
        }
    }
};
class SetBridgedDeviceBasicInformationNodeLabelAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationNodeLabelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "node-label", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &nodeLabel, "Set the Value of on NodeLabel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NodeLabel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNodeLabel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan nodeLabel;
    chip::EndpointId mEndPointId;

private:
    static void SetNodeLabel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationNodeLabelAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationNodeLabelAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::NodeLabel::Set(command->mEndPointId,
                                                                                                              command->nodeLabel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NodeLabel");
        }
    }
};
class SetBridgedDeviceBasicInformationHardwareVersionAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationHardwareVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "hardware-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &hardwareVersion, "Set the Value of on HardwareVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: HardwareVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetHardwareVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t hardwareVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetHardwareVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationHardwareVersionAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationHardwareVersionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::HardwareVersion::Set(
            command->mEndPointId, command->hardwareVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute HardwareVersion");
        }
    }
};
class SetBridgedDeviceBasicInformationHardwareVersionStringAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationHardwareVersionStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "hardware-version-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &hardwareVersionString, "Set the Value of on HardwareVersionString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: HardwareVersionString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetHardwareVersionString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan hardwareVersionString;
    chip::EndpointId mEndPointId;

private:
    static void SetHardwareVersionString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationHardwareVersionStringAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationHardwareVersionStringAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::HardwareVersionString::Set(
            command->mEndPointId, command->hardwareVersionString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute HardwareVersionString");
        }
    }
};
class SetBridgedDeviceBasicInformationSoftwareVersionAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationSoftwareVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "software-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &softwareVersion, "Set the Value of on SoftwareVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SoftwareVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSoftwareVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t softwareVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetSoftwareVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationSoftwareVersionAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationSoftwareVersionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::SoftwareVersion::Set(
            command->mEndPointId, command->softwareVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SoftwareVersion");
        }
    }
};
class SetBridgedDeviceBasicInformationSoftwareVersionStringAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationSoftwareVersionStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "software-version-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &softwareVersionString, "Set the Value of on SoftwareVersionString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SoftwareVersionString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSoftwareVersionString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan softwareVersionString;
    chip::EndpointId mEndPointId;

private:
    static void SetSoftwareVersionString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationSoftwareVersionStringAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationSoftwareVersionStringAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::SoftwareVersionString::Set(
            command->mEndPointId, command->softwareVersionString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SoftwareVersionString");
        }
    }
};
class SetBridgedDeviceBasicInformationManufacturingDateAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationManufacturingDateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "manufacturing-date", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &manufacturingDate, "Set the Value of on ManufacturingDate.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ManufacturingDate");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetManufacturingDate, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan manufacturingDate;
    chip::EndpointId mEndPointId;

private:
    static void SetManufacturingDate(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationManufacturingDateAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationManufacturingDateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::ManufacturingDate::Set(
            command->mEndPointId, command->manufacturingDate);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ManufacturingDate");
        }
    }
};
class SetBridgedDeviceBasicInformationPartNumberAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationPartNumberAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "part-number", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &partNumber, "Set the Value of on PartNumber.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PartNumber");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPartNumber, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan partNumber;
    chip::EndpointId mEndPointId;

private:
    static void SetPartNumber(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationPartNumberAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationPartNumberAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::PartNumber::Set(command->mEndPointId,
                                                                                                               command->partNumber);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PartNumber");
        }
    }
};
class SetBridgedDeviceBasicInformationProductURLAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationProductURLAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-url", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &productURL, "Set the Value of on ProductURL.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductURL");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductURL, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan productURL;
    chip::EndpointId mEndPointId;

private:
    static void SetProductURL(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationProductURLAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationProductURLAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::ProductURL::Set(command->mEndPointId,
                                                                                                               command->productURL);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductURL");
        }
    }
};
class SetBridgedDeviceBasicInformationProductLabelAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationProductLabelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-label", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &productLabel, "Set the Value of on ProductLabel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductLabel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductLabel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan productLabel;
    chip::EndpointId mEndPointId;

private:
    static void SetProductLabel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationProductLabelAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationProductLabelAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::ProductLabel::Set(
            command->mEndPointId, command->productLabel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductLabel");
        }
    }
};
class SetBridgedDeviceBasicInformationSerialNumberAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationSerialNumberAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "serial-number", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &serialNumber, "Set the Value of on SerialNumber.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SerialNumber");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSerialNumber, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan serialNumber;
    chip::EndpointId mEndPointId;

private:
    static void SetSerialNumber(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationSerialNumberAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationSerialNumberAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::SerialNumber::Set(
            command->mEndPointId, command->serialNumber);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SerialNumber");
        }
    }
};
class SetBridgedDeviceBasicInformationReachableAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationReachableAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reachable", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &reachable, "Set the Value of on Reachable.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Reachable");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReachable, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool reachable;
    chip::EndpointId mEndPointId;

private:
    static void SetReachable(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationReachableAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationReachableAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::Reachable::Set(command->mEndPointId,
                                                                                                              command->reachable);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Reachable");
        }
    }
};
class SetBridgedDeviceBasicInformationUniqueIDAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationUniqueIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unique-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &uniqueID, "Set the Value of on UniqueID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UniqueID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUniqueID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan uniqueID;
    chip::EndpointId mEndPointId;

private:
    static void SetUniqueID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationUniqueIDAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationUniqueIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::UniqueID::Set(command->mEndPointId, command->uniqueID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UniqueID");
        }
    }
};
class SetBridgedDeviceBasicInformationFeatureMapAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::FeatureMap::Set(command->mEndPointId,
                                                                                                               command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetBridgedDeviceBasicInformationClusterRevisionAttributeCommand : public Command
{
public:
    SetBridgedDeviceBasicInformationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBridgedDeviceBasicInformationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetBridgedDeviceBasicInformationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BridgedDeviceBasicInformation::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetSwitchNumberOfPositionsAttributeCommand : public Command
{
public:
    SetSwitchNumberOfPositionsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-positions", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfPositions, "Set the Value of on NumberOfPositions.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfPositions");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfPositions, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t numberOfPositions;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfPositions(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSwitchNumberOfPositionsAttributeCommand * command =
            reinterpret_cast<SetSwitchNumberOfPositionsAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Switch::Attributes::NumberOfPositions::Set(command->mEndPointId, command->numberOfPositions);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfPositions");
        }
    }
};
class SetSwitchCurrentPositionAttributeCommand : public Command
{
public:
    SetSwitchCurrentPositionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-position", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentPosition, "Set the Value of on CurrentPosition.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentPosition");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentPosition, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentPosition;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentPosition(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSwitchCurrentPositionAttributeCommand * command = reinterpret_cast<SetSwitchCurrentPositionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Switch::Attributes::CurrentPosition::Set(command->mEndPointId, command->currentPosition);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentPosition");
        }
    }
};
class SetSwitchMultiPressMaxAttributeCommand : public Command
{
public:
    SetSwitchMultiPressMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "multi-press-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &multiPressMax, "Set the Value of on MultiPressMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MultiPressMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMultiPressMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t multiPressMax;
    chip::EndpointId mEndPointId;

private:
    static void SetMultiPressMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSwitchMultiPressMaxAttributeCommand * command = reinterpret_cast<SetSwitchMultiPressMaxAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Switch::Attributes::MultiPressMax::Set(command->mEndPointId, command->multiPressMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MultiPressMax");
        }
    }
};
class SetSwitchFeatureMapAttributeCommand : public Command
{
public:
    SetSwitchFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSwitchFeatureMapAttributeCommand * command = reinterpret_cast<SetSwitchFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Switch::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetSwitchClusterRevisionAttributeCommand : public Command
{
public:
    SetSwitchClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetSwitchClusterRevisionAttributeCommand * command = reinterpret_cast<SetSwitchClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Switch::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetAdministratorCommissioningWindowStatusAttributeCommand : public Command
{
public:
    SetAdministratorCommissioningWindowStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "window-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &windowStatus, "Set the Value of on WindowStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WindowStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWindowStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum windowStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetWindowStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAdministratorCommissioningWindowStatusAttributeCommand * command =
            reinterpret_cast<SetAdministratorCommissioningWindowStatusAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::AdministratorCommissioning::Attributes::WindowStatus::Set(
            command->mEndPointId, command->windowStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WindowStatus");
        }
    }
};
class SetAdministratorCommissioningAdminFabricIndexAttributeCommand : public Command
{
public:
    SetAdministratorCommissioningAdminFabricIndexAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "admin-fabric-index", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &adminFabricIndex, "Set the Value of on AdminFabricIndex.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AdminFabricIndex");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAdminFabricIndex, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::FabricIndex> adminFabricIndex;
    chip::EndpointId mEndPointId;

private:
    static void SetAdminFabricIndex(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAdministratorCommissioningAdminFabricIndexAttributeCommand * command =
            reinterpret_cast<SetAdministratorCommissioningAdminFabricIndexAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::AdministratorCommissioning::Attributes::AdminFabricIndex::Set(
            command->mEndPointId, command->adminFabricIndex);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AdminFabricIndex");
        }
    }
};
class SetAdministratorCommissioningAdminVendorIdAttributeCommand : public Command
{
public:
    SetAdministratorCommissioningAdminVendorIdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "admin-vendor-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &adminVendorId, "Set the Value of on AdminVendorId.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AdminVendorId");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAdminVendorId, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> adminVendorId;
    chip::EndpointId mEndPointId;

private:
    static void SetAdminVendorId(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAdministratorCommissioningAdminVendorIdAttributeCommand * command =
            reinterpret_cast<SetAdministratorCommissioningAdminVendorIdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::AdministratorCommissioning::Attributes::AdminVendorId::Set(
            command->mEndPointId, command->adminVendorId);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AdminVendorId");
        }
    }
};
class SetAdministratorCommissioningFeatureMapAttributeCommand : public Command
{
public:
    SetAdministratorCommissioningFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAdministratorCommissioningFeatureMapAttributeCommand * command =
            reinterpret_cast<SetAdministratorCommissioningFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AdministratorCommissioning::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetAdministratorCommissioningClusterRevisionAttributeCommand : public Command
{
public:
    SetAdministratorCommissioningClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAdministratorCommissioningClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetAdministratorCommissioningClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::AdministratorCommissioning::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetOperationalCredentialsSupportedFabricsAttributeCommand : public Command
{
public:
    SetOperationalCredentialsSupportedFabricsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "supported-fabrics", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &supportedFabrics, "Set the Value of on SupportedFabrics.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SupportedFabrics");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSupportedFabrics, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t supportedFabrics;
    chip::EndpointId mEndPointId;

private:
    static void SetSupportedFabrics(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOperationalCredentialsSupportedFabricsAttributeCommand * command =
            reinterpret_cast<SetOperationalCredentialsSupportedFabricsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OperationalCredentials::Attributes::SupportedFabrics::Set(
            command->mEndPointId, command->supportedFabrics);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SupportedFabrics");
        }
    }
};
class SetOperationalCredentialsCommissionedFabricsAttributeCommand : public Command
{
public:
    SetOperationalCredentialsCommissionedFabricsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "commissioned-fabrics", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &commissionedFabrics, "Set the Value of on CommissionedFabrics.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CommissionedFabrics");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCommissionedFabrics, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t commissionedFabrics;
    chip::EndpointId mEndPointId;

private:
    static void SetCommissionedFabrics(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOperationalCredentialsCommissionedFabricsAttributeCommand * command =
            reinterpret_cast<SetOperationalCredentialsCommissionedFabricsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OperationalCredentials::Attributes::CommissionedFabrics::Set(
            command->mEndPointId, command->commissionedFabrics);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CommissionedFabrics");
        }
    }
};
class SetOperationalCredentialsCurrentFabricIndexAttributeCommand : public Command
{
public:
    SetOperationalCredentialsCurrentFabricIndexAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-fabric-index", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentFabricIndex, "Set the Value of on CurrentFabricIndex.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentFabricIndex");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentFabricIndex, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentFabricIndex;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentFabricIndex(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOperationalCredentialsCurrentFabricIndexAttributeCommand * command =
            reinterpret_cast<SetOperationalCredentialsCurrentFabricIndexAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OperationalCredentials::Attributes::CurrentFabricIndex::Set(
            command->mEndPointId, command->currentFabricIndex);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentFabricIndex");
        }
    }
};
class SetOperationalCredentialsFeatureMapAttributeCommand : public Command
{
public:
    SetOperationalCredentialsFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOperationalCredentialsFeatureMapAttributeCommand * command =
            reinterpret_cast<SetOperationalCredentialsFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OperationalCredentials::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetOperationalCredentialsClusterRevisionAttributeCommand : public Command
{
public:
    SetOperationalCredentialsClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOperationalCredentialsClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetOperationalCredentialsClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OperationalCredentials::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetGroupKeyManagementMaxGroupsPerFabricAttributeCommand : public Command
{
public:
    SetGroupKeyManagementMaxGroupsPerFabricAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-groups-per-fabric", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxGroupsPerFabric, "Set the Value of on MaxGroupsPerFabric.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxGroupsPerFabric");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxGroupsPerFabric, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t maxGroupsPerFabric;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxGroupsPerFabric(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGroupKeyManagementMaxGroupsPerFabricAttributeCommand * command =
            reinterpret_cast<SetGroupKeyManagementMaxGroupsPerFabricAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GroupKeyManagement::Attributes::MaxGroupsPerFabric::Set(
            command->mEndPointId, command->maxGroupsPerFabric);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxGroupsPerFabric");
        }
    }
};
class SetGroupKeyManagementMaxGroupKeysPerFabricAttributeCommand : public Command
{
public:
    SetGroupKeyManagementMaxGroupKeysPerFabricAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-group-keys-per-fabric", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxGroupKeysPerFabric, "Set the Value of on MaxGroupKeysPerFabric.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxGroupKeysPerFabric");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxGroupKeysPerFabric, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t maxGroupKeysPerFabric;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxGroupKeysPerFabric(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGroupKeyManagementMaxGroupKeysPerFabricAttributeCommand * command =
            reinterpret_cast<SetGroupKeyManagementMaxGroupKeysPerFabricAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GroupKeyManagement::Attributes::MaxGroupKeysPerFabric::Set(
            command->mEndPointId, command->maxGroupKeysPerFabric);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxGroupKeysPerFabric");
        }
    }
};
class SetGroupKeyManagementFeatureMapAttributeCommand : public Command
{
public:
    SetGroupKeyManagementFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGroupKeyManagementFeatureMapAttributeCommand * command =
            reinterpret_cast<SetGroupKeyManagementFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::GroupKeyManagement::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetGroupKeyManagementClusterRevisionAttributeCommand : public Command
{
public:
    SetGroupKeyManagementClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetGroupKeyManagementClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetGroupKeyManagementClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::GroupKeyManagement::Attributes::ClusterRevision::Set(command->mEndPointId,
                                                                                                         command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetFixedLabelFeatureMapAttributeCommand : public Command
{
public:
    SetFixedLabelFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFixedLabelFeatureMapAttributeCommand * command = reinterpret_cast<SetFixedLabelFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FixedLabel::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetFixedLabelClusterRevisionAttributeCommand : public Command
{
public:
    SetFixedLabelClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFixedLabelClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetFixedLabelClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FixedLabel::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetUserLabelFeatureMapAttributeCommand : public Command
{
public:
    SetUserLabelFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUserLabelFeatureMapAttributeCommand * command = reinterpret_cast<SetUserLabelFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UserLabel::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetUserLabelClusterRevisionAttributeCommand : public Command
{
public:
    SetUserLabelClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUserLabelClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetUserLabelClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UserLabel::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetProxyConfigurationFeatureMapAttributeCommand : public Command
{
public:
    SetProxyConfigurationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetProxyConfigurationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetProxyConfigurationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ProxyConfiguration::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetProxyConfigurationClusterRevisionAttributeCommand : public Command
{
public:
    SetProxyConfigurationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetProxyConfigurationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetProxyConfigurationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ProxyConfiguration::Attributes::ClusterRevision::Set(command->mEndPointId,
                                                                                                         command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetProxyDiscoveryFeatureMapAttributeCommand : public Command
{
public:
    SetProxyDiscoveryFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetProxyDiscoveryFeatureMapAttributeCommand * command =
            reinterpret_cast<SetProxyDiscoveryFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ProxyDiscovery::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetProxyDiscoveryClusterRevisionAttributeCommand : public Command
{
public:
    SetProxyDiscoveryClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetProxyDiscoveryClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetProxyDiscoveryClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ProxyDiscovery::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetProxyValidFeatureMapAttributeCommand : public Command
{
public:
    SetProxyValidFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetProxyValidFeatureMapAttributeCommand * command = reinterpret_cast<SetProxyValidFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ProxyValid::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetProxyValidClusterRevisionAttributeCommand : public Command
{
public:
    SetProxyValidClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetProxyValidClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetProxyValidClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ProxyValid::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetBooleanStateStateValueAttributeCommand : public Command
{
public:
    SetBooleanStateStateValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "state-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &stateValue, "Set the Value of on StateValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StateValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStateValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool stateValue;
    chip::EndpointId mEndPointId;

private:
    static void SetStateValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBooleanStateStateValueAttributeCommand * command =
            reinterpret_cast<SetBooleanStateStateValueAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BooleanState::Attributes::StateValue::Set(command->mEndPointId, command->stateValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StateValue");
        }
    }
};
class SetBooleanStateFeatureMapAttributeCommand : public Command
{
public:
    SetBooleanStateFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBooleanStateFeatureMapAttributeCommand * command =
            reinterpret_cast<SetBooleanStateFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BooleanState::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetBooleanStateClusterRevisionAttributeCommand : public Command
{
public:
    SetBooleanStateClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBooleanStateClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetBooleanStateClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BooleanState::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetModeSelectDescriptionAttributeCommand : public Command
{
public:
    SetModeSelectDescriptionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "description", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &description, "Set the Value of on Description.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Description");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDescription, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan description;
    chip::EndpointId mEndPointId;

private:
    static void SetDescription(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetModeSelectDescriptionAttributeCommand * command = reinterpret_cast<SetModeSelectDescriptionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ModeSelect::Attributes::Description::Set(command->mEndPointId, command->description);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Description");
        }
    }
};
class SetModeSelectStandardNamespaceAttributeCommand : public Command
{
public:
    SetModeSelectStandardNamespaceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "standard-namespace", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &standardNamespace, "Set the Value of on StandardNamespace.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StandardNamespace");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStandardNamespace, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> standardNamespace;
    chip::EndpointId mEndPointId;

private:
    static void SetStandardNamespace(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetModeSelectStandardNamespaceAttributeCommand * command =
            reinterpret_cast<SetModeSelectStandardNamespaceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ModeSelect::Attributes::StandardNamespace::Set(command->mEndPointId, command->standardNamespace);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StandardNamespace");
        }
    }
};
class SetModeSelectCurrentModeAttributeCommand : public Command
{
public:
    SetModeSelectCurrentModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentMode, "Set the Value of on CurrentMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentMode;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetModeSelectCurrentModeAttributeCommand * command = reinterpret_cast<SetModeSelectCurrentModeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ModeSelect::Attributes::CurrentMode::Set(command->mEndPointId, command->currentMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentMode");
        }
    }
};
class SetModeSelectStartUpModeAttributeCommand : public Command
{
public:
    SetModeSelectStartUpModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "start-up-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &startUpMode, "Set the Value of on StartUpMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StartUpMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStartUpMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> startUpMode;
    chip::EndpointId mEndPointId;

private:
    static void SetStartUpMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetModeSelectStartUpModeAttributeCommand * command = reinterpret_cast<SetModeSelectStartUpModeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ModeSelect::Attributes::StartUpMode::Set(command->mEndPointId, command->startUpMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StartUpMode");
        }
    }
};
class SetModeSelectOnModeAttributeCommand : public Command
{
public:
    SetModeSelectOnModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "on-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &onMode, "Set the Value of on OnMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OnMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOnMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> onMode;
    chip::EndpointId mEndPointId;

private:
    static void SetOnMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetModeSelectOnModeAttributeCommand * command = reinterpret_cast<SetModeSelectOnModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ModeSelect::Attributes::OnMode::Set(command->mEndPointId, command->onMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OnMode");
        }
    }
};
class SetModeSelectFeatureMapAttributeCommand : public Command
{
public:
    SetModeSelectFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetModeSelectFeatureMapAttributeCommand * command = reinterpret_cast<SetModeSelectFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ModeSelect::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetModeSelectClusterRevisionAttributeCommand : public Command
{
public:
    SetModeSelectClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetModeSelectClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetModeSelectClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ModeSelect::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetDoorLockLockStateAttributeCommand : public Command
{
public:
    SetDoorLockLockStateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lock-state", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &lockState, "Set the Value of on LockState.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LockState");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLockState, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> lockState;
    chip::EndpointId mEndPointId;

private:
    static void SetLockState(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockLockStateAttributeCommand * command = reinterpret_cast<SetDoorLockLockStateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::LockState::Set(command->mEndPointId, command->lockState);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LockState");
        }
    }
};
class SetDoorLockLockTypeAttributeCommand : public Command
{
public:
    SetDoorLockLockTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lock-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &lockType, "Set the Value of on LockType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LockType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLockType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::DoorLock::DlLockType lockType;
    chip::EndpointId mEndPointId;

private:
    static void SetLockType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockLockTypeAttributeCommand * command = reinterpret_cast<SetDoorLockLockTypeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::LockType::Set(command->mEndPointId, command->lockType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LockType");
        }
    }
};
class SetDoorLockActuatorEnabledAttributeCommand : public Command
{
public:
    SetDoorLockActuatorEnabledAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "actuator-enabled", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &actuatorEnabled, "Set the Value of on ActuatorEnabled.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActuatorEnabled");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActuatorEnabled, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool actuatorEnabled;
    chip::EndpointId mEndPointId;

private:
    static void SetActuatorEnabled(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockActuatorEnabledAttributeCommand * command =
            reinterpret_cast<SetDoorLockActuatorEnabledAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::ActuatorEnabled::Set(command->mEndPointId, command->actuatorEnabled);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActuatorEnabled");
        }
    }
};
class SetDoorLockDoorStateAttributeCommand : public Command
{
public:
    SetDoorLockDoorStateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "door-state", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &doorState, "Set the Value of on DoorState.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DoorState");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDoorState, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorStateEnum> doorState;
    chip::EndpointId mEndPointId;

private:
    static void SetDoorState(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockDoorStateAttributeCommand * command = reinterpret_cast<SetDoorLockDoorStateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::DoorState::Set(command->mEndPointId, command->doorState);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DoorState");
        }
    }
};
class SetDoorLockDoorOpenEventsAttributeCommand : public Command
{
public:
    SetDoorLockDoorOpenEventsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "door-open-events", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &doorOpenEvents, "Set the Value of on DoorOpenEvents.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DoorOpenEvents");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDoorOpenEvents, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t doorOpenEvents;
    chip::EndpointId mEndPointId;

private:
    static void SetDoorOpenEvents(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockDoorOpenEventsAttributeCommand * command =
            reinterpret_cast<SetDoorLockDoorOpenEventsAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::DoorOpenEvents::Set(command->mEndPointId, command->doorOpenEvents);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DoorOpenEvents");
        }
    }
};
class SetDoorLockDoorClosedEventsAttributeCommand : public Command
{
public:
    SetDoorLockDoorClosedEventsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "door-closed-events", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &doorClosedEvents, "Set the Value of on DoorClosedEvents.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DoorClosedEvents");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDoorClosedEvents, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t doorClosedEvents;
    chip::EndpointId mEndPointId;

private:
    static void SetDoorClosedEvents(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockDoorClosedEventsAttributeCommand * command =
            reinterpret_cast<SetDoorLockDoorClosedEventsAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::DoorClosedEvents::Set(command->mEndPointId, command->doorClosedEvents);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DoorClosedEvents");
        }
    }
};
class SetDoorLockOpenPeriodAttributeCommand : public Command
{
public:
    SetDoorLockOpenPeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "open-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &openPeriod, "Set the Value of on OpenPeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OpenPeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOpenPeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t openPeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetOpenPeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockOpenPeriodAttributeCommand * command = reinterpret_cast<SetDoorLockOpenPeriodAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::OpenPeriod::Set(command->mEndPointId, command->openPeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OpenPeriod");
        }
    }
};
class SetDoorLockNumberOfTotalUsersSupportedAttributeCommand : public Command
{
public:
    SetDoorLockNumberOfTotalUsersSupportedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-total-users-supported", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &numberOfTotalUsersSupported,
                    "Set the Value of on NumberOfTotalUsersSupported.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfTotalUsersSupported");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfTotalUsersSupported, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t numberOfTotalUsersSupported;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfTotalUsersSupported(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockNumberOfTotalUsersSupportedAttributeCommand * command =
            reinterpret_cast<SetDoorLockNumberOfTotalUsersSupportedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::NumberOfTotalUsersSupported::Set(
            command->mEndPointId, command->numberOfTotalUsersSupported);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfTotalUsersSupported");
        }
    }
};
class SetDoorLockNumberOfPINUsersSupportedAttributeCommand : public Command
{
public:
    SetDoorLockNumberOfPINUsersSupportedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-pinusers-supported", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &numberOfPINUsersSupported, "Set the Value of on NumberOfPINUsersSupported.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfPINUsersSupported");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfPINUsersSupported, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t numberOfPINUsersSupported;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfPINUsersSupported(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockNumberOfPINUsersSupportedAttributeCommand * command =
            reinterpret_cast<SetDoorLockNumberOfPINUsersSupportedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::NumberOfPINUsersSupported::Set(
            command->mEndPointId, command->numberOfPINUsersSupported);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfPINUsersSupported");
        }
    }
};
class SetDoorLockNumberOfRFIDUsersSupportedAttributeCommand : public Command
{
public:
    SetDoorLockNumberOfRFIDUsersSupportedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-rfidusers-supported", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &numberOfRFIDUsersSupported,
                    "Set the Value of on NumberOfRFIDUsersSupported.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfRFIDUsersSupported");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfRFIDUsersSupported, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t numberOfRFIDUsersSupported;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfRFIDUsersSupported(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockNumberOfRFIDUsersSupportedAttributeCommand * command =
            reinterpret_cast<SetDoorLockNumberOfRFIDUsersSupportedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::NumberOfRFIDUsersSupported::Set(
            command->mEndPointId, command->numberOfRFIDUsersSupported);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfRFIDUsersSupported");
        }
    }
};
class SetDoorLockNumberOfWeekDaySchedulesSupportedPerUserAttributeCommand : public Command
{
public:
    SetDoorLockNumberOfWeekDaySchedulesSupportedPerUserAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-week-day-schedules-supported-per-user", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfWeekDaySchedulesSupportedPerUser,
                    "Set the Value of on NumberOfWeekDaySchedulesSupportedPerUser.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfWeekDaySchedulesSupportedPerUser");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfWeekDaySchedulesSupportedPerUser,
                                                      reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t numberOfWeekDaySchedulesSupportedPerUser;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfWeekDaySchedulesSupportedPerUser(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockNumberOfWeekDaySchedulesSupportedPerUserAttributeCommand * command =
            reinterpret_cast<SetDoorLockNumberOfWeekDaySchedulesSupportedPerUserAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::NumberOfWeekDaySchedulesSupportedPerUser::Set(
            command->mEndPointId, command->numberOfWeekDaySchedulesSupportedPerUser);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfWeekDaySchedulesSupportedPerUser");
        }
    }
};
class SetDoorLockNumberOfYearDaySchedulesSupportedPerUserAttributeCommand : public Command
{
public:
    SetDoorLockNumberOfYearDaySchedulesSupportedPerUserAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-year-day-schedules-supported-per-user", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfYearDaySchedulesSupportedPerUser,
                    "Set the Value of on NumberOfYearDaySchedulesSupportedPerUser.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfYearDaySchedulesSupportedPerUser");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfYearDaySchedulesSupportedPerUser,
                                                      reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t numberOfYearDaySchedulesSupportedPerUser;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfYearDaySchedulesSupportedPerUser(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockNumberOfYearDaySchedulesSupportedPerUserAttributeCommand * command =
            reinterpret_cast<SetDoorLockNumberOfYearDaySchedulesSupportedPerUserAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::NumberOfYearDaySchedulesSupportedPerUser::Set(
            command->mEndPointId, command->numberOfYearDaySchedulesSupportedPerUser);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfYearDaySchedulesSupportedPerUser");
        }
    }
};
class SetDoorLockNumberOfHolidaySchedulesSupportedAttributeCommand : public Command
{
public:
    SetDoorLockNumberOfHolidaySchedulesSupportedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-holiday-schedules-supported", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfHolidaySchedulesSupported,
                    "Set the Value of on NumberOfHolidaySchedulesSupported.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfHolidaySchedulesSupported");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfHolidaySchedulesSupported, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t numberOfHolidaySchedulesSupported;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfHolidaySchedulesSupported(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockNumberOfHolidaySchedulesSupportedAttributeCommand * command =
            reinterpret_cast<SetDoorLockNumberOfHolidaySchedulesSupportedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::NumberOfHolidaySchedulesSupported::Set(
            command->mEndPointId, command->numberOfHolidaySchedulesSupported);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfHolidaySchedulesSupported");
        }
    }
};
class SetDoorLockMaxPINCodeLengthAttributeCommand : public Command
{
public:
    SetDoorLockMaxPINCodeLengthAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-pincode-length", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &maxPINCodeLength, "Set the Value of on MaxPINCodeLength.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxPINCodeLength");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxPINCodeLength, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t maxPINCodeLength;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxPINCodeLength(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockMaxPINCodeLengthAttributeCommand * command =
            reinterpret_cast<SetDoorLockMaxPINCodeLengthAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::MaxPINCodeLength::Set(command->mEndPointId, command->maxPINCodeLength);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxPINCodeLength");
        }
    }
};
class SetDoorLockMinPINCodeLengthAttributeCommand : public Command
{
public:
    SetDoorLockMinPINCodeLengthAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-pincode-length", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &minPINCodeLength, "Set the Value of on MinPINCodeLength.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinPINCodeLength");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinPINCodeLength, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t minPINCodeLength;
    chip::EndpointId mEndPointId;

private:
    static void SetMinPINCodeLength(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockMinPINCodeLengthAttributeCommand * command =
            reinterpret_cast<SetDoorLockMinPINCodeLengthAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::MinPINCodeLength::Set(command->mEndPointId, command->minPINCodeLength);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinPINCodeLength");
        }
    }
};
class SetDoorLockMaxRFIDCodeLengthAttributeCommand : public Command
{
public:
    SetDoorLockMaxRFIDCodeLengthAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-rfidcode-length", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &maxRFIDCodeLength, "Set the Value of on MaxRFIDCodeLength.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxRFIDCodeLength");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxRFIDCodeLength, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t maxRFIDCodeLength;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxRFIDCodeLength(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockMaxRFIDCodeLengthAttributeCommand * command =
            reinterpret_cast<SetDoorLockMaxRFIDCodeLengthAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::MaxRFIDCodeLength::Set(command->mEndPointId, command->maxRFIDCodeLength);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxRFIDCodeLength");
        }
    }
};
class SetDoorLockMinRFIDCodeLengthAttributeCommand : public Command
{
public:
    SetDoorLockMinRFIDCodeLengthAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-rfidcode-length", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &minRFIDCodeLength, "Set the Value of on MinRFIDCodeLength.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinRFIDCodeLength");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinRFIDCodeLength, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t minRFIDCodeLength;
    chip::EndpointId mEndPointId;

private:
    static void SetMinRFIDCodeLength(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockMinRFIDCodeLengthAttributeCommand * command =
            reinterpret_cast<SetDoorLockMinRFIDCodeLengthAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::MinRFIDCodeLength::Set(command->mEndPointId, command->minRFIDCodeLength);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinRFIDCodeLength");
        }
    }
};
class SetDoorLockCredentialRulesSupportAttributeCommand : public Command
{
public:
    SetDoorLockCredentialRulesSupportAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "credential-rules-support", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &credentialRulesSupport, "Set the Value of on CredentialRulesSupport.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CredentialRulesSupport");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCredentialRulesSupport, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask> credentialRulesSupport;
    chip::EndpointId mEndPointId;

private:
    static void SetCredentialRulesSupport(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockCredentialRulesSupportAttributeCommand * command =
            reinterpret_cast<SetDoorLockCredentialRulesSupportAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::CredentialRulesSupport::Set(
            command->mEndPointId, command->credentialRulesSupport);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CredentialRulesSupport");
        }
    }
};
class SetDoorLockNumberOfCredentialsSupportedPerUserAttributeCommand : public Command
{
public:
    SetDoorLockNumberOfCredentialsSupportedPerUserAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-credentials-supported-per-user", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfCredentialsSupportedPerUser,
                    "Set the Value of on NumberOfCredentialsSupportedPerUser.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfCredentialsSupportedPerUser");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfCredentialsSupportedPerUser, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t numberOfCredentialsSupportedPerUser;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfCredentialsSupportedPerUser(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockNumberOfCredentialsSupportedPerUserAttributeCommand * command =
            reinterpret_cast<SetDoorLockNumberOfCredentialsSupportedPerUserAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::NumberOfCredentialsSupportedPerUser::Set(
            command->mEndPointId, command->numberOfCredentialsSupportedPerUser);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfCredentialsSupportedPerUser");
        }
    }
};
class SetDoorLockLanguageAttributeCommand : public Command
{
public:
    SetDoorLockLanguageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "language", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &language, "Set the Value of on Language.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Language");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLanguage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan language;
    chip::EndpointId mEndPointId;

private:
    static void SetLanguage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockLanguageAttributeCommand * command = reinterpret_cast<SetDoorLockLanguageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::Language::Set(command->mEndPointId, command->language);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Language");
        }
    }
};
class SetDoorLockLEDSettingsAttributeCommand : public Command
{
public:
    SetDoorLockLEDSettingsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ledsettings", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &LEDSettings, "Set the Value of on LEDSettings.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LEDSettings");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLEDSettings, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t LEDSettings;
    chip::EndpointId mEndPointId;

private:
    static void SetLEDSettings(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockLEDSettingsAttributeCommand * command = reinterpret_cast<SetDoorLockLEDSettingsAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::LEDSettings::Set(command->mEndPointId, command->LEDSettings);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LEDSettings");
        }
    }
};
class SetDoorLockAutoRelockTimeAttributeCommand : public Command
{
public:
    SetDoorLockAutoRelockTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "auto-relock-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &autoRelockTime, "Set the Value of on AutoRelockTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AutoRelockTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAutoRelockTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t autoRelockTime;
    chip::EndpointId mEndPointId;

private:
    static void SetAutoRelockTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockAutoRelockTimeAttributeCommand * command =
            reinterpret_cast<SetDoorLockAutoRelockTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::AutoRelockTime::Set(command->mEndPointId, command->autoRelockTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AutoRelockTime");
        }
    }
};
class SetDoorLockSoundVolumeAttributeCommand : public Command
{
public:
    SetDoorLockSoundVolumeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "sound-volume", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &soundVolume, "Set the Value of on SoundVolume.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SoundVolume");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSoundVolume, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t soundVolume;
    chip::EndpointId mEndPointId;

private:
    static void SetSoundVolume(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockSoundVolumeAttributeCommand * command = reinterpret_cast<SetDoorLockSoundVolumeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::SoundVolume::Set(command->mEndPointId, command->soundVolume);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SoundVolume");
        }
    }
};
class SetDoorLockOperatingModeAttributeCommand : public Command
{
public:
    SetDoorLockOperatingModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "operating-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &operatingMode, "Set the Value of on OperatingMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OperatingMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOperatingMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::DoorLock::OperatingModeEnum operatingMode;
    chip::EndpointId mEndPointId;

private:
    static void SetOperatingMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockOperatingModeAttributeCommand * command = reinterpret_cast<SetDoorLockOperatingModeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::OperatingMode::Set(command->mEndPointId, command->operatingMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OperatingMode");
        }
    }
};
class SetDoorLockSupportedOperatingModesAttributeCommand : public Command
{
public:
    SetDoorLockSupportedOperatingModesAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "supported-operating-modes", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &supportedOperatingModes, "Set the Value of on SupportedOperatingModes.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SupportedOperatingModes");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSupportedOperatingModes, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes> supportedOperatingModes;
    chip::EndpointId mEndPointId;

private:
    static void SetSupportedOperatingModes(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockSupportedOperatingModesAttributeCommand * command =
            reinterpret_cast<SetDoorLockSupportedOperatingModesAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::SupportedOperatingModes::Set(
            command->mEndPointId, command->supportedOperatingModes);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SupportedOperatingModes");
        }
    }
};
class SetDoorLockDefaultConfigurationRegisterAttributeCommand : public Command
{
public:
    SetDoorLockDefaultConfigurationRegisterAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "default-configuration-register", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &defaultConfigurationRegister,
                    "Set the Value of on DefaultConfigurationRegister.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DefaultConfigurationRegister");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDefaultConfigurationRegister, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister> defaultConfigurationRegister;
    chip::EndpointId mEndPointId;

private:
    static void SetDefaultConfigurationRegister(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockDefaultConfigurationRegisterAttributeCommand * command =
            reinterpret_cast<SetDoorLockDefaultConfigurationRegisterAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::DefaultConfigurationRegister::Set(
            command->mEndPointId, command->defaultConfigurationRegister);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DefaultConfigurationRegister");
        }
    }
};
class SetDoorLockEnableLocalProgrammingAttributeCommand : public Command
{
public:
    SetDoorLockEnableLocalProgrammingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enable-local-programming", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &enableLocalProgramming, "Set the Value of on EnableLocalProgramming.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EnableLocalProgramming");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnableLocalProgramming, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool enableLocalProgramming;
    chip::EndpointId mEndPointId;

private:
    static void SetEnableLocalProgramming(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockEnableLocalProgrammingAttributeCommand * command =
            reinterpret_cast<SetDoorLockEnableLocalProgrammingAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::EnableLocalProgramming::Set(
            command->mEndPointId, command->enableLocalProgramming);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EnableLocalProgramming");
        }
    }
};
class SetDoorLockEnableOneTouchLockingAttributeCommand : public Command
{
public:
    SetDoorLockEnableOneTouchLockingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enable-one-touch-locking", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &enableOneTouchLocking, "Set the Value of on EnableOneTouchLocking.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EnableOneTouchLocking");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnableOneTouchLocking, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool enableOneTouchLocking;
    chip::EndpointId mEndPointId;

private:
    static void SetEnableOneTouchLocking(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockEnableOneTouchLockingAttributeCommand * command =
            reinterpret_cast<SetDoorLockEnableOneTouchLockingAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::EnableOneTouchLocking::Set(
            command->mEndPointId, command->enableOneTouchLocking);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EnableOneTouchLocking");
        }
    }
};
class SetDoorLockEnableInsideStatusLEDAttributeCommand : public Command
{
public:
    SetDoorLockEnableInsideStatusLEDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enable-inside-status-led", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &enableInsideStatusLED, "Set the Value of on EnableInsideStatusLED.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EnableInsideStatusLED");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnableInsideStatusLED, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool enableInsideStatusLED;
    chip::EndpointId mEndPointId;

private:
    static void SetEnableInsideStatusLED(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockEnableInsideStatusLEDAttributeCommand * command =
            reinterpret_cast<SetDoorLockEnableInsideStatusLEDAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::EnableInsideStatusLED::Set(
            command->mEndPointId, command->enableInsideStatusLED);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EnableInsideStatusLED");
        }
    }
};
class SetDoorLockEnablePrivacyModeButtonAttributeCommand : public Command
{
public:
    SetDoorLockEnablePrivacyModeButtonAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enable-privacy-mode-button", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &enablePrivacyModeButton, "Set the Value of on EnablePrivacyModeButton.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EnablePrivacyModeButton");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnablePrivacyModeButton, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool enablePrivacyModeButton;
    chip::EndpointId mEndPointId;

private:
    static void SetEnablePrivacyModeButton(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockEnablePrivacyModeButtonAttributeCommand * command =
            reinterpret_cast<SetDoorLockEnablePrivacyModeButtonAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::EnablePrivacyModeButton::Set(
            command->mEndPointId, command->enablePrivacyModeButton);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EnablePrivacyModeButton");
        }
    }
};
class SetDoorLockLocalProgrammingFeaturesAttributeCommand : public Command
{
public:
    SetDoorLockLocalProgrammingFeaturesAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "local-programming-features", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &localProgrammingFeatures, "Set the Value of on LocalProgrammingFeatures.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LocalProgrammingFeatures");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLocalProgrammingFeatures, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures> localProgrammingFeatures;
    chip::EndpointId mEndPointId;

private:
    static void SetLocalProgrammingFeatures(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockLocalProgrammingFeaturesAttributeCommand * command =
            reinterpret_cast<SetDoorLockLocalProgrammingFeaturesAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::LocalProgrammingFeatures::Set(
            command->mEndPointId, command->localProgrammingFeatures);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LocalProgrammingFeatures");
        }
    }
};
class SetDoorLockWrongCodeEntryLimitAttributeCommand : public Command
{
public:
    SetDoorLockWrongCodeEntryLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wrong-code-entry-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &wrongCodeEntryLimit, "Set the Value of on WrongCodeEntryLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WrongCodeEntryLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWrongCodeEntryLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t wrongCodeEntryLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetWrongCodeEntryLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockWrongCodeEntryLimitAttributeCommand * command =
            reinterpret_cast<SetDoorLockWrongCodeEntryLimitAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::WrongCodeEntryLimit::Set(command->mEndPointId, command->wrongCodeEntryLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WrongCodeEntryLimit");
        }
    }
};
class SetDoorLockUserCodeTemporaryDisableTimeAttributeCommand : public Command
{
public:
    SetDoorLockUserCodeTemporaryDisableTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "user-code-temporary-disable-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &userCodeTemporaryDisableTime,
                    "Set the Value of on UserCodeTemporaryDisableTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UserCodeTemporaryDisableTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUserCodeTemporaryDisableTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t userCodeTemporaryDisableTime;
    chip::EndpointId mEndPointId;

private:
    static void SetUserCodeTemporaryDisableTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockUserCodeTemporaryDisableTimeAttributeCommand * command =
            reinterpret_cast<SetDoorLockUserCodeTemporaryDisableTimeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::UserCodeTemporaryDisableTime::Set(
            command->mEndPointId, command->userCodeTemporaryDisableTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UserCodeTemporaryDisableTime");
        }
    }
};
class SetDoorLockSendPINOverTheAirAttributeCommand : public Command
{
public:
    SetDoorLockSendPINOverTheAirAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "send-pinover-the-air", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &sendPINOverTheAir, "Set the Value of on SendPINOverTheAir.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SendPINOverTheAir");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSendPINOverTheAir, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool sendPINOverTheAir;
    chip::EndpointId mEndPointId;

private:
    static void SetSendPINOverTheAir(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockSendPINOverTheAirAttributeCommand * command =
            reinterpret_cast<SetDoorLockSendPINOverTheAirAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::SendPINOverTheAir::Set(command->mEndPointId, command->sendPINOverTheAir);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SendPINOverTheAir");
        }
    }
};
class SetDoorLockRequirePINforRemoteOperationAttributeCommand : public Command
{
public:
    SetDoorLockRequirePINforRemoteOperationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "require-pinfor-remote-operation", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &requirePINforRemoteOperation, "Set the Value of on RequirePINforRemoteOperation.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RequirePINforRemoteOperation");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRequirePINforRemoteOperation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool requirePINforRemoteOperation;
    chip::EndpointId mEndPointId;

private:
    static void SetRequirePINforRemoteOperation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockRequirePINforRemoteOperationAttributeCommand * command =
            reinterpret_cast<SetDoorLockRequirePINforRemoteOperationAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::DoorLock::Attributes::RequirePINforRemoteOperation::Set(
            command->mEndPointId, command->requirePINforRemoteOperation);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RequirePINforRemoteOperation");
        }
    }
};
class SetDoorLockExpiringUserTimeoutAttributeCommand : public Command
{
public:
    SetDoorLockExpiringUserTimeoutAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "expiring-user-timeout", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &expiringUserTimeout, "Set the Value of on ExpiringUserTimeout.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ExpiringUserTimeout");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetExpiringUserTimeout, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t expiringUserTimeout;
    chip::EndpointId mEndPointId;

private:
    static void SetExpiringUserTimeout(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockExpiringUserTimeoutAttributeCommand * command =
            reinterpret_cast<SetDoorLockExpiringUserTimeoutAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::ExpiringUserTimeout::Set(command->mEndPointId, command->expiringUserTimeout);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ExpiringUserTimeout");
        }
    }
};
class SetDoorLockFeatureMapAttributeCommand : public Command
{
public:
    SetDoorLockFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockFeatureMapAttributeCommand * command = reinterpret_cast<SetDoorLockFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetDoorLockClusterRevisionAttributeCommand : public Command
{
public:
    SetDoorLockClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetDoorLockClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetDoorLockClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::DoorLock::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetWindowCoveringTypeAttributeCommand : public Command
{
public:
    SetWindowCoveringTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &type, "Set the Value of on Type.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Type");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::WindowCovering::Type type;
    chip::EndpointId mEndPointId;

private:
    static void SetType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringTypeAttributeCommand * command = reinterpret_cast<SetWindowCoveringTypeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::Type::Set(command->mEndPointId, command->type);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Type");
        }
    }
};
class SetWindowCoveringPhysicalClosedLimitLiftAttributeCommand : public Command
{
public:
    SetWindowCoveringPhysicalClosedLimitLiftAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "physical-closed-limit-lift", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &physicalClosedLimitLift, "Set the Value of on PhysicalClosedLimitLift.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhysicalClosedLimitLift");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhysicalClosedLimitLift, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t physicalClosedLimitLift;
    chip::EndpointId mEndPointId;

private:
    static void SetPhysicalClosedLimitLift(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringPhysicalClosedLimitLiftAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringPhysicalClosedLimitLiftAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::PhysicalClosedLimitLift::Set(
            command->mEndPointId, command->physicalClosedLimitLift);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhysicalClosedLimitLift");
        }
    }
};
class SetWindowCoveringPhysicalClosedLimitTiltAttributeCommand : public Command
{
public:
    SetWindowCoveringPhysicalClosedLimitTiltAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "physical-closed-limit-tilt", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &physicalClosedLimitTilt, "Set the Value of on PhysicalClosedLimitTilt.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhysicalClosedLimitTilt");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhysicalClosedLimitTilt, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t physicalClosedLimitTilt;
    chip::EndpointId mEndPointId;

private:
    static void SetPhysicalClosedLimitTilt(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringPhysicalClosedLimitTiltAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringPhysicalClosedLimitTiltAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::PhysicalClosedLimitTilt::Set(
            command->mEndPointId, command->physicalClosedLimitTilt);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhysicalClosedLimitTilt");
        }
    }
};
class SetWindowCoveringCurrentPositionLiftAttributeCommand : public Command
{
public:
    SetWindowCoveringCurrentPositionLiftAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-position-lift", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentPositionLift, "Set the Value of on CurrentPositionLift.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentPositionLift");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentPositionLift, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> currentPositionLift;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentPositionLift(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringCurrentPositionLiftAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringCurrentPositionLiftAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLift::Set(
            command->mEndPointId, command->currentPositionLift);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentPositionLift");
        }
    }
};
class SetWindowCoveringCurrentPositionTiltAttributeCommand : public Command
{
public:
    SetWindowCoveringCurrentPositionTiltAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-position-tilt", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentPositionTilt, "Set the Value of on CurrentPositionTilt.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentPositionTilt");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentPositionTilt, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> currentPositionTilt;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentPositionTilt(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringCurrentPositionTiltAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringCurrentPositionTiltAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTilt::Set(
            command->mEndPointId, command->currentPositionTilt);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentPositionTilt");
        }
    }
};
class SetWindowCoveringNumberOfActuationsLiftAttributeCommand : public Command
{
public:
    SetWindowCoveringNumberOfActuationsLiftAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-actuations-lift", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &numberOfActuationsLift, "Set the Value of on NumberOfActuationsLift.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfActuationsLift");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfActuationsLift, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t numberOfActuationsLift;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfActuationsLift(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringNumberOfActuationsLiftAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringNumberOfActuationsLiftAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::NumberOfActuationsLift::Set(
            command->mEndPointId, command->numberOfActuationsLift);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfActuationsLift");
        }
    }
};
class SetWindowCoveringNumberOfActuationsTiltAttributeCommand : public Command
{
public:
    SetWindowCoveringNumberOfActuationsTiltAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-actuations-tilt", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &numberOfActuationsTilt, "Set the Value of on NumberOfActuationsTilt.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfActuationsTilt");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfActuationsTilt, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t numberOfActuationsTilt;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfActuationsTilt(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringNumberOfActuationsTiltAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringNumberOfActuationsTiltAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::NumberOfActuationsTilt::Set(
            command->mEndPointId, command->numberOfActuationsTilt);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfActuationsTilt");
        }
    }
};
class SetWindowCoveringConfigStatusAttributeCommand : public Command
{
public:
    SetWindowCoveringConfigStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "config-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &configStatus, "Set the Value of on ConfigStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ConfigStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetConfigStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus> configStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetConfigStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringConfigStatusAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringConfigStatusAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WindowCovering::Attributes::ConfigStatus::Set(command->mEndPointId, command->configStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ConfigStatus");
        }
    }
};
class SetWindowCoveringCurrentPositionLiftPercentageAttributeCommand : public Command
{
public:
    SetWindowCoveringCurrentPositionLiftPercentageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-position-lift-percentage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentPositionLiftPercentage,
                    "Set the Value of on CurrentPositionLiftPercentage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentPositionLiftPercentage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentPositionLiftPercentage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::Percent> currentPositionLiftPercentage;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentPositionLiftPercentage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringCurrentPositionLiftPercentageAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringCurrentPositionLiftPercentageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercentage::Set(
            command->mEndPointId, command->currentPositionLiftPercentage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentPositionLiftPercentage");
        }
    }
};
class SetWindowCoveringCurrentPositionTiltPercentageAttributeCommand : public Command
{
public:
    SetWindowCoveringCurrentPositionTiltPercentageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-position-tilt-percentage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentPositionTiltPercentage,
                    "Set the Value of on CurrentPositionTiltPercentage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentPositionTiltPercentage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentPositionTiltPercentage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::Percent> currentPositionTiltPercentage;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentPositionTiltPercentage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringCurrentPositionTiltPercentageAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringCurrentPositionTiltPercentageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercentage::Set(
            command->mEndPointId, command->currentPositionTiltPercentage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentPositionTiltPercentage");
        }
    }
};
class SetWindowCoveringOperationalStatusAttributeCommand : public Command
{
public:
    SetWindowCoveringOperationalStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "operational-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &operationalStatus, "Set the Value of on OperationalStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OperationalStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOperationalStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus> operationalStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetOperationalStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringOperationalStatusAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringOperationalStatusAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::OperationalStatus::Set(command->mEndPointId,
                                                                                                       command->operationalStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OperationalStatus");
        }
    }
};
class SetWindowCoveringTargetPositionLiftPercent100thsAttributeCommand : public Command
{
public:
    SetWindowCoveringTargetPositionLiftPercent100thsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "target-position-lift-percent100ths", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &targetPositionLiftPercent100ths,
                    "Set the Value of on TargetPositionLiftPercent100ths.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TargetPositionLiftPercent100ths");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTargetPositionLiftPercent100ths, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::Percent100ths> targetPositionLiftPercent100ths;
    chip::EndpointId mEndPointId;

private:
    static void SetTargetPositionLiftPercent100ths(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringTargetPositionLiftPercent100thsAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringTargetPositionLiftPercent100thsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::TargetPositionLiftPercent100ths::Set(
            command->mEndPointId, command->targetPositionLiftPercent100ths);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TargetPositionLiftPercent100ths");
        }
    }
};
class SetWindowCoveringTargetPositionTiltPercent100thsAttributeCommand : public Command
{
public:
    SetWindowCoveringTargetPositionTiltPercent100thsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "target-position-tilt-percent100ths", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &targetPositionTiltPercent100ths,
                    "Set the Value of on TargetPositionTiltPercent100ths.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TargetPositionTiltPercent100ths");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTargetPositionTiltPercent100ths, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::Percent100ths> targetPositionTiltPercent100ths;
    chip::EndpointId mEndPointId;

private:
    static void SetTargetPositionTiltPercent100ths(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringTargetPositionTiltPercent100thsAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringTargetPositionTiltPercent100thsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::TargetPositionTiltPercent100ths::Set(
            command->mEndPointId, command->targetPositionTiltPercent100ths);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TargetPositionTiltPercent100ths");
        }
    }
};
class SetWindowCoveringEndProductTypeAttributeCommand : public Command
{
public:
    SetWindowCoveringEndProductTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "end-product-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &endProductType, "Set the Value of on EndProductType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EndProductType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEndProductType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::WindowCovering::EndProductType endProductType;
    chip::EndpointId mEndPointId;

private:
    static void SetEndProductType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringEndProductTypeAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringEndProductTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WindowCovering::Attributes::EndProductType::Set(command->mEndPointId, command->endProductType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EndProductType");
        }
    }
};
class SetWindowCoveringCurrentPositionLiftPercent100thsAttributeCommand : public Command
{
public:
    SetWindowCoveringCurrentPositionLiftPercent100thsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-position-lift-percent100ths", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentPositionLiftPercent100ths,
                    "Set the Value of on CurrentPositionLiftPercent100ths.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentPositionLiftPercent100ths");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentPositionLiftPercent100ths, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::Percent100ths> currentPositionLiftPercent100ths;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentPositionLiftPercent100ths(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringCurrentPositionLiftPercent100thsAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringCurrentPositionLiftPercent100thsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::CurrentPositionLiftPercent100ths::Set(
            command->mEndPointId, command->currentPositionLiftPercent100ths);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentPositionLiftPercent100ths");
        }
    }
};
class SetWindowCoveringCurrentPositionTiltPercent100thsAttributeCommand : public Command
{
public:
    SetWindowCoveringCurrentPositionTiltPercent100thsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-position-tilt-percent100ths", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentPositionTiltPercent100ths,
                    "Set the Value of on CurrentPositionTiltPercent100ths.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentPositionTiltPercent100ths");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentPositionTiltPercent100ths, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::Percent100ths> currentPositionTiltPercent100ths;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentPositionTiltPercent100ths(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringCurrentPositionTiltPercent100thsAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringCurrentPositionTiltPercent100thsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::CurrentPositionTiltPercent100ths::Set(
            command->mEndPointId, command->currentPositionTiltPercent100ths);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentPositionTiltPercent100ths");
        }
    }
};
class SetWindowCoveringInstalledOpenLimitLiftAttributeCommand : public Command
{
public:
    SetWindowCoveringInstalledOpenLimitLiftAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "installed-open-limit-lift", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &installedOpenLimitLift, "Set the Value of on InstalledOpenLimitLift.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstalledOpenLimitLift");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstalledOpenLimitLift, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t installedOpenLimitLift;
    chip::EndpointId mEndPointId;

private:
    static void SetInstalledOpenLimitLift(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringInstalledOpenLimitLiftAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringInstalledOpenLimitLiftAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitLift::Set(
            command->mEndPointId, command->installedOpenLimitLift);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstalledOpenLimitLift");
        }
    }
};
class SetWindowCoveringInstalledClosedLimitLiftAttributeCommand : public Command
{
public:
    SetWindowCoveringInstalledClosedLimitLiftAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "installed-closed-limit-lift", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &installedClosedLimitLift, "Set the Value of on InstalledClosedLimitLift.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstalledClosedLimitLift");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstalledClosedLimitLift, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t installedClosedLimitLift;
    chip::EndpointId mEndPointId;

private:
    static void SetInstalledClosedLimitLift(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringInstalledClosedLimitLiftAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringInstalledClosedLimitLiftAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitLift::Set(
            command->mEndPointId, command->installedClosedLimitLift);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstalledClosedLimitLift");
        }
    }
};
class SetWindowCoveringInstalledOpenLimitTiltAttributeCommand : public Command
{
public:
    SetWindowCoveringInstalledOpenLimitTiltAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "installed-open-limit-tilt", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &installedOpenLimitTilt, "Set the Value of on InstalledOpenLimitTilt.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstalledOpenLimitTilt");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstalledOpenLimitTilt, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t installedOpenLimitTilt;
    chip::EndpointId mEndPointId;

private:
    static void SetInstalledOpenLimitTilt(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringInstalledOpenLimitTiltAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringInstalledOpenLimitTiltAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::InstalledOpenLimitTilt::Set(
            command->mEndPointId, command->installedOpenLimitTilt);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstalledOpenLimitTilt");
        }
    }
};
class SetWindowCoveringInstalledClosedLimitTiltAttributeCommand : public Command
{
public:
    SetWindowCoveringInstalledClosedLimitTiltAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "installed-closed-limit-tilt", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &installedClosedLimitTilt, "Set the Value of on InstalledClosedLimitTilt.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstalledClosedLimitTilt");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstalledClosedLimitTilt, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t installedClosedLimitTilt;
    chip::EndpointId mEndPointId;

private:
    static void SetInstalledClosedLimitTilt(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringInstalledClosedLimitTiltAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringInstalledClosedLimitTiltAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::InstalledClosedLimitTilt::Set(
            command->mEndPointId, command->installedClosedLimitTilt);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstalledClosedLimitTilt");
        }
    }
};
class SetWindowCoveringModeAttributeCommand : public Command
{
public:
    SetWindowCoveringModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &mode, "Set the Value of on Mode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Mode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::WindowCovering::Mode> mode;
    chip::EndpointId mEndPointId;

private:
    static void SetMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringModeAttributeCommand * command = reinterpret_cast<SetWindowCoveringModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::WindowCovering::Attributes::Mode::Set(command->mEndPointId, command->mode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Mode");
        }
    }
};
class SetWindowCoveringSafetyStatusAttributeCommand : public Command
{
public:
    SetWindowCoveringSafetyStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "safety-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &safetyStatus, "Set the Value of on SafetyStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SafetyStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSafetyStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus> safetyStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetSafetyStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringSafetyStatusAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringSafetyStatusAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WindowCovering::Attributes::SafetyStatus::Set(command->mEndPointId, command->safetyStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SafetyStatus");
        }
    }
};
class SetWindowCoveringFeatureMapAttributeCommand : public Command
{
public:
    SetWindowCoveringFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringFeatureMapAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WindowCovering::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetWindowCoveringClusterRevisionAttributeCommand : public Command
{
public:
    SetWindowCoveringClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWindowCoveringClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetWindowCoveringClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WindowCovering::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetBarrierControlBarrierMovingStateAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierMovingStateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-moving-state", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &barrierMovingState, "Set the Value of on BarrierMovingState.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierMovingState");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierMovingState, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t barrierMovingState;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierMovingState(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierMovingStateAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierMovingStateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierMovingState::Set(
            command->mEndPointId, command->barrierMovingState);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierMovingState");
        }
    }
};
class SetBarrierControlBarrierSafetyStatusAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierSafetyStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-safety-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &barrierSafetyStatus, "Set the Value of on BarrierSafetyStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierSafetyStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierSafetyStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t barrierSafetyStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierSafetyStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierSafetyStatusAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierSafetyStatusAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierSafetyStatus::Set(
            command->mEndPointId, command->barrierSafetyStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierSafetyStatus");
        }
    }
};
class SetBarrierControlBarrierCapabilitiesAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierCapabilitiesAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-capabilities", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &barrierCapabilities, "Set the Value of on BarrierCapabilities.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierCapabilities");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierCapabilities, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t barrierCapabilities;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierCapabilities(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierCapabilitiesAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierCapabilitiesAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierCapabilities::Set(
            command->mEndPointId, command->barrierCapabilities);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierCapabilities");
        }
    }
};
class SetBarrierControlBarrierOpenEventsAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierOpenEventsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-open-events", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &barrierOpenEvents, "Set the Value of on BarrierOpenEvents.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierOpenEvents");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierOpenEvents, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t barrierOpenEvents;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierOpenEvents(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierOpenEventsAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierOpenEventsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierOpenEvents::Set(command->mEndPointId,
                                                                                                       command->barrierOpenEvents);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierOpenEvents");
        }
    }
};
class SetBarrierControlBarrierCloseEventsAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierCloseEventsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-close-events", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &barrierCloseEvents, "Set the Value of on BarrierCloseEvents.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierCloseEvents");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierCloseEvents, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t barrierCloseEvents;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierCloseEvents(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierCloseEventsAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierCloseEventsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierCloseEvents::Set(
            command->mEndPointId, command->barrierCloseEvents);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierCloseEvents");
        }
    }
};
class SetBarrierControlBarrierCommandOpenEventsAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierCommandOpenEventsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-command-open-events", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &barrierCommandOpenEvents, "Set the Value of on BarrierCommandOpenEvents.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierCommandOpenEvents");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierCommandOpenEvents, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t barrierCommandOpenEvents;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierCommandOpenEvents(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierCommandOpenEventsAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierCommandOpenEventsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierCommandOpenEvents::Set(
            command->mEndPointId, command->barrierCommandOpenEvents);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierCommandOpenEvents");
        }
    }
};
class SetBarrierControlBarrierCommandCloseEventsAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierCommandCloseEventsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-command-close-events", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &barrierCommandCloseEvents, "Set the Value of on BarrierCommandCloseEvents.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierCommandCloseEvents");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierCommandCloseEvents, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t barrierCommandCloseEvents;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierCommandCloseEvents(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierCommandCloseEventsAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierCommandCloseEventsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierCommandCloseEvents::Set(
            command->mEndPointId, command->barrierCommandCloseEvents);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierCommandCloseEvents");
        }
    }
};
class SetBarrierControlBarrierOpenPeriodAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierOpenPeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-open-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &barrierOpenPeriod, "Set the Value of on BarrierOpenPeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierOpenPeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierOpenPeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t barrierOpenPeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierOpenPeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierOpenPeriodAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierOpenPeriodAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierOpenPeriod::Set(command->mEndPointId,
                                                                                                       command->barrierOpenPeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierOpenPeriod");
        }
    }
};
class SetBarrierControlBarrierClosePeriodAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierClosePeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-close-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &barrierClosePeriod, "Set the Value of on BarrierClosePeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierClosePeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierClosePeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t barrierClosePeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierClosePeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierClosePeriodAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierClosePeriodAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BarrierControl::Attributes::BarrierClosePeriod::Set(
            command->mEndPointId, command->barrierClosePeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierClosePeriod");
        }
    }
};
class SetBarrierControlBarrierPositionAttributeCommand : public Command
{
public:
    SetBarrierControlBarrierPositionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "barrier-position", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &barrierPosition, "Set the Value of on BarrierPosition.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BarrierPosition");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBarrierPosition, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t barrierPosition;
    chip::EndpointId mEndPointId;

private:
    static void SetBarrierPosition(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlBarrierPositionAttributeCommand * command =
            reinterpret_cast<SetBarrierControlBarrierPositionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BarrierControl::Attributes::BarrierPosition::Set(command->mEndPointId, command->barrierPosition);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BarrierPosition");
        }
    }
};
class SetBarrierControlFeatureMapAttributeCommand : public Command
{
public:
    SetBarrierControlFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlFeatureMapAttributeCommand * command =
            reinterpret_cast<SetBarrierControlFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BarrierControl::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetBarrierControlClusterRevisionAttributeCommand : public Command
{
public:
    SetBarrierControlClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBarrierControlClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetBarrierControlClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BarrierControl::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetPumpConfigurationAndControlMaxPressureAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxPressureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-pressure", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxPressure, "Set the Value of on MaxPressure.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxPressure");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxPressure, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> maxPressure;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxPressure(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxPressureAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxPressureAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxPressure::Set(command->mEndPointId,
                                                                                                              command->maxPressure);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxPressure");
        }
    }
};
class SetPumpConfigurationAndControlMaxSpeedAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxSpeedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-speed", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxSpeed, "Set the Value of on MaxSpeed.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxSpeed");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxSpeed, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> maxSpeed;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxSpeed(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxSpeedAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxSpeedAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxSpeed::Set(command->mEndPointId, command->maxSpeed);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxSpeed");
        }
    }
};
class SetPumpConfigurationAndControlMaxFlowAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxFlowAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-flow", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxFlow, "Set the Value of on MaxFlow.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxFlow");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxFlow, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> maxFlow;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxFlow(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxFlowAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxFlowAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxFlow::Set(command->mEndPointId, command->maxFlow);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxFlow");
        }
    }
};
class SetPumpConfigurationAndControlMinConstPressureAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMinConstPressureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-const-pressure", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minConstPressure, "Set the Value of on MinConstPressure.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinConstPressure");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinConstPressure, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> minConstPressure;
    chip::EndpointId mEndPointId;

private:
    static void SetMinConstPressure(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMinConstPressureAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMinConstPressureAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstPressure::Set(
            command->mEndPointId, command->minConstPressure);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinConstPressure");
        }
    }
};
class SetPumpConfigurationAndControlMaxConstPressureAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxConstPressureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-const-pressure", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxConstPressure, "Set the Value of on MaxConstPressure.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxConstPressure");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxConstPressure, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> maxConstPressure;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxConstPressure(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxConstPressureAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxConstPressureAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstPressure::Set(
            command->mEndPointId, command->maxConstPressure);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxConstPressure");
        }
    }
};
class SetPumpConfigurationAndControlMinCompPressureAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMinCompPressureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-comp-pressure", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minCompPressure, "Set the Value of on MinCompPressure.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinCompPressure");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinCompPressure, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> minCompPressure;
    chip::EndpointId mEndPointId;

private:
    static void SetMinCompPressure(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMinCompPressureAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMinCompPressureAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinCompPressure::Set(
            command->mEndPointId, command->minCompPressure);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinCompPressure");
        }
    }
};
class SetPumpConfigurationAndControlMaxCompPressureAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxCompPressureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-comp-pressure", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxCompPressure, "Set the Value of on MaxCompPressure.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxCompPressure");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxCompPressure, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> maxCompPressure;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxCompPressure(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxCompPressureAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxCompPressureAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxCompPressure::Set(
            command->mEndPointId, command->maxCompPressure);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxCompPressure");
        }
    }
};
class SetPumpConfigurationAndControlMinConstSpeedAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMinConstSpeedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-const-speed", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &minConstSpeed, "Set the Value of on MinConstSpeed.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinConstSpeed");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinConstSpeed, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> minConstSpeed;
    chip::EndpointId mEndPointId;

private:
    static void SetMinConstSpeed(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMinConstSpeedAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMinConstSpeedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstSpeed::Set(
            command->mEndPointId, command->minConstSpeed);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinConstSpeed");
        }
    }
};
class SetPumpConfigurationAndControlMaxConstSpeedAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxConstSpeedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-const-speed", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxConstSpeed, "Set the Value of on MaxConstSpeed.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxConstSpeed");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxConstSpeed, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> maxConstSpeed;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxConstSpeed(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxConstSpeedAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxConstSpeedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstSpeed::Set(
            command->mEndPointId, command->maxConstSpeed);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxConstSpeed");
        }
    }
};
class SetPumpConfigurationAndControlMinConstFlowAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMinConstFlowAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-const-flow", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &minConstFlow, "Set the Value of on MinConstFlow.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinConstFlow");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinConstFlow, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> minConstFlow;
    chip::EndpointId mEndPointId;

private:
    static void SetMinConstFlow(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMinConstFlowAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMinConstFlowAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstFlow::Set(
            command->mEndPointId, command->minConstFlow);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinConstFlow");
        }
    }
};
class SetPumpConfigurationAndControlMaxConstFlowAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxConstFlowAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-const-flow", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxConstFlow, "Set the Value of on MaxConstFlow.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxConstFlow");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxConstFlow, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> maxConstFlow;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxConstFlow(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxConstFlowAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxConstFlowAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstFlow::Set(
            command->mEndPointId, command->maxConstFlow);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxConstFlow");
        }
    }
};
class SetPumpConfigurationAndControlMinConstTempAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMinConstTempAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-const-temp", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minConstTemp, "Set the Value of on MinConstTemp.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinConstTemp");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinConstTemp, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> minConstTemp;
    chip::EndpointId mEndPointId;

private:
    static void SetMinConstTemp(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMinConstTempAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMinConstTempAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MinConstTemp::Set(
            command->mEndPointId, command->minConstTemp);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinConstTemp");
        }
    }
};
class SetPumpConfigurationAndControlMaxConstTempAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlMaxConstTempAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-const-temp", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxConstTemp, "Set the Value of on MaxConstTemp.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxConstTemp");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxConstTemp, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> maxConstTemp;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxConstTemp(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlMaxConstTempAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlMaxConstTempAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::MaxConstTemp::Set(
            command->mEndPointId, command->maxConstTemp);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxConstTemp");
        }
    }
};
class SetPumpConfigurationAndControlPumpStatusAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlPumpStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "pump-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &pumpStatus, "Set the Value of on PumpStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PumpStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPumpStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap> pumpStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetPumpStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlPumpStatusAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlPumpStatusAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::PumpStatus::Set(command->mEndPointId,
                                                                                                             command->pumpStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PumpStatus");
        }
    }
};
class SetPumpConfigurationAndControlEffectiveOperationModeAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlEffectiveOperationModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "effective-operation-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &effectiveOperationMode, "Set the Value of on EffectiveOperationMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EffectiveOperationMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEffectiveOperationMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum effectiveOperationMode;
    chip::EndpointId mEndPointId;

private:
    static void SetEffectiveOperationMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlEffectiveOperationModeAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlEffectiveOperationModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveOperationMode::Set(
            command->mEndPointId, command->effectiveOperationMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EffectiveOperationMode");
        }
    }
};
class SetPumpConfigurationAndControlEffectiveControlModeAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlEffectiveControlModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "effective-control-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &effectiveControlMode, "Set the Value of on EffectiveControlMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EffectiveControlMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEffectiveControlMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum effectiveControlMode;
    chip::EndpointId mEndPointId;

private:
    static void SetEffectiveControlMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlEffectiveControlModeAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlEffectiveControlModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::EffectiveControlMode::Set(
            command->mEndPointId, command->effectiveControlMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EffectiveControlMode");
        }
    }
};
class SetPumpConfigurationAndControlCapacityAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlCapacityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "capacity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &capacity, "Set the Value of on Capacity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Capacity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCapacity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> capacity;
    chip::EndpointId mEndPointId;

private:
    static void SetCapacity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlCapacityAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlCapacityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PumpConfigurationAndControl::Attributes::Capacity::Set(command->mEndPointId, command->capacity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Capacity");
        }
    }
};
class SetPumpConfigurationAndControlSpeedAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlSpeedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "speed", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &speed, "Set the Value of on Speed.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Speed");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSpeed, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> speed;
    chip::EndpointId mEndPointId;

private:
    static void SetSpeed(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlSpeedAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlSpeedAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PumpConfigurationAndControl::Attributes::Speed::Set(command->mEndPointId, command->speed);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Speed");
        }
    }
};
class SetPumpConfigurationAndControlLifetimeRunningHoursAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlLifetimeRunningHoursAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lifetime-running-hours", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &lifetimeRunningHours, "Set the Value of on LifetimeRunningHours.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LifetimeRunningHours");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLifetimeRunningHours, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> lifetimeRunningHours;
    chip::EndpointId mEndPointId;

private:
    static void SetLifetimeRunningHours(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlLifetimeRunningHoursAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlLifetimeRunningHoursAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeRunningHours::Set(
            command->mEndPointId, command->lifetimeRunningHours);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LifetimeRunningHours");
        }
    }
};
class SetPumpConfigurationAndControlPowerAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlPowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &power, "Set the Value of on Power.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Power");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> power;
    chip::EndpointId mEndPointId;

private:
    static void SetPower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlPowerAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlPowerAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PumpConfigurationAndControl::Attributes::Power::Set(command->mEndPointId, command->power);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Power");
        }
    }
};
class SetPumpConfigurationAndControlLifetimeEnergyConsumedAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlLifetimeEnergyConsumedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lifetime-energy-consumed", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &lifetimeEnergyConsumed, "Set the Value of on LifetimeEnergyConsumed.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LifetimeEnergyConsumed");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLifetimeEnergyConsumed, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> lifetimeEnergyConsumed;
    chip::EndpointId mEndPointId;

private:
    static void SetLifetimeEnergyConsumed(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlLifetimeEnergyConsumedAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlLifetimeEnergyConsumedAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::LifetimeEnergyConsumed::Set(
            command->mEndPointId, command->lifetimeEnergyConsumed);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LifetimeEnergyConsumed");
        }
    }
};
class SetPumpConfigurationAndControlOperationModeAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlOperationModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "operation-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &operationMode, "Set the Value of on OperationMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OperationMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOperationMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum operationMode;
    chip::EndpointId mEndPointId;

private:
    static void SetOperationMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlOperationModeAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlOperationModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::OperationMode::Set(
            command->mEndPointId, command->operationMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OperationMode");
        }
    }
};
class SetPumpConfigurationAndControlControlModeAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlControlModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "control-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &controlMode, "Set the Value of on ControlMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ControlMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetControlMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum controlMode;
    chip::EndpointId mEndPointId;

private:
    static void SetControlMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlControlModeAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlControlModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::ControlMode::Set(command->mEndPointId,
                                                                                                              command->controlMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ControlMode");
        }
    }
};
class SetPumpConfigurationAndControlFeatureMapAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlFeatureMapAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::FeatureMap::Set(command->mEndPointId,
                                                                                                             command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetPumpConfigurationAndControlClusterRevisionAttributeCommand : public Command
{
public:
    SetPumpConfigurationAndControlClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPumpConfigurationAndControlClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetPumpConfigurationAndControlClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PumpConfigurationAndControl::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetThermostatLocalTemperatureAttributeCommand : public Command
{
public:
    SetThermostatLocalTemperatureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "local-temperature", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &localTemperature, "Set the Value of on LocalTemperature.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LocalTemperature");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLocalTemperature, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> localTemperature;
    chip::EndpointId mEndPointId;

private:
    static void SetLocalTemperature(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatLocalTemperatureAttributeCommand * command =
            reinterpret_cast<SetThermostatLocalTemperatureAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::LocalTemperature::Set(command->mEndPointId, command->localTemperature);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LocalTemperature");
        }
    }
};
class SetThermostatOutdoorTemperatureAttributeCommand : public Command
{
public:
    SetThermostatOutdoorTemperatureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "outdoor-temperature", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &outdoorTemperature, "Set the Value of on OutdoorTemperature.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OutdoorTemperature");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOutdoorTemperature, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> outdoorTemperature;
    chip::EndpointId mEndPointId;

private:
    static void SetOutdoorTemperature(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatOutdoorTemperatureAttributeCommand * command =
            reinterpret_cast<SetThermostatOutdoorTemperatureAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::OutdoorTemperature::Set(command->mEndPointId, command->outdoorTemperature);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OutdoorTemperature");
        }
    }
};
class SetThermostatOccupancyAttributeCommand : public Command
{
public:
    SetThermostatOccupancyAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupancy", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &occupancy, "Set the Value of on Occupancy.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Occupancy");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupancy, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t occupancy;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupancy(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatOccupancyAttributeCommand * command = reinterpret_cast<SetThermostatOccupancyAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::Occupancy::Set(command->mEndPointId, command->occupancy);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Occupancy");
        }
    }
};
class SetThermostatAbsMinHeatSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatAbsMinHeatSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "abs-min-heat-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &absMinHeatSetpointLimit,
                    "Set the Value of on AbsMinHeatSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AbsMinHeatSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAbsMinHeatSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t absMinHeatSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetAbsMinHeatSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatAbsMinHeatSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatAbsMinHeatSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::AbsMinHeatSetpointLimit::Set(
            command->mEndPointId, command->absMinHeatSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AbsMinHeatSetpointLimit");
        }
    }
};
class SetThermostatAbsMaxHeatSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatAbsMaxHeatSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "abs-max-heat-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &absMaxHeatSetpointLimit,
                    "Set the Value of on AbsMaxHeatSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AbsMaxHeatSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAbsMaxHeatSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t absMaxHeatSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetAbsMaxHeatSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatAbsMaxHeatSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatAbsMaxHeatSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::AbsMaxHeatSetpointLimit::Set(
            command->mEndPointId, command->absMaxHeatSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AbsMaxHeatSetpointLimit");
        }
    }
};
class SetThermostatAbsMinCoolSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatAbsMinCoolSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "abs-min-cool-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &absMinCoolSetpointLimit,
                    "Set the Value of on AbsMinCoolSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AbsMinCoolSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAbsMinCoolSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t absMinCoolSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetAbsMinCoolSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatAbsMinCoolSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatAbsMinCoolSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::AbsMinCoolSetpointLimit::Set(
            command->mEndPointId, command->absMinCoolSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AbsMinCoolSetpointLimit");
        }
    }
};
class SetThermostatAbsMaxCoolSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatAbsMaxCoolSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "abs-max-cool-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &absMaxCoolSetpointLimit,
                    "Set the Value of on AbsMaxCoolSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AbsMaxCoolSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAbsMaxCoolSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t absMaxCoolSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetAbsMaxCoolSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatAbsMaxCoolSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatAbsMaxCoolSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::AbsMaxCoolSetpointLimit::Set(
            command->mEndPointId, command->absMaxCoolSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AbsMaxCoolSetpointLimit");
        }
    }
};
class SetThermostatPICoolingDemandAttributeCommand : public Command
{
public:
    SetThermostatPICoolingDemandAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "picooling-demand", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &PICoolingDemand, "Set the Value of on PICoolingDemand.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PICoolingDemand");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPICoolingDemand, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t PICoolingDemand;
    chip::EndpointId mEndPointId;

private:
    static void SetPICoolingDemand(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatPICoolingDemandAttributeCommand * command =
            reinterpret_cast<SetThermostatPICoolingDemandAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::PICoolingDemand::Set(command->mEndPointId, command->PICoolingDemand);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PICoolingDemand");
        }
    }
};
class SetThermostatPIHeatingDemandAttributeCommand : public Command
{
public:
    SetThermostatPIHeatingDemandAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "piheating-demand", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &PIHeatingDemand, "Set the Value of on PIHeatingDemand.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PIHeatingDemand");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPIHeatingDemand, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t PIHeatingDemand;
    chip::EndpointId mEndPointId;

private:
    static void SetPIHeatingDemand(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatPIHeatingDemandAttributeCommand * command =
            reinterpret_cast<SetThermostatPIHeatingDemandAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::PIHeatingDemand::Set(command->mEndPointId, command->PIHeatingDemand);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PIHeatingDemand");
        }
    }
};
class SetThermostatHVACSystemTypeConfigurationAttributeCommand : public Command
{
public:
    SetThermostatHVACSystemTypeConfigurationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "hvacsystem-type-configuration", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &HVACSystemTypeConfiguration,
                    "Set the Value of on HVACSystemTypeConfiguration.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: HVACSystemTypeConfiguration");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetHVACSystemTypeConfiguration, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t HVACSystemTypeConfiguration;
    chip::EndpointId mEndPointId;

private:
    static void SetHVACSystemTypeConfiguration(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatHVACSystemTypeConfigurationAttributeCommand * command =
            reinterpret_cast<SetThermostatHVACSystemTypeConfigurationAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::HVACSystemTypeConfiguration::Set(
            command->mEndPointId, command->HVACSystemTypeConfiguration);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute HVACSystemTypeConfiguration");
        }
    }
};
class SetThermostatLocalTemperatureCalibrationAttributeCommand : public Command
{
public:
    SetThermostatLocalTemperatureCalibrationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "local-temperature-calibration", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &localTemperatureCalibration,
                    "Set the Value of on LocalTemperatureCalibration.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LocalTemperatureCalibration");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLocalTemperatureCalibration, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t localTemperatureCalibration;
    chip::EndpointId mEndPointId;

private:
    static void SetLocalTemperatureCalibration(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatLocalTemperatureCalibrationAttributeCommand * command =
            reinterpret_cast<SetThermostatLocalTemperatureCalibrationAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::LocalTemperatureCalibration::Set(
            command->mEndPointId, command->localTemperatureCalibration);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LocalTemperatureCalibration");
        }
    }
};
class SetThermostatOccupiedCoolingSetpointAttributeCommand : public Command
{
public:
    SetThermostatOccupiedCoolingSetpointAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupied-cooling-setpoint", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &occupiedCoolingSetpoint,
                    "Set the Value of on OccupiedCoolingSetpoint.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OccupiedCoolingSetpoint");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupiedCoolingSetpoint, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t occupiedCoolingSetpoint;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupiedCoolingSetpoint(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatOccupiedCoolingSetpointAttributeCommand * command =
            reinterpret_cast<SetThermostatOccupiedCoolingSetpointAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::OccupiedCoolingSetpoint::Set(
            command->mEndPointId, command->occupiedCoolingSetpoint);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OccupiedCoolingSetpoint");
        }
    }
};
class SetThermostatOccupiedHeatingSetpointAttributeCommand : public Command
{
public:
    SetThermostatOccupiedHeatingSetpointAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupied-heating-setpoint", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &occupiedHeatingSetpoint,
                    "Set the Value of on OccupiedHeatingSetpoint.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OccupiedHeatingSetpoint");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupiedHeatingSetpoint, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t occupiedHeatingSetpoint;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupiedHeatingSetpoint(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatOccupiedHeatingSetpointAttributeCommand * command =
            reinterpret_cast<SetThermostatOccupiedHeatingSetpointAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::OccupiedHeatingSetpoint::Set(
            command->mEndPointId, command->occupiedHeatingSetpoint);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OccupiedHeatingSetpoint");
        }
    }
};
class SetThermostatUnoccupiedCoolingSetpointAttributeCommand : public Command
{
public:
    SetThermostatUnoccupiedCoolingSetpointAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unoccupied-cooling-setpoint", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &unoccupiedCoolingSetpoint,
                    "Set the Value of on UnoccupiedCoolingSetpoint.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UnoccupiedCoolingSetpoint");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUnoccupiedCoolingSetpoint, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t unoccupiedCoolingSetpoint;
    chip::EndpointId mEndPointId;

private:
    static void SetUnoccupiedCoolingSetpoint(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUnoccupiedCoolingSetpointAttributeCommand * command =
            reinterpret_cast<SetThermostatUnoccupiedCoolingSetpointAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::UnoccupiedCoolingSetpoint::Set(
            command->mEndPointId, command->unoccupiedCoolingSetpoint);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UnoccupiedCoolingSetpoint");
        }
    }
};
class SetThermostatUnoccupiedHeatingSetpointAttributeCommand : public Command
{
public:
    SetThermostatUnoccupiedHeatingSetpointAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unoccupied-heating-setpoint", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &unoccupiedHeatingSetpoint,
                    "Set the Value of on UnoccupiedHeatingSetpoint.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UnoccupiedHeatingSetpoint");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUnoccupiedHeatingSetpoint, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t unoccupiedHeatingSetpoint;
    chip::EndpointId mEndPointId;

private:
    static void SetUnoccupiedHeatingSetpoint(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUnoccupiedHeatingSetpointAttributeCommand * command =
            reinterpret_cast<SetThermostatUnoccupiedHeatingSetpointAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::UnoccupiedHeatingSetpoint::Set(
            command->mEndPointId, command->unoccupiedHeatingSetpoint);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UnoccupiedHeatingSetpoint");
        }
    }
};
class SetThermostatMinHeatSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatMinHeatSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-heat-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minHeatSetpointLimit, "Set the Value of on MinHeatSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinHeatSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinHeatSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t minHeatSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetMinHeatSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatMinHeatSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatMinHeatSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::MinHeatSetpointLimit::Set(
            command->mEndPointId, command->minHeatSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinHeatSetpointLimit");
        }
    }
};
class SetThermostatMaxHeatSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatMaxHeatSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-heat-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxHeatSetpointLimit, "Set the Value of on MaxHeatSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxHeatSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxHeatSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t maxHeatSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxHeatSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatMaxHeatSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatMaxHeatSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::MaxHeatSetpointLimit::Set(
            command->mEndPointId, command->maxHeatSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxHeatSetpointLimit");
        }
    }
};
class SetThermostatMinCoolSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatMinCoolSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-cool-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minCoolSetpointLimit, "Set the Value of on MinCoolSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinCoolSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinCoolSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t minCoolSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetMinCoolSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatMinCoolSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatMinCoolSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::MinCoolSetpointLimit::Set(
            command->mEndPointId, command->minCoolSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinCoolSetpointLimit");
        }
    }
};
class SetThermostatMaxCoolSetpointLimitAttributeCommand : public Command
{
public:
    SetThermostatMaxCoolSetpointLimitAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-cool-setpoint-limit", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxCoolSetpointLimit, "Set the Value of on MaxCoolSetpointLimit.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxCoolSetpointLimit");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxCoolSetpointLimit, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t maxCoolSetpointLimit;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxCoolSetpointLimit(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatMaxCoolSetpointLimitAttributeCommand * command =
            reinterpret_cast<SetThermostatMaxCoolSetpointLimitAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::MaxCoolSetpointLimit::Set(
            command->mEndPointId, command->maxCoolSetpointLimit);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxCoolSetpointLimit");
        }
    }
};
class SetThermostatMinSetpointDeadBandAttributeCommand : public Command
{
public:
    SetThermostatMinSetpointDeadBandAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-setpoint-dead-band", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &minSetpointDeadBand, "Set the Value of on MinSetpointDeadBand.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinSetpointDeadBand");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinSetpointDeadBand, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t minSetpointDeadBand;
    chip::EndpointId mEndPointId;

private:
    static void SetMinSetpointDeadBand(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatMinSetpointDeadBandAttributeCommand * command =
            reinterpret_cast<SetThermostatMinSetpointDeadBandAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::MinSetpointDeadBand::Set(command->mEndPointId,
                                                                                                     command->minSetpointDeadBand);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinSetpointDeadBand");
        }
    }
};
class SetThermostatRemoteSensingAttributeCommand : public Command
{
public:
    SetThermostatRemoteSensingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "remote-sensing", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &remoteSensing, "Set the Value of on RemoteSensing.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RemoteSensing");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRemoteSensing, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t remoteSensing;
    chip::EndpointId mEndPointId;

private:
    static void SetRemoteSensing(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatRemoteSensingAttributeCommand * command =
            reinterpret_cast<SetThermostatRemoteSensingAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::RemoteSensing::Set(command->mEndPointId, command->remoteSensing);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RemoteSensing");
        }
    }
};
class SetThermostatControlSequenceOfOperationAttributeCommand : public Command
{
public:
    SetThermostatControlSequenceOfOperationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "control-sequence-of-operation", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &controlSequenceOfOperation, "Set the Value of on ControlSequenceOfOperation.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ControlSequenceOfOperation");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetControlSequenceOfOperation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::Thermostat::ThermostatControlSequence controlSequenceOfOperation;
    chip::EndpointId mEndPointId;

private:
    static void SetControlSequenceOfOperation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatControlSequenceOfOperationAttributeCommand * command =
            reinterpret_cast<SetThermostatControlSequenceOfOperationAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::ControlSequenceOfOperation::Set(
            command->mEndPointId, command->controlSequenceOfOperation);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ControlSequenceOfOperation");
        }
    }
};
class SetThermostatSystemModeAttributeCommand : public Command
{
public:
    SetThermostatSystemModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "system-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &systemMode, "Set the Value of on SystemMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SystemMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSystemMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t systemMode;
    chip::EndpointId mEndPointId;

private:
    static void SetSystemMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatSystemModeAttributeCommand * command = reinterpret_cast<SetThermostatSystemModeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::SystemMode::Set(command->mEndPointId, command->systemMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SystemMode");
        }
    }
};
class SetThermostatThermostatRunningModeAttributeCommand : public Command
{
public:
    SetThermostatThermostatRunningModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "thermostat-running-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &thermostatRunningMode, "Set the Value of on ThermostatRunningMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ThermostatRunningMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetThermostatRunningMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t thermostatRunningMode;
    chip::EndpointId mEndPointId;

private:
    static void SetThermostatRunningMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatThermostatRunningModeAttributeCommand * command =
            reinterpret_cast<SetThermostatThermostatRunningModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::ThermostatRunningMode::Set(
            command->mEndPointId, command->thermostatRunningMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ThermostatRunningMode");
        }
    }
};
class SetThermostatStartOfWeekAttributeCommand : public Command
{
public:
    SetThermostatStartOfWeekAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "start-of-week", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &startOfWeek, "Set the Value of on StartOfWeek.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StartOfWeek");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStartOfWeek, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t startOfWeek;
    chip::EndpointId mEndPointId;

private:
    static void SetStartOfWeek(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatStartOfWeekAttributeCommand * command = reinterpret_cast<SetThermostatStartOfWeekAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::StartOfWeek::Set(command->mEndPointId, command->startOfWeek);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StartOfWeek");
        }
    }
};
class SetThermostatNumberOfWeeklyTransitionsAttributeCommand : public Command
{
public:
    SetThermostatNumberOfWeeklyTransitionsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-weekly-transitions", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfWeeklyTransitions, "Set the Value of on NumberOfWeeklyTransitions.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfWeeklyTransitions");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfWeeklyTransitions, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t numberOfWeeklyTransitions;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfWeeklyTransitions(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatNumberOfWeeklyTransitionsAttributeCommand * command =
            reinterpret_cast<SetThermostatNumberOfWeeklyTransitionsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::NumberOfWeeklyTransitions::Set(
            command->mEndPointId, command->numberOfWeeklyTransitions);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfWeeklyTransitions");
        }
    }
};
class SetThermostatNumberOfDailyTransitionsAttributeCommand : public Command
{
public:
    SetThermostatNumberOfDailyTransitionsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-daily-transitions", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfDailyTransitions, "Set the Value of on NumberOfDailyTransitions.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfDailyTransitions");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfDailyTransitions, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t numberOfDailyTransitions;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfDailyTransitions(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatNumberOfDailyTransitionsAttributeCommand * command =
            reinterpret_cast<SetThermostatNumberOfDailyTransitionsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::NumberOfDailyTransitions::Set(
            command->mEndPointId, command->numberOfDailyTransitions);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfDailyTransitions");
        }
    }
};
class SetThermostatTemperatureSetpointHoldAttributeCommand : public Command
{
public:
    SetThermostatTemperatureSetpointHoldAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "temperature-setpoint-hold", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &temperatureSetpointHold, "Set the Value of on TemperatureSetpointHold.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TemperatureSetpointHold");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTemperatureSetpointHold, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t temperatureSetpointHold;
    chip::EndpointId mEndPointId;

private:
    static void SetTemperatureSetpointHold(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatTemperatureSetpointHoldAttributeCommand * command =
            reinterpret_cast<SetThermostatTemperatureSetpointHoldAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::TemperatureSetpointHold::Set(
            command->mEndPointId, command->temperatureSetpointHold);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TemperatureSetpointHold");
        }
    }
};
class SetThermostatTemperatureSetpointHoldDurationAttributeCommand : public Command
{
public:
    SetThermostatTemperatureSetpointHoldDurationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "temperature-setpoint-hold-duration", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &temperatureSetpointHoldDuration,
                    "Set the Value of on TemperatureSetpointHoldDuration.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TemperatureSetpointHoldDuration");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTemperatureSetpointHoldDuration, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> temperatureSetpointHoldDuration;
    chip::EndpointId mEndPointId;

private:
    static void SetTemperatureSetpointHoldDuration(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatTemperatureSetpointHoldDurationAttributeCommand * command =
            reinterpret_cast<SetThermostatTemperatureSetpointHoldDurationAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::TemperatureSetpointHoldDuration::Set(
            command->mEndPointId, command->temperatureSetpointHoldDuration);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TemperatureSetpointHoldDuration");
        }
    }
};
class SetThermostatThermostatProgrammingOperationModeAttributeCommand : public Command
{
public:
    SetThermostatThermostatProgrammingOperationModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "thermostat-programming-operation-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &thermostatProgrammingOperationMode,
                    "Set the Value of on ThermostatProgrammingOperationMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ThermostatProgrammingOperationMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetThermostatProgrammingOperationMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t thermostatProgrammingOperationMode;
    chip::EndpointId mEndPointId;

private:
    static void SetThermostatProgrammingOperationMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatThermostatProgrammingOperationModeAttributeCommand * command =
            reinterpret_cast<SetThermostatThermostatProgrammingOperationModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::ThermostatProgrammingOperationMode::Set(
            command->mEndPointId, command->thermostatProgrammingOperationMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ThermostatProgrammingOperationMode");
        }
    }
};
class SetThermostatThermostatRunningStateAttributeCommand : public Command
{
public:
    SetThermostatThermostatRunningStateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "thermostat-running-state", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &thermostatRunningState, "Set the Value of on ThermostatRunningState.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ThermostatRunningState");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetThermostatRunningState, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t thermostatRunningState;
    chip::EndpointId mEndPointId;

private:
    static void SetThermostatRunningState(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatThermostatRunningStateAttributeCommand * command =
            reinterpret_cast<SetThermostatThermostatRunningStateAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::ThermostatRunningState::Set(
            command->mEndPointId, command->thermostatRunningState);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ThermostatRunningState");
        }
    }
};
class SetThermostatSetpointChangeSourceAttributeCommand : public Command
{
public:
    SetThermostatSetpointChangeSourceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "setpoint-change-source", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &setpointChangeSource, "Set the Value of on SetpointChangeSource.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SetpointChangeSource");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSetpointChangeSource, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t setpointChangeSource;
    chip::EndpointId mEndPointId;

private:
    static void SetSetpointChangeSource(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatSetpointChangeSourceAttributeCommand * command =
            reinterpret_cast<SetThermostatSetpointChangeSourceAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::SetpointChangeSource::Set(
            command->mEndPointId, command->setpointChangeSource);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SetpointChangeSource");
        }
    }
};
class SetThermostatSetpointChangeAmountAttributeCommand : public Command
{
public:
    SetThermostatSetpointChangeAmountAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "setpoint-change-amount", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &setpointChangeAmount, "Set the Value of on SetpointChangeAmount.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SetpointChangeAmount");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSetpointChangeAmount, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> setpointChangeAmount;
    chip::EndpointId mEndPointId;

private:
    static void SetSetpointChangeAmount(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatSetpointChangeAmountAttributeCommand * command =
            reinterpret_cast<SetThermostatSetpointChangeAmountAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::SetpointChangeAmount::Set(
            command->mEndPointId, command->setpointChangeAmount);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SetpointChangeAmount");
        }
    }
};
class SetThermostatSetpointChangeSourceTimestampAttributeCommand : public Command
{
public:
    SetThermostatSetpointChangeSourceTimestampAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "setpoint-change-source-timestamp", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &setpointChangeSourceTimestamp,
                    "Set the Value of on SetpointChangeSourceTimestamp.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SetpointChangeSourceTimestamp");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSetpointChangeSourceTimestamp, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t setpointChangeSourceTimestamp;
    chip::EndpointId mEndPointId;

private:
    static void SetSetpointChangeSourceTimestamp(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatSetpointChangeSourceTimestampAttributeCommand * command =
            reinterpret_cast<SetThermostatSetpointChangeSourceTimestampAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::SetpointChangeSourceTimestamp::Set(
            command->mEndPointId, command->setpointChangeSourceTimestamp);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SetpointChangeSourceTimestamp");
        }
    }
};
class SetThermostatOccupiedSetbackAttributeCommand : public Command
{
public:
    SetThermostatOccupiedSetbackAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupied-setback", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &occupiedSetback, "Set the Value of on OccupiedSetback.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OccupiedSetback");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupiedSetback, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> occupiedSetback;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupiedSetback(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatOccupiedSetbackAttributeCommand * command =
            reinterpret_cast<SetThermostatOccupiedSetbackAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::OccupiedSetback::Set(command->mEndPointId, command->occupiedSetback);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OccupiedSetback");
        }
    }
};
class SetThermostatOccupiedSetbackMinAttributeCommand : public Command
{
public:
    SetThermostatOccupiedSetbackMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupied-setback-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &occupiedSetbackMin, "Set the Value of on OccupiedSetbackMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OccupiedSetbackMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupiedSetbackMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> occupiedSetbackMin;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupiedSetbackMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatOccupiedSetbackMinAttributeCommand * command =
            reinterpret_cast<SetThermostatOccupiedSetbackMinAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::OccupiedSetbackMin::Set(command->mEndPointId, command->occupiedSetbackMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OccupiedSetbackMin");
        }
    }
};
class SetThermostatOccupiedSetbackMaxAttributeCommand : public Command
{
public:
    SetThermostatOccupiedSetbackMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupied-setback-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &occupiedSetbackMax, "Set the Value of on OccupiedSetbackMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OccupiedSetbackMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupiedSetbackMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> occupiedSetbackMax;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupiedSetbackMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatOccupiedSetbackMaxAttributeCommand * command =
            reinterpret_cast<SetThermostatOccupiedSetbackMaxAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::OccupiedSetbackMax::Set(command->mEndPointId, command->occupiedSetbackMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OccupiedSetbackMax");
        }
    }
};
class SetThermostatUnoccupiedSetbackAttributeCommand : public Command
{
public:
    SetThermostatUnoccupiedSetbackAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unoccupied-setback", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &unoccupiedSetback, "Set the Value of on UnoccupiedSetback.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UnoccupiedSetback");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUnoccupiedSetback, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> unoccupiedSetback;
    chip::EndpointId mEndPointId;

private:
    static void SetUnoccupiedSetback(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUnoccupiedSetbackAttributeCommand * command =
            reinterpret_cast<SetThermostatUnoccupiedSetbackAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::UnoccupiedSetback::Set(command->mEndPointId, command->unoccupiedSetback);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UnoccupiedSetback");
        }
    }
};
class SetThermostatUnoccupiedSetbackMinAttributeCommand : public Command
{
public:
    SetThermostatUnoccupiedSetbackMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unoccupied-setback-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &unoccupiedSetbackMin, "Set the Value of on UnoccupiedSetbackMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UnoccupiedSetbackMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUnoccupiedSetbackMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> unoccupiedSetbackMin;
    chip::EndpointId mEndPointId;

private:
    static void SetUnoccupiedSetbackMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUnoccupiedSetbackMinAttributeCommand * command =
            reinterpret_cast<SetThermostatUnoccupiedSetbackMinAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::UnoccupiedSetbackMin::Set(
            command->mEndPointId, command->unoccupiedSetbackMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UnoccupiedSetbackMin");
        }
    }
};
class SetThermostatUnoccupiedSetbackMaxAttributeCommand : public Command
{
public:
    SetThermostatUnoccupiedSetbackMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unoccupied-setback-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &unoccupiedSetbackMax, "Set the Value of on UnoccupiedSetbackMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UnoccupiedSetbackMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUnoccupiedSetbackMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> unoccupiedSetbackMax;
    chip::EndpointId mEndPointId;

private:
    static void SetUnoccupiedSetbackMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUnoccupiedSetbackMaxAttributeCommand * command =
            reinterpret_cast<SetThermostatUnoccupiedSetbackMaxAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::UnoccupiedSetbackMax::Set(
            command->mEndPointId, command->unoccupiedSetbackMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UnoccupiedSetbackMax");
        }
    }
};
class SetThermostatEmergencyHeatDeltaAttributeCommand : public Command
{
public:
    SetThermostatEmergencyHeatDeltaAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "emergency-heat-delta", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &emergencyHeatDelta, "Set the Value of on EmergencyHeatDelta.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EmergencyHeatDelta");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEmergencyHeatDelta, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t emergencyHeatDelta;
    chip::EndpointId mEndPointId;

private:
    static void SetEmergencyHeatDelta(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatEmergencyHeatDeltaAttributeCommand * command =
            reinterpret_cast<SetThermostatEmergencyHeatDeltaAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::EmergencyHeatDelta::Set(command->mEndPointId, command->emergencyHeatDelta);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EmergencyHeatDelta");
        }
    }
};
class SetThermostatACTypeAttributeCommand : public Command
{
public:
    SetThermostatACTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "actype", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ACType, "Set the Value of on ACType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t ACType;
    chip::EndpointId mEndPointId;

private:
    static void SetACType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACTypeAttributeCommand * command = reinterpret_cast<SetThermostatACTypeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Thermostat::Attributes::ACType::Set(command->mEndPointId, command->ACType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACType");
        }
    }
};
class SetThermostatACCapacityAttributeCommand : public Command
{
public:
    SetThermostatACCapacityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "accapacity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &ACCapacity, "Set the Value of on ACCapacity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACCapacity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACCapacity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t ACCapacity;
    chip::EndpointId mEndPointId;

private:
    static void SetACCapacity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACCapacityAttributeCommand * command = reinterpret_cast<SetThermostatACCapacityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ACCapacity::Set(command->mEndPointId, command->ACCapacity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACCapacity");
        }
    }
};
class SetThermostatACRefrigerantTypeAttributeCommand : public Command
{
public:
    SetThermostatACRefrigerantTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "acrefrigerant-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ACRefrigerantType, "Set the Value of on ACRefrigerantType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACRefrigerantType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACRefrigerantType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t ACRefrigerantType;
    chip::EndpointId mEndPointId;

private:
    static void SetACRefrigerantType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACRefrigerantTypeAttributeCommand * command =
            reinterpret_cast<SetThermostatACRefrigerantTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ACRefrigerantType::Set(command->mEndPointId, command->ACRefrigerantType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACRefrigerantType");
        }
    }
};
class SetThermostatACCompressorTypeAttributeCommand : public Command
{
public:
    SetThermostatACCompressorTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "accompressor-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ACCompressorType, "Set the Value of on ACCompressorType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACCompressorType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACCompressorType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t ACCompressorType;
    chip::EndpointId mEndPointId;

private:
    static void SetACCompressorType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACCompressorTypeAttributeCommand * command =
            reinterpret_cast<SetThermostatACCompressorTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ACCompressorType::Set(command->mEndPointId, command->ACCompressorType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACCompressorType");
        }
    }
};
class SetThermostatACErrorCodeAttributeCommand : public Command
{
public:
    SetThermostatACErrorCodeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "acerror-code", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &ACErrorCode, "Set the Value of on ACErrorCode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACErrorCode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACErrorCode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t ACErrorCode;
    chip::EndpointId mEndPointId;

private:
    static void SetACErrorCode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACErrorCodeAttributeCommand * command = reinterpret_cast<SetThermostatACErrorCodeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ACErrorCode::Set(command->mEndPointId, command->ACErrorCode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACErrorCode");
        }
    }
};
class SetThermostatACLouverPositionAttributeCommand : public Command
{
public:
    SetThermostatACLouverPositionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "aclouver-position", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ACLouverPosition, "Set the Value of on ACLouverPosition.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACLouverPosition");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACLouverPosition, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t ACLouverPosition;
    chip::EndpointId mEndPointId;

private:
    static void SetACLouverPosition(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACLouverPositionAttributeCommand * command =
            reinterpret_cast<SetThermostatACLouverPositionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ACLouverPosition::Set(command->mEndPointId, command->ACLouverPosition);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACLouverPosition");
        }
    }
};
class SetThermostatACCoilTemperatureAttributeCommand : public Command
{
public:
    SetThermostatACCoilTemperatureAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "accoil-temperature", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &ACCoilTemperature, "Set the Value of on ACCoilTemperature.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACCoilTemperature");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACCoilTemperature, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> ACCoilTemperature;
    chip::EndpointId mEndPointId;

private:
    static void SetACCoilTemperature(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACCoilTemperatureAttributeCommand * command =
            reinterpret_cast<SetThermostatACCoilTemperatureAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ACCoilTemperature::Set(command->mEndPointId, command->ACCoilTemperature);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACCoilTemperature");
        }
    }
};
class SetThermostatACCapacityformatAttributeCommand : public Command
{
public:
    SetThermostatACCapacityformatAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "accapacityformat", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ACCapacityformat, "Set the Value of on ACCapacityformat.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ACCapacityformat");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetACCapacityformat, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t ACCapacityformat;
    chip::EndpointId mEndPointId;

private:
    static void SetACCapacityformat(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatACCapacityformatAttributeCommand * command =
            reinterpret_cast<SetThermostatACCapacityformatAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ACCapacityformat::Set(command->mEndPointId, command->ACCapacityformat);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ACCapacityformat");
        }
    }
};
class SetThermostatFeatureMapAttributeCommand : public Command
{
public:
    SetThermostatFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatFeatureMapAttributeCommand * command = reinterpret_cast<SetThermostatFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetThermostatClusterRevisionAttributeCommand : public Command
{
public:
    SetThermostatClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetThermostatClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Thermostat::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetFanControlFanModeAttributeCommand : public Command
{
public:
    SetFanControlFanModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "fan-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &fanMode, "Set the Value of on FanMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FanMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFanMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::FanControl::FanModeType fanMode;
    chip::EndpointId mEndPointId;

private:
    static void SetFanMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlFanModeAttributeCommand * command = reinterpret_cast<SetFanControlFanModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::FanControl::Attributes::FanMode::Set(command->mEndPointId, command->fanMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FanMode");
        }
    }
};
class SetFanControlFanModeSequenceAttributeCommand : public Command
{
public:
    SetFanControlFanModeSequenceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "fan-mode-sequence", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &fanModeSequence, "Set the Value of on FanModeSequence.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FanModeSequence");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFanModeSequence, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::FanControl::FanModeSequenceType fanModeSequence;
    chip::EndpointId mEndPointId;

private:
    static void SetFanModeSequence(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlFanModeSequenceAttributeCommand * command =
            reinterpret_cast<SetFanControlFanModeSequenceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::FanModeSequence::Set(command->mEndPointId, command->fanModeSequence);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FanModeSequence");
        }
    }
};
class SetFanControlPercentSettingAttributeCommand : public Command
{
public:
    SetFanControlPercentSettingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "percent-setting", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &percentSetting, "Set the Value of on PercentSetting.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PercentSetting");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPercentSetting, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> percentSetting;
    chip::EndpointId mEndPointId;

private:
    static void SetPercentSetting(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlPercentSettingAttributeCommand * command =
            reinterpret_cast<SetFanControlPercentSettingAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::PercentSetting::Set(command->mEndPointId, command->percentSetting);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PercentSetting");
        }
    }
};
class SetFanControlPercentCurrentAttributeCommand : public Command
{
public:
    SetFanControlPercentCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "percent-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &percentCurrent, "Set the Value of on PercentCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PercentCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPercentCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t percentCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetPercentCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlPercentCurrentAttributeCommand * command =
            reinterpret_cast<SetFanControlPercentCurrentAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::PercentCurrent::Set(command->mEndPointId, command->percentCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PercentCurrent");
        }
    }
};
class SetFanControlSpeedMaxAttributeCommand : public Command
{
public:
    SetFanControlSpeedMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "speed-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &speedMax, "Set the Value of on SpeedMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SpeedMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSpeedMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t speedMax;
    chip::EndpointId mEndPointId;

private:
    static void SetSpeedMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlSpeedMaxAttributeCommand * command = reinterpret_cast<SetFanControlSpeedMaxAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::FanControl::Attributes::SpeedMax::Set(command->mEndPointId, command->speedMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SpeedMax");
        }
    }
};
class SetFanControlSpeedSettingAttributeCommand : public Command
{
public:
    SetFanControlSpeedSettingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "speed-setting", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &speedSetting, "Set the Value of on SpeedSetting.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SpeedSetting");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSpeedSetting, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> speedSetting;
    chip::EndpointId mEndPointId;

private:
    static void SetSpeedSetting(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlSpeedSettingAttributeCommand * command =
            reinterpret_cast<SetFanControlSpeedSettingAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::SpeedSetting::Set(command->mEndPointId, command->speedSetting);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SpeedSetting");
        }
    }
};
class SetFanControlSpeedCurrentAttributeCommand : public Command
{
public:
    SetFanControlSpeedCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "speed-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &speedCurrent, "Set the Value of on SpeedCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SpeedCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSpeedCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t speedCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetSpeedCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlSpeedCurrentAttributeCommand * command =
            reinterpret_cast<SetFanControlSpeedCurrentAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::SpeedCurrent::Set(command->mEndPointId, command->speedCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SpeedCurrent");
        }
    }
};
class SetFanControlRockSupportAttributeCommand : public Command
{
public:
    SetFanControlRockSupportAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rock-support", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &rockSupport, "Set the Value of on RockSupport.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RockSupport");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRockSupport, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t rockSupport;
    chip::EndpointId mEndPointId;

private:
    static void SetRockSupport(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlRockSupportAttributeCommand * command = reinterpret_cast<SetFanControlRockSupportAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::RockSupport::Set(command->mEndPointId, command->rockSupport);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RockSupport");
        }
    }
};
class SetFanControlRockSettingAttributeCommand : public Command
{
public:
    SetFanControlRockSettingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rock-setting", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &rockSetting, "Set the Value of on RockSetting.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RockSetting");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRockSetting, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t rockSetting;
    chip::EndpointId mEndPointId;

private:
    static void SetRockSetting(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlRockSettingAttributeCommand * command = reinterpret_cast<SetFanControlRockSettingAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::RockSetting::Set(command->mEndPointId, command->rockSetting);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RockSetting");
        }
    }
};
class SetFanControlWindSupportAttributeCommand : public Command
{
public:
    SetFanControlWindSupportAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wind-support", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &windSupport, "Set the Value of on WindSupport.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WindSupport");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWindSupport, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t windSupport;
    chip::EndpointId mEndPointId;

private:
    static void SetWindSupport(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlWindSupportAttributeCommand * command = reinterpret_cast<SetFanControlWindSupportAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::WindSupport::Set(command->mEndPointId, command->windSupport);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WindSupport");
        }
    }
};
class SetFanControlWindSettingAttributeCommand : public Command
{
public:
    SetFanControlWindSettingAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "wind-setting", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &windSetting, "Set the Value of on WindSetting.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WindSetting");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWindSetting, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t windSetting;
    chip::EndpointId mEndPointId;

private:
    static void SetWindSetting(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlWindSettingAttributeCommand * command = reinterpret_cast<SetFanControlWindSettingAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::WindSetting::Set(command->mEndPointId, command->windSetting);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WindSetting");
        }
    }
};
class SetFanControlFeatureMapAttributeCommand : public Command
{
public:
    SetFanControlFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlFeatureMapAttributeCommand * command = reinterpret_cast<SetFanControlFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetFanControlClusterRevisionAttributeCommand : public Command
{
public:
    SetFanControlClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFanControlClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetFanControlClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FanControl::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetThermostatUserInterfaceConfigurationTemperatureDisplayModeAttributeCommand : public Command
{
public:
    SetThermostatUserInterfaceConfigurationTemperatureDisplayModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "temperature-display-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &temperatureDisplayMode, "Set the Value of on TemperatureDisplayMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TemperatureDisplayMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTemperatureDisplayMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t temperatureDisplayMode;
    chip::EndpointId mEndPointId;

private:
    static void SetTemperatureDisplayMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUserInterfaceConfigurationTemperatureDisplayModeAttributeCommand * command =
            reinterpret_cast<SetThermostatUserInterfaceConfigurationTemperatureDisplayModeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::TemperatureDisplayMode::Set(
            command->mEndPointId, command->temperatureDisplayMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TemperatureDisplayMode");
        }
    }
};
class SetThermostatUserInterfaceConfigurationKeypadLockoutAttributeCommand : public Command
{
public:
    SetThermostatUserInterfaceConfigurationKeypadLockoutAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "keypad-lockout", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &keypadLockout, "Set the Value of on KeypadLockout.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: KeypadLockout");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetKeypadLockout, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t keypadLockout;
    chip::EndpointId mEndPointId;

private:
    static void SetKeypadLockout(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUserInterfaceConfigurationKeypadLockoutAttributeCommand * command =
            reinterpret_cast<SetThermostatUserInterfaceConfigurationKeypadLockoutAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::KeypadLockout::Set(
            command->mEndPointId, command->keypadLockout);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute KeypadLockout");
        }
    }
};
class SetThermostatUserInterfaceConfigurationScheduleProgrammingVisibilityAttributeCommand : public Command
{
public:
    SetThermostatUserInterfaceConfigurationScheduleProgrammingVisibilityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "schedule-programming-visibility", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &scheduleProgrammingVisibility,
                    "Set the Value of on ScheduleProgrammingVisibility.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ScheduleProgrammingVisibility");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetScheduleProgrammingVisibility, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t scheduleProgrammingVisibility;
    chip::EndpointId mEndPointId;

private:
    static void SetScheduleProgrammingVisibility(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUserInterfaceConfigurationScheduleProgrammingVisibilityAttributeCommand * command =
            reinterpret_cast<SetThermostatUserInterfaceConfigurationScheduleProgrammingVisibilityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ScheduleProgrammingVisibility::Set(
                command->mEndPointId, command->scheduleProgrammingVisibility);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ScheduleProgrammingVisibility");
        }
    }
};
class SetThermostatUserInterfaceConfigurationFeatureMapAttributeCommand : public Command
{
public:
    SetThermostatUserInterfaceConfigurationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUserInterfaceConfigurationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetThermostatUserInterfaceConfigurationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::FeatureMap::Set(
            command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetThermostatUserInterfaceConfigurationClusterRevisionAttributeCommand : public Command
{
public:
    SetThermostatUserInterfaceConfigurationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetThermostatUserInterfaceConfigurationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetThermostatUserInterfaceConfigurationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ThermostatUserInterfaceConfiguration::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetColorControlCurrentHueAttributeCommand : public Command
{
public:
    SetColorControlCurrentHueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-hue", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentHue, "Set the Value of on CurrentHue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentHue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentHue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentHue;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentHue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlCurrentHueAttributeCommand * command =
            reinterpret_cast<SetColorControlCurrentHueAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::CurrentHue::Set(command->mEndPointId, command->currentHue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentHue");
        }
    }
};
class SetColorControlCurrentSaturationAttributeCommand : public Command
{
public:
    SetColorControlCurrentSaturationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-saturation", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentSaturation, "Set the Value of on CurrentSaturation.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentSaturation");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentSaturation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentSaturation;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentSaturation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlCurrentSaturationAttributeCommand * command =
            reinterpret_cast<SetColorControlCurrentSaturationAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::CurrentSaturation::Set(command->mEndPointId, command->currentSaturation);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentSaturation");
        }
    }
};
class SetColorControlRemainingTimeAttributeCommand : public Command
{
public:
    SetColorControlRemainingTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "remaining-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &remainingTime, "Set the Value of on RemainingTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RemainingTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRemainingTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t remainingTime;
    chip::EndpointId mEndPointId;

private:
    static void SetRemainingTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlRemainingTimeAttributeCommand * command =
            reinterpret_cast<SetColorControlRemainingTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::RemainingTime::Set(command->mEndPointId, command->remainingTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RemainingTime");
        }
    }
};
class SetColorControlCurrentXAttributeCommand : public Command
{
public:
    SetColorControlCurrentXAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentX, "Set the Value of on CurrentX.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentX");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentX, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t currentX;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentX(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlCurrentXAttributeCommand * command = reinterpret_cast<SetColorControlCurrentXAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::CurrentX::Set(command->mEndPointId, command->currentX);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentX");
        }
    }
};
class SetColorControlCurrentYAttributeCommand : public Command
{
public:
    SetColorControlCurrentYAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &currentY, "Set the Value of on CurrentY.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentY");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentY, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t currentY;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentY(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlCurrentYAttributeCommand * command = reinterpret_cast<SetColorControlCurrentYAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::CurrentY::Set(command->mEndPointId, command->currentY);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentY");
        }
    }
};
class SetColorControlDriftCompensationAttributeCommand : public Command
{
public:
    SetColorControlDriftCompensationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "drift-compensation", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &driftCompensation, "Set the Value of on DriftCompensation.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DriftCompensation");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDriftCompensation, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t driftCompensation;
    chip::EndpointId mEndPointId;

private:
    static void SetDriftCompensation(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlDriftCompensationAttributeCommand * command =
            reinterpret_cast<SetColorControlDriftCompensationAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::DriftCompensation::Set(command->mEndPointId, command->driftCompensation);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DriftCompensation");
        }
    }
};
class SetColorControlCompensationTextAttributeCommand : public Command
{
public:
    SetColorControlCompensationTextAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "compensation-text", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &compensationText, "Set the Value of on CompensationText.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CompensationText");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCompensationText, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan compensationText;
    chip::EndpointId mEndPointId;

private:
    static void SetCompensationText(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlCompensationTextAttributeCommand * command =
            reinterpret_cast<SetColorControlCompensationTextAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::CompensationText::Set(command->mEndPointId, command->compensationText);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CompensationText");
        }
    }
};
class SetColorControlColorTemperatureMiredsAttributeCommand : public Command
{
public:
    SetColorControlColorTemperatureMiredsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-temperature-mireds", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorTemperatureMireds, "Set the Value of on ColorTemperatureMireds.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorTemperatureMireds");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorTemperatureMireds, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorTemperatureMireds;
    chip::EndpointId mEndPointId;

private:
    static void SetColorTemperatureMireds(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorTemperatureMiredsAttributeCommand * command =
            reinterpret_cast<SetColorControlColorTemperatureMiredsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorTemperatureMireds::Set(
            command->mEndPointId, command->colorTemperatureMireds);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorTemperatureMireds");
        }
    }
};
class SetColorControlColorModeAttributeCommand : public Command
{
public:
    SetColorControlColorModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &colorMode, "Set the Value of on ColorMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t colorMode;
    chip::EndpointId mEndPointId;

private:
    static void SetColorMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorModeAttributeCommand * command = reinterpret_cast<SetColorControlColorModeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorMode::Set(command->mEndPointId, command->colorMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorMode");
        }
    }
};
class SetColorControlOptionsAttributeCommand : public Command
{
public:
    SetColorControlOptionsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "options", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &options, "Set the Value of on Options.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Options");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOptions, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t options;
    chip::EndpointId mEndPointId;

private:
    static void SetOptions(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlOptionsAttributeCommand * command = reinterpret_cast<SetColorControlOptionsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::Options::Set(command->mEndPointId, command->options);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Options");
        }
    }
};
class SetColorControlNumberOfPrimariesAttributeCommand : public Command
{
public:
    SetColorControlNumberOfPrimariesAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "number-of-primaries", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &numberOfPrimaries, "Set the Value of on NumberOfPrimaries.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NumberOfPrimaries");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNumberOfPrimaries, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> numberOfPrimaries;
    chip::EndpointId mEndPointId;

private:
    static void SetNumberOfPrimaries(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlNumberOfPrimariesAttributeCommand * command =
            reinterpret_cast<SetColorControlNumberOfPrimariesAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::NumberOfPrimaries::Set(command->mEndPointId, command->numberOfPrimaries);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NumberOfPrimaries");
        }
    }
};
class SetColorControlPrimary1XAttributeCommand : public Command
{
public:
    SetColorControlPrimary1XAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary1x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary1X, "Set the Value of on Primary1X.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary1X");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary1X, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary1X;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary1X(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary1XAttributeCommand * command = reinterpret_cast<SetColorControlPrimary1XAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary1X::Set(command->mEndPointId, command->primary1X);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary1X");
        }
    }
};
class SetColorControlPrimary1YAttributeCommand : public Command
{
public:
    SetColorControlPrimary1YAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary1y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary1Y, "Set the Value of on Primary1Y.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary1Y");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary1Y, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary1Y;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary1Y(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary1YAttributeCommand * command = reinterpret_cast<SetColorControlPrimary1YAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary1Y::Set(command->mEndPointId, command->primary1Y);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary1Y");
        }
    }
};
class SetColorControlPrimary1IntensityAttributeCommand : public Command
{
public:
    SetColorControlPrimary1IntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary1intensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &primary1Intensity, "Set the Value of on Primary1Intensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary1Intensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary1Intensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> primary1Intensity;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary1Intensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary1IntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlPrimary1IntensityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary1Intensity::Set(command->mEndPointId, command->primary1Intensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary1Intensity");
        }
    }
};
class SetColorControlPrimary2XAttributeCommand : public Command
{
public:
    SetColorControlPrimary2XAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary2x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary2X, "Set the Value of on Primary2X.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary2X");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary2X, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary2X;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary2X(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary2XAttributeCommand * command = reinterpret_cast<SetColorControlPrimary2XAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary2X::Set(command->mEndPointId, command->primary2X);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary2X");
        }
    }
};
class SetColorControlPrimary2YAttributeCommand : public Command
{
public:
    SetColorControlPrimary2YAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary2y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary2Y, "Set the Value of on Primary2Y.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary2Y");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary2Y, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary2Y;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary2Y(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary2YAttributeCommand * command = reinterpret_cast<SetColorControlPrimary2YAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary2Y::Set(command->mEndPointId, command->primary2Y);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary2Y");
        }
    }
};
class SetColorControlPrimary2IntensityAttributeCommand : public Command
{
public:
    SetColorControlPrimary2IntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary2intensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &primary2Intensity, "Set the Value of on Primary2Intensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary2Intensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary2Intensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> primary2Intensity;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary2Intensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary2IntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlPrimary2IntensityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary2Intensity::Set(command->mEndPointId, command->primary2Intensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary2Intensity");
        }
    }
};
class SetColorControlPrimary3XAttributeCommand : public Command
{
public:
    SetColorControlPrimary3XAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary3x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary3X, "Set the Value of on Primary3X.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary3X");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary3X, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary3X;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary3X(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary3XAttributeCommand * command = reinterpret_cast<SetColorControlPrimary3XAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary3X::Set(command->mEndPointId, command->primary3X);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary3X");
        }
    }
};
class SetColorControlPrimary3YAttributeCommand : public Command
{
public:
    SetColorControlPrimary3YAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary3y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary3Y, "Set the Value of on Primary3Y.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary3Y");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary3Y, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary3Y;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary3Y(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary3YAttributeCommand * command = reinterpret_cast<SetColorControlPrimary3YAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary3Y::Set(command->mEndPointId, command->primary3Y);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary3Y");
        }
    }
};
class SetColorControlPrimary3IntensityAttributeCommand : public Command
{
public:
    SetColorControlPrimary3IntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary3intensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &primary3Intensity, "Set the Value of on Primary3Intensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary3Intensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary3Intensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> primary3Intensity;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary3Intensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary3IntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlPrimary3IntensityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary3Intensity::Set(command->mEndPointId, command->primary3Intensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary3Intensity");
        }
    }
};
class SetColorControlPrimary4XAttributeCommand : public Command
{
public:
    SetColorControlPrimary4XAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary4x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary4X, "Set the Value of on Primary4X.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary4X");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary4X, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary4X;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary4X(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary4XAttributeCommand * command = reinterpret_cast<SetColorControlPrimary4XAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary4X::Set(command->mEndPointId, command->primary4X);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary4X");
        }
    }
};
class SetColorControlPrimary4YAttributeCommand : public Command
{
public:
    SetColorControlPrimary4YAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary4y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary4Y, "Set the Value of on Primary4Y.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary4Y");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary4Y, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary4Y;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary4Y(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary4YAttributeCommand * command = reinterpret_cast<SetColorControlPrimary4YAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary4Y::Set(command->mEndPointId, command->primary4Y);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary4Y");
        }
    }
};
class SetColorControlPrimary4IntensityAttributeCommand : public Command
{
public:
    SetColorControlPrimary4IntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary4intensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &primary4Intensity, "Set the Value of on Primary4Intensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary4Intensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary4Intensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> primary4Intensity;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary4Intensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary4IntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlPrimary4IntensityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary4Intensity::Set(command->mEndPointId, command->primary4Intensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary4Intensity");
        }
    }
};
class SetColorControlPrimary5XAttributeCommand : public Command
{
public:
    SetColorControlPrimary5XAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary5x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary5X, "Set the Value of on Primary5X.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary5X");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary5X, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary5X;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary5X(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary5XAttributeCommand * command = reinterpret_cast<SetColorControlPrimary5XAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary5X::Set(command->mEndPointId, command->primary5X);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary5X");
        }
    }
};
class SetColorControlPrimary5YAttributeCommand : public Command
{
public:
    SetColorControlPrimary5YAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary5y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary5Y, "Set the Value of on Primary5Y.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary5Y");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary5Y, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary5Y;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary5Y(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary5YAttributeCommand * command = reinterpret_cast<SetColorControlPrimary5YAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary5Y::Set(command->mEndPointId, command->primary5Y);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary5Y");
        }
    }
};
class SetColorControlPrimary5IntensityAttributeCommand : public Command
{
public:
    SetColorControlPrimary5IntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary5intensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &primary5Intensity, "Set the Value of on Primary5Intensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary5Intensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary5Intensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> primary5Intensity;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary5Intensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary5IntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlPrimary5IntensityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary5Intensity::Set(command->mEndPointId, command->primary5Intensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary5Intensity");
        }
    }
};
class SetColorControlPrimary6XAttributeCommand : public Command
{
public:
    SetColorControlPrimary6XAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary6x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary6X, "Set the Value of on Primary6X.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary6X");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary6X, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary6X;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary6X(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary6XAttributeCommand * command = reinterpret_cast<SetColorControlPrimary6XAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary6X::Set(command->mEndPointId, command->primary6X);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary6X");
        }
    }
};
class SetColorControlPrimary6YAttributeCommand : public Command
{
public:
    SetColorControlPrimary6YAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary6y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &primary6Y, "Set the Value of on Primary6Y.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary6Y");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary6Y, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t primary6Y;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary6Y(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary6YAttributeCommand * command = reinterpret_cast<SetColorControlPrimary6YAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary6Y::Set(command->mEndPointId, command->primary6Y);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary6Y");
        }
    }
};
class SetColorControlPrimary6IntensityAttributeCommand : public Command
{
public:
    SetColorControlPrimary6IntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "primary6intensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &primary6Intensity, "Set the Value of on Primary6Intensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Primary6Intensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPrimary6Intensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> primary6Intensity;
    chip::EndpointId mEndPointId;

private:
    static void SetPrimary6Intensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlPrimary6IntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlPrimary6IntensityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::Primary6Intensity::Set(command->mEndPointId, command->primary6Intensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Primary6Intensity");
        }
    }
};
class SetColorControlWhitePointXAttributeCommand : public Command
{
public:
    SetColorControlWhitePointXAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "white-point-x", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &whitePointX, "Set the Value of on WhitePointX.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WhitePointX");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWhitePointX, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t whitePointX;
    chip::EndpointId mEndPointId;

private:
    static void SetWhitePointX(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlWhitePointXAttributeCommand * command =
            reinterpret_cast<SetColorControlWhitePointXAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::WhitePointX::Set(command->mEndPointId, command->whitePointX);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WhitePointX");
        }
    }
};
class SetColorControlWhitePointYAttributeCommand : public Command
{
public:
    SetColorControlWhitePointYAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "white-point-y", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &whitePointY, "Set the Value of on WhitePointY.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WhitePointY");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWhitePointY, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t whitePointY;
    chip::EndpointId mEndPointId;

private:
    static void SetWhitePointY(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlWhitePointYAttributeCommand * command =
            reinterpret_cast<SetColorControlWhitePointYAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::WhitePointY::Set(command->mEndPointId, command->whitePointY);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WhitePointY");
        }
    }
};
class SetColorControlColorPointRXAttributeCommand : public Command
{
public:
    SetColorControlColorPointRXAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-rx", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorPointRX, "Set the Value of on ColorPointRX.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointRX");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointRX, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorPointRX;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointRX(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointRXAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointRXAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorPointRX::Set(command->mEndPointId, command->colorPointRX);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointRX");
        }
    }
};
class SetColorControlColorPointRYAttributeCommand : public Command
{
public:
    SetColorControlColorPointRYAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-ry", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorPointRY, "Set the Value of on ColorPointRY.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointRY");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointRY, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorPointRY;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointRY(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointRYAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointRYAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorPointRY::Set(command->mEndPointId, command->colorPointRY);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointRY");
        }
    }
};
class SetColorControlColorPointRIntensityAttributeCommand : public Command
{
public:
    SetColorControlColorPointRIntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-rintensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &colorPointRIntensity, "Set the Value of on ColorPointRIntensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointRIntensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointRIntensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> colorPointRIntensity;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointRIntensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointRIntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointRIntensityAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorPointRIntensity::Set(
            command->mEndPointId, command->colorPointRIntensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointRIntensity");
        }
    }
};
class SetColorControlColorPointGXAttributeCommand : public Command
{
public:
    SetColorControlColorPointGXAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-gx", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorPointGX, "Set the Value of on ColorPointGX.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointGX");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointGX, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorPointGX;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointGX(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointGXAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointGXAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorPointGX::Set(command->mEndPointId, command->colorPointGX);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointGX");
        }
    }
};
class SetColorControlColorPointGYAttributeCommand : public Command
{
public:
    SetColorControlColorPointGYAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-gy", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorPointGY, "Set the Value of on ColorPointGY.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointGY");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointGY, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorPointGY;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointGY(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointGYAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointGYAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorPointGY::Set(command->mEndPointId, command->colorPointGY);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointGY");
        }
    }
};
class SetColorControlColorPointGIntensityAttributeCommand : public Command
{
public:
    SetColorControlColorPointGIntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-gintensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &colorPointGIntensity, "Set the Value of on ColorPointGIntensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointGIntensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointGIntensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> colorPointGIntensity;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointGIntensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointGIntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointGIntensityAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorPointGIntensity::Set(
            command->mEndPointId, command->colorPointGIntensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointGIntensity");
        }
    }
};
class SetColorControlColorPointBXAttributeCommand : public Command
{
public:
    SetColorControlColorPointBXAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-bx", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorPointBX, "Set the Value of on ColorPointBX.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointBX");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointBX, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorPointBX;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointBX(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointBXAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointBXAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorPointBX::Set(command->mEndPointId, command->colorPointBX);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointBX");
        }
    }
};
class SetColorControlColorPointBYAttributeCommand : public Command
{
public:
    SetColorControlColorPointBYAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-by", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorPointBY, "Set the Value of on ColorPointBY.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointBY");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointBY, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorPointBY;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointBY(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointBYAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointBYAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorPointBY::Set(command->mEndPointId, command->colorPointBY);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointBY");
        }
    }
};
class SetColorControlColorPointBIntensityAttributeCommand : public Command
{
public:
    SetColorControlColorPointBIntensityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-point-bintensity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &colorPointBIntensity, "Set the Value of on ColorPointBIntensity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorPointBIntensity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorPointBIntensity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> colorPointBIntensity;
    chip::EndpointId mEndPointId;

private:
    static void SetColorPointBIntensity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorPointBIntensityAttributeCommand * command =
            reinterpret_cast<SetColorControlColorPointBIntensityAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorPointBIntensity::Set(
            command->mEndPointId, command->colorPointBIntensity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorPointBIntensity");
        }
    }
};
class SetColorControlEnhancedCurrentHueAttributeCommand : public Command
{
public:
    SetColorControlEnhancedCurrentHueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enhanced-current-hue", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &enhancedCurrentHue, "Set the Value of on EnhancedCurrentHue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EnhancedCurrentHue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnhancedCurrentHue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t enhancedCurrentHue;
    chip::EndpointId mEndPointId;

private:
    static void SetEnhancedCurrentHue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlEnhancedCurrentHueAttributeCommand * command =
            reinterpret_cast<SetColorControlEnhancedCurrentHueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::EnhancedCurrentHue::Set(command->mEndPointId,
                                                                                                      command->enhancedCurrentHue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EnhancedCurrentHue");
        }
    }
};
class SetColorControlEnhancedColorModeAttributeCommand : public Command
{
public:
    SetColorControlEnhancedColorModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enhanced-color-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &enhancedColorMode, "Set the Value of on EnhancedColorMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EnhancedColorMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnhancedColorMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t enhancedColorMode;
    chip::EndpointId mEndPointId;

private:
    static void SetEnhancedColorMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlEnhancedColorModeAttributeCommand * command =
            reinterpret_cast<SetColorControlEnhancedColorModeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::EnhancedColorMode::Set(command->mEndPointId, command->enhancedColorMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EnhancedColorMode");
        }
    }
};
class SetColorControlColorLoopActiveAttributeCommand : public Command
{
public:
    SetColorControlColorLoopActiveAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-loop-active", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &colorLoopActive, "Set the Value of on ColorLoopActive.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorLoopActive");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorLoopActive, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t colorLoopActive;
    chip::EndpointId mEndPointId;

private:
    static void SetColorLoopActive(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorLoopActiveAttributeCommand * command =
            reinterpret_cast<SetColorControlColorLoopActiveAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorLoopActive::Set(command->mEndPointId, command->colorLoopActive);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorLoopActive");
        }
    }
};
class SetColorControlColorLoopDirectionAttributeCommand : public Command
{
public:
    SetColorControlColorLoopDirectionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-loop-direction", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &colorLoopDirection, "Set the Value of on ColorLoopDirection.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorLoopDirection");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorLoopDirection, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t colorLoopDirection;
    chip::EndpointId mEndPointId;

private:
    static void SetColorLoopDirection(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorLoopDirectionAttributeCommand * command =
            reinterpret_cast<SetColorControlColorLoopDirectionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorLoopDirection::Set(command->mEndPointId,
                                                                                                      command->colorLoopDirection);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorLoopDirection");
        }
    }
};
class SetColorControlColorLoopTimeAttributeCommand : public Command
{
public:
    SetColorControlColorLoopTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-loop-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorLoopTime, "Set the Value of on ColorLoopTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorLoopTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorLoopTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorLoopTime;
    chip::EndpointId mEndPointId;

private:
    static void SetColorLoopTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorLoopTimeAttributeCommand * command =
            reinterpret_cast<SetColorControlColorLoopTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorLoopTime::Set(command->mEndPointId, command->colorLoopTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorLoopTime");
        }
    }
};
class SetColorControlColorLoopStartEnhancedHueAttributeCommand : public Command
{
public:
    SetColorControlColorLoopStartEnhancedHueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-loop-start-enhanced-hue", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorLoopStartEnhancedHue, "Set the Value of on ColorLoopStartEnhancedHue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorLoopStartEnhancedHue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorLoopStartEnhancedHue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorLoopStartEnhancedHue;
    chip::EndpointId mEndPointId;

private:
    static void SetColorLoopStartEnhancedHue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorLoopStartEnhancedHueAttributeCommand * command =
            reinterpret_cast<SetColorControlColorLoopStartEnhancedHueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorLoopStartEnhancedHue::Set(
            command->mEndPointId, command->colorLoopStartEnhancedHue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorLoopStartEnhancedHue");
        }
    }
};
class SetColorControlColorLoopStoredEnhancedHueAttributeCommand : public Command
{
public:
    SetColorControlColorLoopStoredEnhancedHueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-loop-stored-enhanced-hue", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorLoopStoredEnhancedHue,
                    "Set the Value of on ColorLoopStoredEnhancedHue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorLoopStoredEnhancedHue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorLoopStoredEnhancedHue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorLoopStoredEnhancedHue;
    chip::EndpointId mEndPointId;

private:
    static void SetColorLoopStoredEnhancedHue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorLoopStoredEnhancedHueAttributeCommand * command =
            reinterpret_cast<SetColorControlColorLoopStoredEnhancedHueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorLoopStoredEnhancedHue::Set(
            command->mEndPointId, command->colorLoopStoredEnhancedHue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorLoopStoredEnhancedHue");
        }
    }
};
class SetColorControlColorCapabilitiesAttributeCommand : public Command
{
public:
    SetColorControlColorCapabilitiesAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-capabilities", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorCapabilities, "Set the Value of on ColorCapabilities.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorCapabilities");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorCapabilities, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorCapabilities;
    chip::EndpointId mEndPointId;

private:
    static void SetColorCapabilities(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorCapabilitiesAttributeCommand * command =
            reinterpret_cast<SetColorControlColorCapabilitiesAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ColorCapabilities::Set(command->mEndPointId, command->colorCapabilities);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorCapabilities");
        }
    }
};
class SetColorControlColorTempPhysicalMinMiredsAttributeCommand : public Command
{
public:
    SetColorControlColorTempPhysicalMinMiredsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-temp-physical-min-mireds", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorTempPhysicalMinMireds,
                    "Set the Value of on ColorTempPhysicalMinMireds.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorTempPhysicalMinMireds");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorTempPhysicalMinMireds, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorTempPhysicalMinMireds;
    chip::EndpointId mEndPointId;

private:
    static void SetColorTempPhysicalMinMireds(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorTempPhysicalMinMiredsAttributeCommand * command =
            reinterpret_cast<SetColorControlColorTempPhysicalMinMiredsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMinMireds::Set(
            command->mEndPointId, command->colorTempPhysicalMinMireds);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorTempPhysicalMinMireds");
        }
    }
};
class SetColorControlColorTempPhysicalMaxMiredsAttributeCommand : public Command
{
public:
    SetColorControlColorTempPhysicalMaxMiredsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "color-temp-physical-max-mireds", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &colorTempPhysicalMaxMireds,
                    "Set the Value of on ColorTempPhysicalMaxMireds.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ColorTempPhysicalMaxMireds");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetColorTempPhysicalMaxMireds, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t colorTempPhysicalMaxMireds;
    chip::EndpointId mEndPointId;

private:
    static void SetColorTempPhysicalMaxMireds(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlColorTempPhysicalMaxMiredsAttributeCommand * command =
            reinterpret_cast<SetColorControlColorTempPhysicalMaxMiredsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::ColorTempPhysicalMaxMireds::Set(
            command->mEndPointId, command->colorTempPhysicalMaxMireds);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ColorTempPhysicalMaxMireds");
        }
    }
};
class SetColorControlCoupleColorTempToLevelMinMiredsAttributeCommand : public Command
{
public:
    SetColorControlCoupleColorTempToLevelMinMiredsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "couple-color-temp-to-level-min-mireds", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &coupleColorTempToLevelMinMireds,
                    "Set the Value of on CoupleColorTempToLevelMinMireds.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CoupleColorTempToLevelMinMireds");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCoupleColorTempToLevelMinMireds, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t coupleColorTempToLevelMinMireds;
    chip::EndpointId mEndPointId;

private:
    static void SetCoupleColorTempToLevelMinMireds(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlCoupleColorTempToLevelMinMiredsAttributeCommand * command =
            reinterpret_cast<SetColorControlCoupleColorTempToLevelMinMiredsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::CoupleColorTempToLevelMinMireds::Set(
            command->mEndPointId, command->coupleColorTempToLevelMinMireds);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CoupleColorTempToLevelMinMireds");
        }
    }
};
class SetColorControlStartUpColorTemperatureMiredsAttributeCommand : public Command
{
public:
    SetColorControlStartUpColorTemperatureMiredsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "start-up-color-temperature-mireds", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &startUpColorTemperatureMireds,
                    "Set the Value of on StartUpColorTemperatureMireds.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StartUpColorTemperatureMireds");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStartUpColorTemperatureMireds, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> startUpColorTemperatureMireds;
    chip::EndpointId mEndPointId;

private:
    static void SetStartUpColorTemperatureMireds(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlStartUpColorTemperatureMiredsAttributeCommand * command =
            reinterpret_cast<SetColorControlStartUpColorTemperatureMiredsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ColorControl::Attributes::StartUpColorTemperatureMireds::Set(
            command->mEndPointId, command->startUpColorTemperatureMireds);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StartUpColorTemperatureMireds");
        }
    }
};
class SetColorControlFeatureMapAttributeCommand : public Command
{
public:
    SetColorControlFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlFeatureMapAttributeCommand * command =
            reinterpret_cast<SetColorControlFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetColorControlClusterRevisionAttributeCommand : public Command
{
public:
    SetColorControlClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetColorControlClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetColorControlClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ColorControl::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetBallastConfigurationPhysicalMinLevelAttributeCommand : public Command
{
public:
    SetBallastConfigurationPhysicalMinLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "physical-min-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &physicalMinLevel, "Set the Value of on PhysicalMinLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhysicalMinLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhysicalMinLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t physicalMinLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetPhysicalMinLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationPhysicalMinLevelAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationPhysicalMinLevelAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::PhysicalMinLevel::Set(
            command->mEndPointId, command->physicalMinLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhysicalMinLevel");
        }
    }
};
class SetBallastConfigurationPhysicalMaxLevelAttributeCommand : public Command
{
public:
    SetBallastConfigurationPhysicalMaxLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "physical-max-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &physicalMaxLevel, "Set the Value of on PhysicalMaxLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhysicalMaxLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhysicalMaxLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t physicalMaxLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetPhysicalMaxLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationPhysicalMaxLevelAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationPhysicalMaxLevelAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::PhysicalMaxLevel::Set(
            command->mEndPointId, command->physicalMaxLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhysicalMaxLevel");
        }
    }
};
class SetBallastConfigurationBallastStatusAttributeCommand : public Command
{
public:
    SetBallastConfigurationBallastStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ballast-status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ballastStatus, "Set the Value of on BallastStatus.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BallastStatus");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBallastStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t ballastStatus;
    chip::EndpointId mEndPointId;

private:
    static void SetBallastStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationBallastStatusAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationBallastStatusAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::BallastStatus::Set(command->mEndPointId, command->ballastStatus);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BallastStatus");
        }
    }
};
class SetBallastConfigurationMinLevelAttributeCommand : public Command
{
public:
    SetBallastConfigurationMinLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &minLevel, "Set the Value of on MinLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t minLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetMinLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationMinLevelAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationMinLevelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::MinLevel::Set(command->mEndPointId, command->minLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinLevel");
        }
    }
};
class SetBallastConfigurationMaxLevelAttributeCommand : public Command
{
public:
    SetBallastConfigurationMaxLevelAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-level", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &maxLevel, "Set the Value of on MaxLevel.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxLevel");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxLevel, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t maxLevel;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxLevel(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationMaxLevelAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationMaxLevelAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::MaxLevel::Set(command->mEndPointId, command->maxLevel);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxLevel");
        }
    }
};
class SetBallastConfigurationIntrinsicBallastFactorAttributeCommand : public Command
{
public:
    SetBallastConfigurationIntrinsicBallastFactorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "intrinsic-ballast-factor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &intrinsicBallastFactor, "Set the Value of on IntrinsicBallastFactor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: IntrinsicBallastFactor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetIntrinsicBallastFactor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> intrinsicBallastFactor;
    chip::EndpointId mEndPointId;

private:
    static void SetIntrinsicBallastFactor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationIntrinsicBallastFactorAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationIntrinsicBallastFactorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::IntrinsicBallastFactor::Set(
            command->mEndPointId, command->intrinsicBallastFactor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute IntrinsicBallastFactor");
        }
    }
};
class SetBallastConfigurationBallastFactorAdjustmentAttributeCommand : public Command
{
public:
    SetBallastConfigurationBallastFactorAdjustmentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ballast-factor-adjustment", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ballastFactorAdjustment, "Set the Value of on BallastFactorAdjustment.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: BallastFactorAdjustment");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBallastFactorAdjustment, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> ballastFactorAdjustment;
    chip::EndpointId mEndPointId;

private:
    static void SetBallastFactorAdjustment(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationBallastFactorAdjustmentAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationBallastFactorAdjustmentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::BallastFactorAdjustment::Set(
            command->mEndPointId, command->ballastFactorAdjustment);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute BallastFactorAdjustment");
        }
    }
};
class SetBallastConfigurationLampQuantityAttributeCommand : public Command
{
public:
    SetBallastConfigurationLampQuantityAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lamp-quantity", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &lampQuantity, "Set the Value of on LampQuantity.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LampQuantity");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLampQuantity, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t lampQuantity;
    chip::EndpointId mEndPointId;

private:
    static void SetLampQuantity(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationLampQuantityAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationLampQuantityAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::LampQuantity::Set(command->mEndPointId, command->lampQuantity);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LampQuantity");
        }
    }
};
class SetBallastConfigurationLampTypeAttributeCommand : public Command
{
public:
    SetBallastConfigurationLampTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lamp-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &lampType, "Set the Value of on LampType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LampType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLampType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan lampType;
    chip::EndpointId mEndPointId;

private:
    static void SetLampType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationLampTypeAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationLampTypeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::LampType::Set(command->mEndPointId, command->lampType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LampType");
        }
    }
};
class SetBallastConfigurationLampManufacturerAttributeCommand : public Command
{
public:
    SetBallastConfigurationLampManufacturerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lamp-manufacturer", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &lampManufacturer, "Set the Value of on LampManufacturer.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LampManufacturer");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLampManufacturer, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan lampManufacturer;
    chip::EndpointId mEndPointId;

private:
    static void SetLampManufacturer(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationLampManufacturerAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationLampManufacturerAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::LampManufacturer::Set(
            command->mEndPointId, command->lampManufacturer);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LampManufacturer");
        }
    }
};
class SetBallastConfigurationLampRatedHoursAttributeCommand : public Command
{
public:
    SetBallastConfigurationLampRatedHoursAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lamp-rated-hours", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &lampRatedHours, "Set the Value of on LampRatedHours.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LampRatedHours");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLampRatedHours, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> lampRatedHours;
    chip::EndpointId mEndPointId;

private:
    static void SetLampRatedHours(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationLampRatedHoursAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationLampRatedHoursAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::LampRatedHours::Set(command->mEndPointId,
                                                                                                          command->lampRatedHours);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LampRatedHours");
        }
    }
};
class SetBallastConfigurationLampBurnHoursAttributeCommand : public Command
{
public:
    SetBallastConfigurationLampBurnHoursAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lamp-burn-hours", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &lampBurnHours, "Set the Value of on LampBurnHours.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LampBurnHours");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLampBurnHours, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> lampBurnHours;
    chip::EndpointId mEndPointId;

private:
    static void SetLampBurnHours(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationLampBurnHoursAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationLampBurnHoursAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::LampBurnHours::Set(command->mEndPointId, command->lampBurnHours);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LampBurnHours");
        }
    }
};
class SetBallastConfigurationLampAlarmModeAttributeCommand : public Command
{
public:
    SetBallastConfigurationLampAlarmModeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lamp-alarm-mode", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &lampAlarmMode, "Set the Value of on LampAlarmMode.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LampAlarmMode");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLampAlarmMode, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t lampAlarmMode;
    chip::EndpointId mEndPointId;

private:
    static void SetLampAlarmMode(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationLampAlarmModeAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationLampAlarmModeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::LampAlarmMode::Set(command->mEndPointId, command->lampAlarmMode);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LampAlarmMode");
        }
    }
};
class SetBallastConfigurationLampBurnHoursTripPointAttributeCommand : public Command
{
public:
    SetBallastConfigurationLampBurnHoursTripPointAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "lamp-burn-hours-trip-point", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &lampBurnHoursTripPoint, "Set the Value of on LampBurnHoursTripPoint.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LampBurnHoursTripPoint");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLampBurnHoursTripPoint, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> lampBurnHoursTripPoint;
    chip::EndpointId mEndPointId;

private:
    static void SetLampBurnHoursTripPoint(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationLampBurnHoursTripPointAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationLampBurnHoursTripPointAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::LampBurnHoursTripPoint::Set(
            command->mEndPointId, command->lampBurnHoursTripPoint);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LampBurnHoursTripPoint");
        }
    }
};
class SetBallastConfigurationFeatureMapAttributeCommand : public Command
{
public:
    SetBallastConfigurationFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationFeatureMapAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::BallastConfiguration::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetBallastConfigurationClusterRevisionAttributeCommand : public Command
{
public:
    SetBallastConfigurationClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetBallastConfigurationClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetBallastConfigurationClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::BallastConfiguration::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetIlluminanceMeasurementMeasuredValueAttributeCommand : public Command
{
public:
    SetIlluminanceMeasurementMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &measuredValue, "Set the Value of on MeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> measuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIlluminanceMeasurementMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetIlluminanceMeasurementMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::IlluminanceMeasurement::Attributes::MeasuredValue::Set(command->mEndPointId,
                                                                                                           command->measuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredValue");
        }
    }
};
class SetIlluminanceMeasurementMinMeasuredValueAttributeCommand : public Command
{
public:
    SetIlluminanceMeasurementMinMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &minMeasuredValue, "Set the Value of on MinMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> minMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMinMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIlluminanceMeasurementMinMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetIlluminanceMeasurementMinMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::IlluminanceMeasurement::Attributes::MinMeasuredValue::Set(
            command->mEndPointId, command->minMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinMeasuredValue");
        }
    }
};
class SetIlluminanceMeasurementMaxMeasuredValueAttributeCommand : public Command
{
public:
    SetIlluminanceMeasurementMaxMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxMeasuredValue, "Set the Value of on MaxMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> maxMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIlluminanceMeasurementMaxMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetIlluminanceMeasurementMaxMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::IlluminanceMeasurement::Attributes::MaxMeasuredValue::Set(
            command->mEndPointId, command->maxMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxMeasuredValue");
        }
    }
};
class SetIlluminanceMeasurementToleranceAttributeCommand : public Command
{
public:
    SetIlluminanceMeasurementToleranceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tolerance", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &tolerance, "Set the Value of on Tolerance.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Tolerance");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTolerance, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t tolerance;
    chip::EndpointId mEndPointId;

private:
    static void SetTolerance(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIlluminanceMeasurementToleranceAttributeCommand * command =
            reinterpret_cast<SetIlluminanceMeasurementToleranceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::IlluminanceMeasurement::Attributes::Tolerance::Set(command->mEndPointId, command->tolerance);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Tolerance");
        }
    }
};
class SetIlluminanceMeasurementLightSensorTypeAttributeCommand : public Command
{
public:
    SetIlluminanceMeasurementLightSensorTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "light-sensor-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &lightSensorType, "Set the Value of on LightSensorType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LightSensorType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLightSensorType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> lightSensorType;
    chip::EndpointId mEndPointId;

private:
    static void SetLightSensorType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIlluminanceMeasurementLightSensorTypeAttributeCommand * command =
            reinterpret_cast<SetIlluminanceMeasurementLightSensorTypeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::IlluminanceMeasurement::Attributes::LightSensorType::Set(
            command->mEndPointId, command->lightSensorType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LightSensorType");
        }
    }
};
class SetIlluminanceMeasurementFeatureMapAttributeCommand : public Command
{
public:
    SetIlluminanceMeasurementFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIlluminanceMeasurementFeatureMapAttributeCommand * command =
            reinterpret_cast<SetIlluminanceMeasurementFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::IlluminanceMeasurement::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetIlluminanceMeasurementClusterRevisionAttributeCommand : public Command
{
public:
    SetIlluminanceMeasurementClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetIlluminanceMeasurementClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetIlluminanceMeasurementClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::IlluminanceMeasurement::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetTemperatureMeasurementMeasuredValueAttributeCommand : public Command
{
public:
    SetTemperatureMeasurementMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredValue, "Set the Value of on MeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> measuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTemperatureMeasurementMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetTemperatureMeasurementMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TemperatureMeasurement::Attributes::MeasuredValue::Set(command->mEndPointId,
                                                                                                           command->measuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredValue");
        }
    }
};
class SetTemperatureMeasurementMinMeasuredValueAttributeCommand : public Command
{
public:
    SetTemperatureMeasurementMinMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minMeasuredValue, "Set the Value of on MinMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> minMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMinMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTemperatureMeasurementMinMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetTemperatureMeasurementMinMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TemperatureMeasurement::Attributes::MinMeasuredValue::Set(
            command->mEndPointId, command->minMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinMeasuredValue");
        }
    }
};
class SetTemperatureMeasurementMaxMeasuredValueAttributeCommand : public Command
{
public:
    SetTemperatureMeasurementMaxMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxMeasuredValue, "Set the Value of on MaxMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> maxMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTemperatureMeasurementMaxMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetTemperatureMeasurementMaxMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TemperatureMeasurement::Attributes::MaxMeasuredValue::Set(
            command->mEndPointId, command->maxMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxMeasuredValue");
        }
    }
};
class SetTemperatureMeasurementToleranceAttributeCommand : public Command
{
public:
    SetTemperatureMeasurementToleranceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tolerance", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &tolerance, "Set the Value of on Tolerance.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Tolerance");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTolerance, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t tolerance;
    chip::EndpointId mEndPointId;

private:
    static void SetTolerance(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTemperatureMeasurementToleranceAttributeCommand * command =
            reinterpret_cast<SetTemperatureMeasurementToleranceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TemperatureMeasurement::Attributes::Tolerance::Set(command->mEndPointId, command->tolerance);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Tolerance");
        }
    }
};
class SetTemperatureMeasurementFeatureMapAttributeCommand : public Command
{
public:
    SetTemperatureMeasurementFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTemperatureMeasurementFeatureMapAttributeCommand * command =
            reinterpret_cast<SetTemperatureMeasurementFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TemperatureMeasurement::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetTemperatureMeasurementClusterRevisionAttributeCommand : public Command
{
public:
    SetTemperatureMeasurementClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTemperatureMeasurementClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetTemperatureMeasurementClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::TemperatureMeasurement::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetPressureMeasurementMeasuredValueAttributeCommand : public Command
{
public:
    SetPressureMeasurementMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredValue, "Set the Value of on MeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> measuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PressureMeasurement::Attributes::MeasuredValue::Set(command->mEndPointId, command->measuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredValue");
        }
    }
};
class SetPressureMeasurementMinMeasuredValueAttributeCommand : public Command
{
public:
    SetPressureMeasurementMinMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minMeasuredValue, "Set the Value of on MinMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> minMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMinMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementMinMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementMinMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PressureMeasurement::Attributes::MinMeasuredValue::Set(
            command->mEndPointId, command->minMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinMeasuredValue");
        }
    }
};
class SetPressureMeasurementMaxMeasuredValueAttributeCommand : public Command
{
public:
    SetPressureMeasurementMaxMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxMeasuredValue, "Set the Value of on MaxMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> maxMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementMaxMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementMaxMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PressureMeasurement::Attributes::MaxMeasuredValue::Set(
            command->mEndPointId, command->maxMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxMeasuredValue");
        }
    }
};
class SetPressureMeasurementToleranceAttributeCommand : public Command
{
public:
    SetPressureMeasurementToleranceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tolerance", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &tolerance, "Set the Value of on Tolerance.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Tolerance");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTolerance, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t tolerance;
    chip::EndpointId mEndPointId;

private:
    static void SetTolerance(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementToleranceAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementToleranceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PressureMeasurement::Attributes::Tolerance::Set(command->mEndPointId, command->tolerance);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Tolerance");
        }
    }
};
class SetPressureMeasurementScaledValueAttributeCommand : public Command
{
public:
    SetPressureMeasurementScaledValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "scaled-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &scaledValue, "Set the Value of on ScaledValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ScaledValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetScaledValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> scaledValue;
    chip::EndpointId mEndPointId;

private:
    static void SetScaledValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementScaledValueAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementScaledValueAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PressureMeasurement::Attributes::ScaledValue::Set(command->mEndPointId, command->scaledValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ScaledValue");
        }
    }
};
class SetPressureMeasurementMinScaledValueAttributeCommand : public Command
{
public:
    SetPressureMeasurementMinScaledValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-scaled-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &minScaledValue, "Set the Value of on MinScaledValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinScaledValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinScaledValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> minScaledValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMinScaledValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementMinScaledValueAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementMinScaledValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PressureMeasurement::Attributes::MinScaledValue::Set(command->mEndPointId,
                                                                                                         command->minScaledValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinScaledValue");
        }
    }
};
class SetPressureMeasurementMaxScaledValueAttributeCommand : public Command
{
public:
    SetPressureMeasurementMaxScaledValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-scaled-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &maxScaledValue, "Set the Value of on MaxScaledValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxScaledValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxScaledValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> maxScaledValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxScaledValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementMaxScaledValueAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementMaxScaledValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PressureMeasurement::Attributes::MaxScaledValue::Set(command->mEndPointId,
                                                                                                         command->maxScaledValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxScaledValue");
        }
    }
};
class SetPressureMeasurementScaledToleranceAttributeCommand : public Command
{
public:
    SetPressureMeasurementScaledToleranceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "scaled-tolerance", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &scaledTolerance, "Set the Value of on ScaledTolerance.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ScaledTolerance");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetScaledTolerance, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t scaledTolerance;
    chip::EndpointId mEndPointId;

private:
    static void SetScaledTolerance(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementScaledToleranceAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementScaledToleranceAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PressureMeasurement::Attributes::ScaledTolerance::Set(command->mEndPointId,
                                                                                                          command->scaledTolerance);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ScaledTolerance");
        }
    }
};
class SetPressureMeasurementScaleAttributeCommand : public Command
{
public:
    SetPressureMeasurementScaleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "scale", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &scale, "Set the Value of on Scale.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Scale");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetScale, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t scale;
    chip::EndpointId mEndPointId;

private:
    static void SetScale(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementScaleAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementScaleAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PressureMeasurement::Attributes::Scale::Set(command->mEndPointId, command->scale);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Scale");
        }
    }
};
class SetPressureMeasurementFeatureMapAttributeCommand : public Command
{
public:
    SetPressureMeasurementFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementFeatureMapAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::PressureMeasurement::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetPressureMeasurementClusterRevisionAttributeCommand : public Command
{
public:
    SetPressureMeasurementClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetPressureMeasurementClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetPressureMeasurementClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::PressureMeasurement::Attributes::ClusterRevision::Set(command->mEndPointId,
                                                                                                          command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetFlowMeasurementMeasuredValueAttributeCommand : public Command
{
public:
    SetFlowMeasurementMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &measuredValue, "Set the Value of on MeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> measuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFlowMeasurementMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetFlowMeasurementMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FlowMeasurement::Attributes::MeasuredValue::Set(command->mEndPointId, command->measuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredValue");
        }
    }
};
class SetFlowMeasurementMinMeasuredValueAttributeCommand : public Command
{
public:
    SetFlowMeasurementMinMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &minMeasuredValue, "Set the Value of on MinMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> minMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMinMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFlowMeasurementMinMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetFlowMeasurementMinMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::FlowMeasurement::Attributes::MinMeasuredValue::Set(command->mEndPointId,
                                                                                                       command->minMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinMeasuredValue");
        }
    }
};
class SetFlowMeasurementMaxMeasuredValueAttributeCommand : public Command
{
public:
    SetFlowMeasurementMaxMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxMeasuredValue, "Set the Value of on MaxMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> maxMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFlowMeasurementMaxMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetFlowMeasurementMaxMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::FlowMeasurement::Attributes::MaxMeasuredValue::Set(command->mEndPointId,
                                                                                                       command->maxMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxMeasuredValue");
        }
    }
};
class SetFlowMeasurementToleranceAttributeCommand : public Command
{
public:
    SetFlowMeasurementToleranceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tolerance", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &tolerance, "Set the Value of on Tolerance.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Tolerance");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTolerance, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t tolerance;
    chip::EndpointId mEndPointId;

private:
    static void SetTolerance(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFlowMeasurementToleranceAttributeCommand * command =
            reinterpret_cast<SetFlowMeasurementToleranceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FlowMeasurement::Attributes::Tolerance::Set(command->mEndPointId, command->tolerance);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Tolerance");
        }
    }
};
class SetFlowMeasurementFeatureMapAttributeCommand : public Command
{
public:
    SetFlowMeasurementFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFlowMeasurementFeatureMapAttributeCommand * command =
            reinterpret_cast<SetFlowMeasurementFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FlowMeasurement::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetFlowMeasurementClusterRevisionAttributeCommand : public Command
{
public:
    SetFlowMeasurementClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFlowMeasurementClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetFlowMeasurementClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FlowMeasurement::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetRelativeHumidityMeasurementMeasuredValueAttributeCommand : public Command
{
public:
    SetRelativeHumidityMeasurementMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &measuredValue, "Set the Value of on MeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> measuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetRelativeHumidityMeasurementMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetRelativeHumidityMeasurementMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MeasuredValue::Set(
            command->mEndPointId, command->measuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredValue");
        }
    }
};
class SetRelativeHumidityMeasurementMinMeasuredValueAttributeCommand : public Command
{
public:
    SetRelativeHumidityMeasurementMinMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "min-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &minMeasuredValue, "Set the Value of on MinMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MinMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMinMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> minMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMinMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetRelativeHumidityMeasurementMinMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetRelativeHumidityMeasurementMinMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MinMeasuredValue::Set(
            command->mEndPointId, command->minMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MinMeasuredValue");
        }
    }
};
class SetRelativeHumidityMeasurementMaxMeasuredValueAttributeCommand : public Command
{
public:
    SetRelativeHumidityMeasurementMaxMeasuredValueAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "max-measured-value", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &maxMeasuredValue, "Set the Value of on MaxMeasuredValue.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MaxMeasuredValue");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMaxMeasuredValue, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> maxMeasuredValue;
    chip::EndpointId mEndPointId;

private:
    static void SetMaxMeasuredValue(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetRelativeHumidityMeasurementMaxMeasuredValueAttributeCommand * command =
            reinterpret_cast<SetRelativeHumidityMeasurementMaxMeasuredValueAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::RelativeHumidityMeasurement::Attributes::MaxMeasuredValue::Set(
            command->mEndPointId, command->maxMeasuredValue);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MaxMeasuredValue");
        }
    }
};
class SetRelativeHumidityMeasurementToleranceAttributeCommand : public Command
{
public:
    SetRelativeHumidityMeasurementToleranceAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "tolerance", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &tolerance, "Set the Value of on Tolerance.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Tolerance");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTolerance, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t tolerance;
    chip::EndpointId mEndPointId;

private:
    static void SetTolerance(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetRelativeHumidityMeasurementToleranceAttributeCommand * command =
            reinterpret_cast<SetRelativeHumidityMeasurementToleranceAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::RelativeHumidityMeasurement::Attributes::Tolerance::Set(command->mEndPointId, command->tolerance);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Tolerance");
        }
    }
};
class SetRelativeHumidityMeasurementFeatureMapAttributeCommand : public Command
{
public:
    SetRelativeHumidityMeasurementFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetRelativeHumidityMeasurementFeatureMapAttributeCommand * command =
            reinterpret_cast<SetRelativeHumidityMeasurementFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::RelativeHumidityMeasurement::Attributes::FeatureMap::Set(command->mEndPointId,
                                                                                                             command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetRelativeHumidityMeasurementClusterRevisionAttributeCommand : public Command
{
public:
    SetRelativeHumidityMeasurementClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetRelativeHumidityMeasurementClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetRelativeHumidityMeasurementClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::RelativeHumidityMeasurement::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetOccupancySensingOccupancyAttributeCommand : public Command
{
public:
    SetOccupancySensingOccupancyAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupancy", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &occupancy, "Set the Value of on Occupancy.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Occupancy");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupancy, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap> occupancy;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupancy(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingOccupancyAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingOccupancyAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OccupancySensing::Attributes::Occupancy::Set(command->mEndPointId, command->occupancy);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Occupancy");
        }
    }
};
class SetOccupancySensingOccupancySensorTypeAttributeCommand : public Command
{
public:
    SetOccupancySensingOccupancySensorTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupancy-sensor-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &occupancySensorType, "Set the Value of on OccupancySensorType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OccupancySensorType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupancySensorType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum occupancySensorType;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupancySensorType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingOccupancySensorTypeAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingOccupancySensorTypeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorType::Set(
            command->mEndPointId, command->occupancySensorType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OccupancySensorType");
        }
    }
};
class SetOccupancySensingOccupancySensorTypeBitmapAttributeCommand : public Command
{
public:
    SetOccupancySensingOccupancySensorTypeBitmapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "occupancy-sensor-type-bitmap", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &occupancySensorTypeBitmap, "Set the Value of on OccupancySensorTypeBitmap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OccupancySensorTypeBitmap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOccupancySensorTypeBitmap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap> occupancySensorTypeBitmap;
    chip::EndpointId mEndPointId;

private:
    static void SetOccupancySensorTypeBitmap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingOccupancySensorTypeBitmapAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingOccupancySensorTypeBitmapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::OccupancySensorTypeBitmap::Set(
            command->mEndPointId, command->occupancySensorTypeBitmap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OccupancySensorTypeBitmap");
        }
    }
};
class SetOccupancySensingPIROccupiedToUnoccupiedDelayAttributeCommand : public Command
{
public:
    SetOccupancySensingPIROccupiedToUnoccupiedDelayAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "piroccupied-to-unoccupied-delay", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &PIROccupiedToUnoccupiedDelay,
                    "Set the Value of on PIROccupiedToUnoccupiedDelay.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PIROccupiedToUnoccupiedDelay");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPIROccupiedToUnoccupiedDelay, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t PIROccupiedToUnoccupiedDelay;
    chip::EndpointId mEndPointId;

private:
    static void SetPIROccupiedToUnoccupiedDelay(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingPIROccupiedToUnoccupiedDelayAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingPIROccupiedToUnoccupiedDelayAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::PIROccupiedToUnoccupiedDelay::Set(
            command->mEndPointId, command->PIROccupiedToUnoccupiedDelay);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PIROccupiedToUnoccupiedDelay");
        }
    }
};
class SetOccupancySensingPIRUnoccupiedToOccupiedDelayAttributeCommand : public Command
{
public:
    SetOccupancySensingPIRUnoccupiedToOccupiedDelayAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "pirunoccupied-to-occupied-delay", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &PIRUnoccupiedToOccupiedDelay,
                    "Set the Value of on PIRUnoccupiedToOccupiedDelay.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PIRUnoccupiedToOccupiedDelay");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPIRUnoccupiedToOccupiedDelay, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t PIRUnoccupiedToOccupiedDelay;
    chip::EndpointId mEndPointId;

private:
    static void SetPIRUnoccupiedToOccupiedDelay(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingPIRUnoccupiedToOccupiedDelayAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingPIRUnoccupiedToOccupiedDelayAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::PIRUnoccupiedToOccupiedDelay::Set(
            command->mEndPointId, command->PIRUnoccupiedToOccupiedDelay);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PIRUnoccupiedToOccupiedDelay");
        }
    }
};
class SetOccupancySensingPIRUnoccupiedToOccupiedThresholdAttributeCommand : public Command
{
public:
    SetOccupancySensingPIRUnoccupiedToOccupiedThresholdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "pirunoccupied-to-occupied-threshold", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &PIRUnoccupiedToOccupiedThreshold,
                    "Set the Value of on PIRUnoccupiedToOccupiedThreshold.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PIRUnoccupiedToOccupiedThreshold");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPIRUnoccupiedToOccupiedThreshold, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t PIRUnoccupiedToOccupiedThreshold;
    chip::EndpointId mEndPointId;

private:
    static void SetPIRUnoccupiedToOccupiedThreshold(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingPIRUnoccupiedToOccupiedThresholdAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingPIRUnoccupiedToOccupiedThresholdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::PIRUnoccupiedToOccupiedThreshold::Set(
            command->mEndPointId, command->PIRUnoccupiedToOccupiedThreshold);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PIRUnoccupiedToOccupiedThreshold");
        }
    }
};
class SetOccupancySensingUltrasonicOccupiedToUnoccupiedDelayAttributeCommand : public Command
{
public:
    SetOccupancySensingUltrasonicOccupiedToUnoccupiedDelayAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ultrasonic-occupied-to-unoccupied-delay", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &ultrasonicOccupiedToUnoccupiedDelay,
                    "Set the Value of on UltrasonicOccupiedToUnoccupiedDelay.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UltrasonicOccupiedToUnoccupiedDelay");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUltrasonicOccupiedToUnoccupiedDelay, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t ultrasonicOccupiedToUnoccupiedDelay;
    chip::EndpointId mEndPointId;

private:
    static void SetUltrasonicOccupiedToUnoccupiedDelay(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingUltrasonicOccupiedToUnoccupiedDelayAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingUltrasonicOccupiedToUnoccupiedDelayAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::UltrasonicOccupiedToUnoccupiedDelay::Set(
            command->mEndPointId, command->ultrasonicOccupiedToUnoccupiedDelay);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UltrasonicOccupiedToUnoccupiedDelay");
        }
    }
};
class SetOccupancySensingUltrasonicUnoccupiedToOccupiedDelayAttributeCommand : public Command
{
public:
    SetOccupancySensingUltrasonicUnoccupiedToOccupiedDelayAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ultrasonic-unoccupied-to-occupied-delay", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &ultrasonicUnoccupiedToOccupiedDelay,
                    "Set the Value of on UltrasonicUnoccupiedToOccupiedDelay.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UltrasonicUnoccupiedToOccupiedDelay");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUltrasonicUnoccupiedToOccupiedDelay, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t ultrasonicUnoccupiedToOccupiedDelay;
    chip::EndpointId mEndPointId;

private:
    static void SetUltrasonicUnoccupiedToOccupiedDelay(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingUltrasonicUnoccupiedToOccupiedDelayAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingUltrasonicUnoccupiedToOccupiedDelayAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::UltrasonicUnoccupiedToOccupiedDelay::Set(
            command->mEndPointId, command->ultrasonicUnoccupiedToOccupiedDelay);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UltrasonicUnoccupiedToOccupiedDelay");
        }
    }
};
class SetOccupancySensingUltrasonicUnoccupiedToOccupiedThresholdAttributeCommand : public Command
{
public:
    SetOccupancySensingUltrasonicUnoccupiedToOccupiedThresholdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ultrasonic-unoccupied-to-occupied-threshold", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &ultrasonicUnoccupiedToOccupiedThreshold,
                    "Set the Value of on UltrasonicUnoccupiedToOccupiedThreshold.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: UltrasonicUnoccupiedToOccupiedThreshold");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUltrasonicUnoccupiedToOccupiedThreshold, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t ultrasonicUnoccupiedToOccupiedThreshold;
    chip::EndpointId mEndPointId;

private:
    static void SetUltrasonicUnoccupiedToOccupiedThreshold(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingUltrasonicUnoccupiedToOccupiedThresholdAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingUltrasonicUnoccupiedToOccupiedThresholdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::UltrasonicUnoccupiedToOccupiedThreshold::Set(
            command->mEndPointId, command->ultrasonicUnoccupiedToOccupiedThreshold);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute UltrasonicUnoccupiedToOccupiedThreshold");
        }
    }
};
class SetOccupancySensingPhysicalContactOccupiedToUnoccupiedDelayAttributeCommand : public Command
{
public:
    SetOccupancySensingPhysicalContactOccupiedToUnoccupiedDelayAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "physical-contact-occupied-to-unoccupied-delay", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &physicalContactOccupiedToUnoccupiedDelay,
                    "Set the Value of on PhysicalContactOccupiedToUnoccupiedDelay.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhysicalContactOccupiedToUnoccupiedDelay");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhysicalContactOccupiedToUnoccupiedDelay,
                                                      reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t physicalContactOccupiedToUnoccupiedDelay;
    chip::EndpointId mEndPointId;

private:
    static void SetPhysicalContactOccupiedToUnoccupiedDelay(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingPhysicalContactOccupiedToUnoccupiedDelayAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingPhysicalContactOccupiedToUnoccupiedDelayAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::PhysicalContactOccupiedToUnoccupiedDelay::Set(
            command->mEndPointId, command->physicalContactOccupiedToUnoccupiedDelay);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhysicalContactOccupiedToUnoccupiedDelay");
        }
    }
};
class SetOccupancySensingPhysicalContactUnoccupiedToOccupiedDelayAttributeCommand : public Command
{
public:
    SetOccupancySensingPhysicalContactUnoccupiedToOccupiedDelayAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "physical-contact-unoccupied-to-occupied-delay", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &physicalContactUnoccupiedToOccupiedDelay,
                    "Set the Value of on PhysicalContactUnoccupiedToOccupiedDelay.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhysicalContactUnoccupiedToOccupiedDelay");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhysicalContactUnoccupiedToOccupiedDelay,
                                                      reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t physicalContactUnoccupiedToOccupiedDelay;
    chip::EndpointId mEndPointId;

private:
    static void SetPhysicalContactUnoccupiedToOccupiedDelay(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingPhysicalContactUnoccupiedToOccupiedDelayAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingPhysicalContactUnoccupiedToOccupiedDelayAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::PhysicalContactUnoccupiedToOccupiedDelay::Set(
            command->mEndPointId, command->physicalContactUnoccupiedToOccupiedDelay);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhysicalContactUnoccupiedToOccupiedDelay");
        }
    }
};
class SetOccupancySensingPhysicalContactUnoccupiedToOccupiedThresholdAttributeCommand : public Command
{
public:
    SetOccupancySensingPhysicalContactUnoccupiedToOccupiedThresholdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "physical-contact-unoccupied-to-occupied-threshold", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &physicalContactUnoccupiedToOccupiedThreshold,
                    "Set the Value of on PhysicalContactUnoccupiedToOccupiedThreshold.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhysicalContactUnoccupiedToOccupiedThreshold");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhysicalContactUnoccupiedToOccupiedThreshold,
                                                      reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t physicalContactUnoccupiedToOccupiedThreshold;
    chip::EndpointId mEndPointId;

private:
    static void SetPhysicalContactUnoccupiedToOccupiedThreshold(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingPhysicalContactUnoccupiedToOccupiedThresholdAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingPhysicalContactUnoccupiedToOccupiedThresholdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::OccupancySensing::Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::Set(
            command->mEndPointId, command->physicalContactUnoccupiedToOccupiedThreshold);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhysicalContactUnoccupiedToOccupiedThreshold");
        }
    }
};
class SetOccupancySensingFeatureMapAttributeCommand : public Command
{
public:
    SetOccupancySensingFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingFeatureMapAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OccupancySensing::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetOccupancySensingClusterRevisionAttributeCommand : public Command
{
public:
    SetOccupancySensingClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetOccupancySensingClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetOccupancySensingClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::OccupancySensing::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetWakeOnLanMACAddressAttributeCommand : public Command
{
public:
    SetWakeOnLanMACAddressAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "macaddress", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &MACAddress, "Set the Value of on MACAddress.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MACAddress");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMACAddress, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan MACAddress;
    chip::EndpointId mEndPointId;

private:
    static void SetMACAddress(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWakeOnLanMACAddressAttributeCommand * command = reinterpret_cast<SetWakeOnLanMACAddressAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WakeOnLan::Attributes::MACAddress::Set(command->mEndPointId, command->MACAddress);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MACAddress");
        }
    }
};
class SetWakeOnLanFeatureMapAttributeCommand : public Command
{
public:
    SetWakeOnLanFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWakeOnLanFeatureMapAttributeCommand * command = reinterpret_cast<SetWakeOnLanFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WakeOnLan::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetWakeOnLanClusterRevisionAttributeCommand : public Command
{
public:
    SetWakeOnLanClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetWakeOnLanClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetWakeOnLanClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::WakeOnLan::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetChannelFeatureMapAttributeCommand : public Command
{
public:
    SetChannelFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetChannelFeatureMapAttributeCommand * command = reinterpret_cast<SetChannelFeatureMapAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::Channel::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetChannelClusterRevisionAttributeCommand : public Command
{
public:
    SetChannelClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetChannelClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetChannelClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::Channel::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetTargetNavigatorCurrentTargetAttributeCommand : public Command
{
public:
    SetTargetNavigatorCurrentTargetAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-target", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentTarget, "Set the Value of on CurrentTarget.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentTarget");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentTarget, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentTarget;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentTarget(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTargetNavigatorCurrentTargetAttributeCommand * command =
            reinterpret_cast<SetTargetNavigatorCurrentTargetAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TargetNavigator::Attributes::CurrentTarget::Set(command->mEndPointId, command->currentTarget);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentTarget");
        }
    }
};
class SetTargetNavigatorFeatureMapAttributeCommand : public Command
{
public:
    SetTargetNavigatorFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTargetNavigatorFeatureMapAttributeCommand * command =
            reinterpret_cast<SetTargetNavigatorFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TargetNavigator::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetTargetNavigatorClusterRevisionAttributeCommand : public Command
{
public:
    SetTargetNavigatorClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetTargetNavigatorClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetTargetNavigatorClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::TargetNavigator::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetMediaPlaybackCurrentStateAttributeCommand : public Command
{
public:
    SetMediaPlaybackCurrentStateAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-state", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentState, "Set the Value of on CurrentState.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentState");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentState, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::MediaPlayback::PlaybackStateEnum currentState;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentState(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackCurrentStateAttributeCommand * command =
            reinterpret_cast<SetMediaPlaybackCurrentStateAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::CurrentState::Set(command->mEndPointId, command->currentState);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentState");
        }
    }
};
class SetMediaPlaybackStartTimeAttributeCommand : public Command
{
public:
    SetMediaPlaybackStartTimeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "start-time", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &startTime, "Set the Value of on StartTime.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: StartTime");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStartTime, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> startTime;
    chip::EndpointId mEndPointId;

private:
    static void SetStartTime(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackStartTimeAttributeCommand * command =
            reinterpret_cast<SetMediaPlaybackStartTimeAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::StartTime::Set(command->mEndPointId, command->startTime);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute StartTime");
        }
    }
};
class SetMediaPlaybackDurationAttributeCommand : public Command
{
public:
    SetMediaPlaybackDurationAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "duration", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &duration, "Set the Value of on Duration.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Duration");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDuration, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> duration;
    chip::EndpointId mEndPointId;

private:
    static void SetDuration(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackDurationAttributeCommand * command = reinterpret_cast<SetMediaPlaybackDurationAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::Duration::Set(command->mEndPointId, command->duration);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Duration");
        }
    }
};
class SetMediaPlaybackPlaybackSpeedAttributeCommand : public Command
{
public:
    SetMediaPlaybackPlaybackSpeedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "playback-speed", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(),
                    &playbackSpeed, "Set the Value of on PlaybackSpeed.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PlaybackSpeed");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPlaybackSpeed, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    float playbackSpeed;
    chip::EndpointId mEndPointId;

private:
    static void SetPlaybackSpeed(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackPlaybackSpeedAttributeCommand * command =
            reinterpret_cast<SetMediaPlaybackPlaybackSpeedAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::PlaybackSpeed::Set(command->mEndPointId, command->playbackSpeed);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PlaybackSpeed");
        }
    }
};
class SetMediaPlaybackSeekRangeEndAttributeCommand : public Command
{
public:
    SetMediaPlaybackSeekRangeEndAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "seek-range-end", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &seekRangeEnd, "Set the Value of on SeekRangeEnd.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SeekRangeEnd");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSeekRangeEnd, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> seekRangeEnd;
    chip::EndpointId mEndPointId;

private:
    static void SetSeekRangeEnd(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackSeekRangeEndAttributeCommand * command =
            reinterpret_cast<SetMediaPlaybackSeekRangeEndAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::SeekRangeEnd::Set(command->mEndPointId, command->seekRangeEnd);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SeekRangeEnd");
        }
    }
};
class SetMediaPlaybackSeekRangeStartAttributeCommand : public Command
{
public:
    SetMediaPlaybackSeekRangeStartAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "seek-range-start", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &seekRangeStart, "Set the Value of on SeekRangeStart.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SeekRangeStart");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSeekRangeStart, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> seekRangeStart;
    chip::EndpointId mEndPointId;

private:
    static void SetSeekRangeStart(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackSeekRangeStartAttributeCommand * command =
            reinterpret_cast<SetMediaPlaybackSeekRangeStartAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::SeekRangeStart::Set(command->mEndPointId, command->seekRangeStart);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SeekRangeStart");
        }
    }
};
class SetMediaPlaybackFeatureMapAttributeCommand : public Command
{
public:
    SetMediaPlaybackFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackFeatureMapAttributeCommand * command =
            reinterpret_cast<SetMediaPlaybackFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetMediaPlaybackClusterRevisionAttributeCommand : public Command
{
public:
    SetMediaPlaybackClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaPlaybackClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetMediaPlaybackClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaPlayback::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetMediaInputCurrentInputAttributeCommand : public Command
{
public:
    SetMediaInputCurrentInputAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-input", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentInput, "Set the Value of on CurrentInput.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentInput");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentInput, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentInput;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentInput(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaInputCurrentInputAttributeCommand * command =
            reinterpret_cast<SetMediaInputCurrentInputAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaInput::Attributes::CurrentInput::Set(command->mEndPointId, command->currentInput);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentInput");
        }
    }
};
class SetMediaInputFeatureMapAttributeCommand : public Command
{
public:
    SetMediaInputFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaInputFeatureMapAttributeCommand * command = reinterpret_cast<SetMediaInputFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaInput::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetMediaInputClusterRevisionAttributeCommand : public Command
{
public:
    SetMediaInputClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetMediaInputClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetMediaInputClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::MediaInput::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetLowPowerFeatureMapAttributeCommand : public Command
{
public:
    SetLowPowerFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLowPowerFeatureMapAttributeCommand * command = reinterpret_cast<SetLowPowerFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LowPower::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetLowPowerClusterRevisionAttributeCommand : public Command
{
public:
    SetLowPowerClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetLowPowerClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetLowPowerClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::LowPower::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetKeypadInputFeatureMapAttributeCommand : public Command
{
public:
    SetKeypadInputFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetKeypadInputFeatureMapAttributeCommand * command = reinterpret_cast<SetKeypadInputFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::KeypadInput::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetKeypadInputClusterRevisionAttributeCommand : public Command
{
public:
    SetKeypadInputClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetKeypadInputClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetKeypadInputClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::KeypadInput::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetContentLauncherSupportedStreamingProtocolsAttributeCommand : public Command
{
public:
    SetContentLauncherSupportedStreamingProtocolsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "supported-streaming-protocols", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &supportedStreamingProtocols,
                    "Set the Value of on SupportedStreamingProtocols.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: SupportedStreamingProtocols");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetSupportedStreamingProtocols, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t supportedStreamingProtocols;
    chip::EndpointId mEndPointId;

private:
    static void SetSupportedStreamingProtocols(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetContentLauncherSupportedStreamingProtocolsAttributeCommand * command =
            reinterpret_cast<SetContentLauncherSupportedStreamingProtocolsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ContentLauncher::Attributes::SupportedStreamingProtocols::Set(
            command->mEndPointId, command->supportedStreamingProtocols);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute SupportedStreamingProtocols");
        }
    }
};
class SetContentLauncherFeatureMapAttributeCommand : public Command
{
public:
    SetContentLauncherFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetContentLauncherFeatureMapAttributeCommand * command =
            reinterpret_cast<SetContentLauncherFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ContentLauncher::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetContentLauncherClusterRevisionAttributeCommand : public Command
{
public:
    SetContentLauncherClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetContentLauncherClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetContentLauncherClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ContentLauncher::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetAudioOutputCurrentOutputAttributeCommand : public Command
{
public:
    SetAudioOutputCurrentOutputAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-output", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &currentOutput, "Set the Value of on CurrentOutput.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentOutput");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentOutput, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t currentOutput;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentOutput(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAudioOutputCurrentOutputAttributeCommand * command =
            reinterpret_cast<SetAudioOutputCurrentOutputAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AudioOutput::Attributes::CurrentOutput::Set(command->mEndPointId, command->currentOutput);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentOutput");
        }
    }
};
class SetAudioOutputFeatureMapAttributeCommand : public Command
{
public:
    SetAudioOutputFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAudioOutputFeatureMapAttributeCommand * command = reinterpret_cast<SetAudioOutputFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AudioOutput::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetAudioOutputClusterRevisionAttributeCommand : public Command
{
public:
    SetAudioOutputClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAudioOutputClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetAudioOutputClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AudioOutput::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetApplicationLauncherFeatureMapAttributeCommand : public Command
{
public:
    SetApplicationLauncherFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationLauncherFeatureMapAttributeCommand * command =
            reinterpret_cast<SetApplicationLauncherFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationLauncher::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetApplicationLauncherClusterRevisionAttributeCommand : public Command
{
public:
    SetApplicationLauncherClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationLauncherClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetApplicationLauncherClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ApplicationLauncher::Attributes::ClusterRevision::Set(command->mEndPointId,
                                                                                                          command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetApplicationBasicVendorNameAttributeCommand : public Command
{
public:
    SetApplicationBasicVendorNameAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "vendor-name", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &vendorName, "Set the Value of on VendorName.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VendorName");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVendorName, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan vendorName;
    chip::EndpointId mEndPointId;

private:
    static void SetVendorName(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicVendorNameAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicVendorNameAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationBasic::Attributes::VendorName::Set(command->mEndPointId, command->vendorName);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VendorName");
        }
    }
};
class SetApplicationBasicVendorIDAttributeCommand : public Command
{
public:
    SetApplicationBasicVendorIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "vendor-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &vendorID, "Set the Value of on VendorID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VendorID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVendorID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::VendorId vendorID;
    chip::EndpointId mEndPointId;

private:
    static void SetVendorID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicVendorIDAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicVendorIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationBasic::Attributes::VendorID::Set(command->mEndPointId, command->vendorID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VendorID");
        }
    }
};
class SetApplicationBasicApplicationNameAttributeCommand : public Command
{
public:
    SetApplicationBasicApplicationNameAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "application-name", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &applicationName, "Set the Value of on ApplicationName.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ApplicationName");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetApplicationName, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan applicationName;
    chip::EndpointId mEndPointId;

private:
    static void SetApplicationName(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicApplicationNameAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicApplicationNameAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationBasic::Attributes::ApplicationName::Set(command->mEndPointId, command->applicationName);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ApplicationName");
        }
    }
};
class SetApplicationBasicProductIDAttributeCommand : public Command
{
public:
    SetApplicationBasicProductIDAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "product-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &productID, "Set the Value of on ProductID.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ProductID");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetProductID, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t productID;
    chip::EndpointId mEndPointId;

private:
    static void SetProductID(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicProductIDAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicProductIDAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationBasic::Attributes::ProductID::Set(command->mEndPointId, command->productID);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ProductID");
        }
    }
};
class SetApplicationBasicStatusAttributeCommand : public Command
{
public:
    SetApplicationBasicStatusAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "status", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &status, "Set the Value of on Status.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Status");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetStatus, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum status;
    chip::EndpointId mEndPointId;

private:
    static void SetStatus(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicStatusAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicStatusAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationBasic::Attributes::Status::Set(command->mEndPointId, command->status);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Status");
        }
    }
};
class SetApplicationBasicApplicationVersionAttributeCommand : public Command
{
public:
    SetApplicationBasicApplicationVersionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "application-version", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &applicationVersion, "Set the Value of on ApplicationVersion.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ApplicationVersion");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetApplicationVersion, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan applicationVersion;
    chip::EndpointId mEndPointId;

private:
    static void SetApplicationVersion(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicApplicationVersionAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicApplicationVersionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ApplicationBasic::Attributes::ApplicationVersion::Set(
            command->mEndPointId, command->applicationVersion);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ApplicationVersion");
        }
    }
};
class SetApplicationBasicFeatureMapAttributeCommand : public Command
{
public:
    SetApplicationBasicFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicFeatureMapAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationBasic::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetApplicationBasicClusterRevisionAttributeCommand : public Command
{
public:
    SetApplicationBasicClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetApplicationBasicClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetApplicationBasicClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ApplicationBasic::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetAccountLoginFeatureMapAttributeCommand : public Command
{
public:
    SetAccountLoginFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAccountLoginFeatureMapAttributeCommand * command =
            reinterpret_cast<SetAccountLoginFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AccountLogin::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetAccountLoginClusterRevisionAttributeCommand : public Command
{
public:
    SetAccountLoginClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetAccountLoginClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetAccountLoginClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::AccountLogin::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetElectricalMeasurementMeasurementTypeAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasurementTypeAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measurement-type", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &measurementType, "Set the Value of on MeasurementType.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasurementType");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasurementType, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t measurementType;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasurementType(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasurementTypeAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasurementTypeAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::MeasurementType::Set(
            command->mEndPointId, command->measurementType);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasurementType");
        }
    }
};
class SetElectricalMeasurementDcVoltageAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcVoltage, "Set the Value of on DcVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetDcVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcVoltageAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcVoltageAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcVoltage::Set(command->mEndPointId, command->dcVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcVoltage");
        }
    }
};
class SetElectricalMeasurementDcVoltageMinAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcVoltageMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-voltage-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcVoltageMin, "Set the Value of on DcVoltageMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcVoltageMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcVoltageMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcVoltageMin;
    chip::EndpointId mEndPointId;

private:
    static void SetDcVoltageMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcVoltageMinAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcVoltageMinAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcVoltageMin::Set(command->mEndPointId, command->dcVoltageMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcVoltageMin");
        }
    }
};
class SetElectricalMeasurementDcVoltageMaxAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcVoltageMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-voltage-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcVoltageMax, "Set the Value of on DcVoltageMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcVoltageMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcVoltageMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcVoltageMax;
    chip::EndpointId mEndPointId;

private:
    static void SetDcVoltageMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcVoltageMaxAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcVoltageMaxAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcVoltageMax::Set(command->mEndPointId, command->dcVoltageMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcVoltageMax");
        }
    }
};
class SetElectricalMeasurementDcCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcCurrent, "Set the Value of on DcCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetDcCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcCurrentAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcCurrent::Set(command->mEndPointId, command->dcCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcCurrent");
        }
    }
};
class SetElectricalMeasurementDcCurrentMinAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcCurrentMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-current-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcCurrentMin, "Set the Value of on DcCurrentMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcCurrentMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcCurrentMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcCurrentMin;
    chip::EndpointId mEndPointId;

private:
    static void SetDcCurrentMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcCurrentMinAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcCurrentMinAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcCurrentMin::Set(command->mEndPointId, command->dcCurrentMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcCurrentMin");
        }
    }
};
class SetElectricalMeasurementDcCurrentMaxAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcCurrentMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-current-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcCurrentMax, "Set the Value of on DcCurrentMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcCurrentMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcCurrentMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcCurrentMax;
    chip::EndpointId mEndPointId;

private:
    static void SetDcCurrentMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcCurrentMaxAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcCurrentMaxAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcCurrentMax::Set(command->mEndPointId, command->dcCurrentMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcCurrentMax");
        }
    }
};
class SetElectricalMeasurementDcPowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcPowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcPower, "Set the Value of on DcPower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcPower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcPower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcPower;
    chip::EndpointId mEndPointId;

private:
    static void SetDcPower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcPowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcPowerAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcPower::Set(command->mEndPointId, command->dcPower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcPower");
        }
    }
};
class SetElectricalMeasurementDcPowerMinAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcPowerMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-power-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcPowerMin, "Set the Value of on DcPowerMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcPowerMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcPowerMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcPowerMin;
    chip::EndpointId mEndPointId;

private:
    static void SetDcPowerMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcPowerMinAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcPowerMinAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcPowerMin::Set(command->mEndPointId, command->dcPowerMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcPowerMin");
        }
    }
};
class SetElectricalMeasurementDcPowerMaxAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcPowerMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-power-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &dcPowerMax, "Set the Value of on DcPowerMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcPowerMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcPowerMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t dcPowerMax;
    chip::EndpointId mEndPointId;

private:
    static void SetDcPowerMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcPowerMaxAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcPowerMaxAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::DcPowerMax::Set(command->mEndPointId, command->dcPowerMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcPowerMax");
        }
    }
};
class SetElectricalMeasurementDcVoltageMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcVoltageMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-voltage-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &dcVoltageMultiplier, "Set the Value of on DcVoltageMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcVoltageMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcVoltageMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t dcVoltageMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetDcVoltageMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcVoltageMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcVoltageMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::DcVoltageMultiplier::Set(
            command->mEndPointId, command->dcVoltageMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcVoltageMultiplier");
        }
    }
};
class SetElectricalMeasurementDcVoltageDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcVoltageDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-voltage-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &dcVoltageDivisor, "Set the Value of on DcVoltageDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcVoltageDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcVoltageDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t dcVoltageDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetDcVoltageDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcVoltageDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcVoltageDivisorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::DcVoltageDivisor::Set(
            command->mEndPointId, command->dcVoltageDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcVoltageDivisor");
        }
    }
};
class SetElectricalMeasurementDcCurrentMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcCurrentMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-current-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &dcCurrentMultiplier, "Set the Value of on DcCurrentMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcCurrentMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcCurrentMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t dcCurrentMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetDcCurrentMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcCurrentMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcCurrentMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::DcCurrentMultiplier::Set(
            command->mEndPointId, command->dcCurrentMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcCurrentMultiplier");
        }
    }
};
class SetElectricalMeasurementDcCurrentDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcCurrentDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-current-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &dcCurrentDivisor, "Set the Value of on DcCurrentDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcCurrentDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcCurrentDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t dcCurrentDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetDcCurrentDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcCurrentDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcCurrentDivisorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::DcCurrentDivisor::Set(
            command->mEndPointId, command->dcCurrentDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcCurrentDivisor");
        }
    }
};
class SetElectricalMeasurementDcPowerMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcPowerMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-power-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &dcPowerMultiplier, "Set the Value of on DcPowerMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcPowerMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcPowerMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t dcPowerMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetDcPowerMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcPowerMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcPowerMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::DcPowerMultiplier::Set(
            command->mEndPointId, command->dcPowerMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcPowerMultiplier");
        }
    }
};
class SetElectricalMeasurementDcPowerDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementDcPowerDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "dc-power-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &dcPowerDivisor, "Set the Value of on DcPowerDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: DcPowerDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetDcPowerDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t dcPowerDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetDcPowerDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementDcPowerDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementDcPowerDivisorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::DcPowerDivisor::Set(command->mEndPointId,
                                                                                                           command->dcPowerDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute DcPowerDivisor");
        }
    }
};
class SetElectricalMeasurementAcFrequencyAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcFrequencyAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-frequency", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acFrequency, "Set the Value of on AcFrequency.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcFrequency");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcFrequency, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acFrequency;
    chip::EndpointId mEndPointId;

private:
    static void SetAcFrequency(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcFrequencyAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcFrequencyAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::AcFrequency::Set(command->mEndPointId, command->acFrequency);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcFrequency");
        }
    }
};
class SetElectricalMeasurementAcFrequencyMinAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcFrequencyMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-frequency-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acFrequencyMin, "Set the Value of on AcFrequencyMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcFrequencyMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcFrequencyMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acFrequencyMin;
    chip::EndpointId mEndPointId;

private:
    static void SetAcFrequencyMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcFrequencyMinAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcFrequencyMinAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcFrequencyMin::Set(command->mEndPointId,
                                                                                                           command->acFrequencyMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcFrequencyMin");
        }
    }
};
class SetElectricalMeasurementAcFrequencyMaxAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcFrequencyMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-frequency-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acFrequencyMax, "Set the Value of on AcFrequencyMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcFrequencyMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcFrequencyMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acFrequencyMax;
    chip::EndpointId mEndPointId;

private:
    static void SetAcFrequencyMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcFrequencyMaxAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcFrequencyMaxAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcFrequencyMax::Set(command->mEndPointId,
                                                                                                           command->acFrequencyMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcFrequencyMax");
        }
    }
};
class SetElectricalMeasurementNeutralCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementNeutralCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "neutral-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &neutralCurrent, "Set the Value of on NeutralCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NeutralCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNeutralCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t neutralCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetNeutralCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementNeutralCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementNeutralCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::NeutralCurrent::Set(command->mEndPointId,
                                                                                                           command->neutralCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NeutralCurrent");
        }
    }
};
class SetElectricalMeasurementTotalActivePowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementTotalActivePowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "total-active-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT32_MIN, INT32_MAX, &totalActivePower, "Set the Value of on TotalActivePower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TotalActivePower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTotalActivePower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int32_t totalActivePower;
    chip::EndpointId mEndPointId;

private:
    static void SetTotalActivePower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementTotalActivePowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementTotalActivePowerAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::TotalActivePower::Set(
            command->mEndPointId, command->totalActivePower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TotalActivePower");
        }
    }
};
class SetElectricalMeasurementTotalReactivePowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementTotalReactivePowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "total-reactive-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT32_MIN, INT32_MAX, &totalReactivePower, "Set the Value of on TotalReactivePower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TotalReactivePower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTotalReactivePower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int32_t totalReactivePower;
    chip::EndpointId mEndPointId;

private:
    static void SetTotalReactivePower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementTotalReactivePowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementTotalReactivePowerAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::TotalReactivePower::Set(
            command->mEndPointId, command->totalReactivePower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TotalReactivePower");
        }
    }
};
class SetElectricalMeasurementTotalApparentPowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementTotalApparentPowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "total-apparent-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &totalApparentPower, "Set the Value of on TotalApparentPower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TotalApparentPower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTotalApparentPower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t totalApparentPower;
    chip::EndpointId mEndPointId;

private:
    static void SetTotalApparentPower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementTotalApparentPowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementTotalApparentPowerAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::TotalApparentPower::Set(
            command->mEndPointId, command->totalApparentPower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TotalApparentPower");
        }
    }
};
class SetElectricalMeasurementMeasured1stHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasured1stHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured1st-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measured1stHarmonicCurrent,
                    "Set the Value of on Measured1stHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Measured1stHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasured1stHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measured1stHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasured1stHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasured1stHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasured1stHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::Measured1stHarmonicCurrent::Set(
            command->mEndPointId, command->measured1stHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Measured1stHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasured3rdHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasured3rdHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured3rd-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measured3rdHarmonicCurrent,
                    "Set the Value of on Measured3rdHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Measured3rdHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasured3rdHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measured3rdHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasured3rdHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasured3rdHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasured3rdHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::Measured3rdHarmonicCurrent::Set(
            command->mEndPointId, command->measured3rdHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Measured3rdHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasured5thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasured5thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured5th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measured5thHarmonicCurrent,
                    "Set the Value of on Measured5thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Measured5thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasured5thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measured5thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasured5thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasured5thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasured5thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::Measured5thHarmonicCurrent::Set(
            command->mEndPointId, command->measured5thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Measured5thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasured7thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasured7thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured7th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measured7thHarmonicCurrent,
                    "Set the Value of on Measured7thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Measured7thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasured7thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measured7thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasured7thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasured7thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasured7thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::Measured7thHarmonicCurrent::Set(
            command->mEndPointId, command->measured7thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Measured7thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasured9thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasured9thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured9th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measured9thHarmonicCurrent,
                    "Set the Value of on Measured9thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Measured9thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasured9thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measured9thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasured9thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasured9thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasured9thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::Measured9thHarmonicCurrent::Set(
            command->mEndPointId, command->measured9thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Measured9thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasured11thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasured11thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured11th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measured11thHarmonicCurrent,
                    "Set the Value of on Measured11thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Measured11thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasured11thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measured11thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasured11thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasured11thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasured11thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::Measured11thHarmonicCurrent::Set(
            command->mEndPointId, command->measured11thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Measured11thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasuredPhase1stHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasuredPhase1stHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-phase1st-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredPhase1stHarmonicCurrent,
                    "Set the Value of on MeasuredPhase1stHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredPhase1stHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredPhase1stHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measuredPhase1stHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredPhase1stHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasuredPhase1stHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasuredPhase1stHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::MeasuredPhase1stHarmonicCurrent::Set(
            command->mEndPointId, command->measuredPhase1stHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredPhase1stHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasuredPhase3rdHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasuredPhase3rdHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-phase3rd-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredPhase3rdHarmonicCurrent,
                    "Set the Value of on MeasuredPhase3rdHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredPhase3rdHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredPhase3rdHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measuredPhase3rdHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredPhase3rdHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasuredPhase3rdHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasuredPhase3rdHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::MeasuredPhase3rdHarmonicCurrent::Set(
            command->mEndPointId, command->measuredPhase3rdHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredPhase3rdHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasuredPhase5thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasuredPhase5thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-phase5th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredPhase5thHarmonicCurrent,
                    "Set the Value of on MeasuredPhase5thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredPhase5thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredPhase5thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measuredPhase5thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredPhase5thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasuredPhase5thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasuredPhase5thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::MeasuredPhase5thHarmonicCurrent::Set(
            command->mEndPointId, command->measuredPhase5thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredPhase5thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasuredPhase7thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasuredPhase7thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-phase7th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredPhase7thHarmonicCurrent,
                    "Set the Value of on MeasuredPhase7thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredPhase7thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredPhase7thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measuredPhase7thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredPhase7thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasuredPhase7thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasuredPhase7thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::MeasuredPhase7thHarmonicCurrent::Set(
            command->mEndPointId, command->measuredPhase7thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredPhase7thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasuredPhase9thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasuredPhase9thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-phase9th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredPhase9thHarmonicCurrent,
                    "Set the Value of on MeasuredPhase9thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredPhase9thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredPhase9thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measuredPhase9thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredPhase9thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasuredPhase9thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasuredPhase9thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::MeasuredPhase9thHarmonicCurrent::Set(
            command->mEndPointId, command->measuredPhase9thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredPhase9thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementMeasuredPhase11thHarmonicCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementMeasuredPhase11thHarmonicCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "measured-phase11th-harmonic-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &measuredPhase11thHarmonicCurrent,
                    "Set the Value of on MeasuredPhase11thHarmonicCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: MeasuredPhase11thHarmonicCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetMeasuredPhase11thHarmonicCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t measuredPhase11thHarmonicCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetMeasuredPhase11thHarmonicCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementMeasuredPhase11thHarmonicCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementMeasuredPhase11thHarmonicCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::MeasuredPhase11thHarmonicCurrent::Set(
            command->mEndPointId, command->measuredPhase11thHarmonicCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute MeasuredPhase11thHarmonicCurrent");
        }
    }
};
class SetElectricalMeasurementAcFrequencyMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcFrequencyMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-frequency-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acFrequencyMultiplier, "Set the Value of on AcFrequencyMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcFrequencyMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcFrequencyMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acFrequencyMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetAcFrequencyMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcFrequencyMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcFrequencyMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcFrequencyMultiplier::Set(
            command->mEndPointId, command->acFrequencyMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcFrequencyMultiplier");
        }
    }
};
class SetElectricalMeasurementAcFrequencyDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcFrequencyDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-frequency-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acFrequencyDivisor, "Set the Value of on AcFrequencyDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcFrequencyDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcFrequencyDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acFrequencyDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetAcFrequencyDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcFrequencyDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcFrequencyDivisorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcFrequencyDivisor::Set(
            command->mEndPointId, command->acFrequencyDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcFrequencyDivisor");
        }
    }
};
class SetElectricalMeasurementPowerMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementPowerMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "power-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &powerMultiplier, "Set the Value of on PowerMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PowerMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPowerMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t powerMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetPowerMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementPowerMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementPowerMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::PowerMultiplier::Set(
            command->mEndPointId, command->powerMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PowerMultiplier");
        }
    }
};
class SetElectricalMeasurementPowerDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementPowerDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "power-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &powerDivisor, "Set the Value of on PowerDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PowerDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPowerDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t powerDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetPowerDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementPowerDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementPowerDivisorAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::PowerDivisor::Set(command->mEndPointId, command->powerDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PowerDivisor");
        }
    }
};
class SetElectricalMeasurementHarmonicCurrentMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementHarmonicCurrentMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "harmonic-current-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &harmonicCurrentMultiplier,
                    "Set the Value of on HarmonicCurrentMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: HarmonicCurrentMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetHarmonicCurrentMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t harmonicCurrentMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetHarmonicCurrentMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementHarmonicCurrentMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementHarmonicCurrentMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::HarmonicCurrentMultiplier::Set(
            command->mEndPointId, command->harmonicCurrentMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute HarmonicCurrentMultiplier");
        }
    }
};
class SetElectricalMeasurementPhaseHarmonicCurrentMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementPhaseHarmonicCurrentMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "phase-harmonic-current-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &phaseHarmonicCurrentMultiplier,
                    "Set the Value of on PhaseHarmonicCurrentMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PhaseHarmonicCurrentMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPhaseHarmonicCurrentMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t phaseHarmonicCurrentMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetPhaseHarmonicCurrentMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementPhaseHarmonicCurrentMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementPhaseHarmonicCurrentMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::PhaseHarmonicCurrentMultiplier::Set(
            command->mEndPointId, command->phaseHarmonicCurrentMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PhaseHarmonicCurrentMultiplier");
        }
    }
};
class SetElectricalMeasurementInstantaneousVoltageAttributeCommand : public Command
{
public:
    SetElectricalMeasurementInstantaneousVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "instantaneous-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &instantaneousVoltage, "Set the Value of on InstantaneousVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstantaneousVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstantaneousVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t instantaneousVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetInstantaneousVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementInstantaneousVoltageAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementInstantaneousVoltageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::InstantaneousVoltage::Set(
            command->mEndPointId, command->instantaneousVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstantaneousVoltage");
        }
    }
};
class SetElectricalMeasurementInstantaneousLineCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementInstantaneousLineCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "instantaneous-line-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &instantaneousLineCurrent, "Set the Value of on InstantaneousLineCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstantaneousLineCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstantaneousLineCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t instantaneousLineCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetInstantaneousLineCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementInstantaneousLineCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementInstantaneousLineCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::InstantaneousLineCurrent::Set(
            command->mEndPointId, command->instantaneousLineCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstantaneousLineCurrent");
        }
    }
};
class SetElectricalMeasurementInstantaneousActiveCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementInstantaneousActiveCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "instantaneous-active-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &instantaneousActiveCurrent,
                    "Set the Value of on InstantaneousActiveCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstantaneousActiveCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstantaneousActiveCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t instantaneousActiveCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetInstantaneousActiveCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementInstantaneousActiveCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementInstantaneousActiveCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::InstantaneousActiveCurrent::Set(
            command->mEndPointId, command->instantaneousActiveCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstantaneousActiveCurrent");
        }
    }
};
class SetElectricalMeasurementInstantaneousReactiveCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementInstantaneousReactiveCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "instantaneous-reactive-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &instantaneousReactiveCurrent,
                    "Set the Value of on InstantaneousReactiveCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstantaneousReactiveCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstantaneousReactiveCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t instantaneousReactiveCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetInstantaneousReactiveCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementInstantaneousReactiveCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementInstantaneousReactiveCurrentAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::InstantaneousReactiveCurrent::Set(
            command->mEndPointId, command->instantaneousReactiveCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstantaneousReactiveCurrent");
        }
    }
};
class SetElectricalMeasurementInstantaneousPowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementInstantaneousPowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "instantaneous-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &instantaneousPower, "Set the Value of on InstantaneousPower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: InstantaneousPower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInstantaneousPower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t instantaneousPower;
    chip::EndpointId mEndPointId;

private:
    static void SetInstantaneousPower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementInstantaneousPowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementInstantaneousPowerAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::InstantaneousPower::Set(
            command->mEndPointId, command->instantaneousPower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute InstantaneousPower");
        }
    }
};
class SetElectricalMeasurementRmsVoltageAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltage, "Set the Value of on RmsVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltage::Set(command->mEndPointId, command->rmsVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltage");
        }
    }
};
class SetElectricalMeasurementRmsVoltageMinAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageMin, "Set the Value of on RmsVoltageMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageMin;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageMinAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageMinAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageMin::Set(command->mEndPointId,
                                                                                                          command->rmsVoltageMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageMin");
        }
    }
};
class SetElectricalMeasurementRmsVoltageMaxAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageMax, "Set the Value of on RmsVoltageMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageMax;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageMaxAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageMaxAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageMax::Set(command->mEndPointId,
                                                                                                          command->rmsVoltageMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageMax");
        }
    }
};
class SetElectricalMeasurementRmsCurrentAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrent, "Set the Value of on RmsCurrent.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrent");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrent, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrent;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrent(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrent::Set(command->mEndPointId, command->rmsCurrent);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrent");
        }
    }
};
class SetElectricalMeasurementRmsCurrentMinAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentMin, "Set the Value of on RmsCurrentMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentMin;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentMinAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentMinAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentMin::Set(command->mEndPointId,
                                                                                                          command->rmsCurrentMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentMin");
        }
    }
};
class SetElectricalMeasurementRmsCurrentMaxAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentMax, "Set the Value of on RmsCurrentMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentMax;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentMaxAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentMaxAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentMax::Set(command->mEndPointId,
                                                                                                          command->rmsCurrentMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentMax");
        }
    }
};
class SetElectricalMeasurementActivePowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePower, "Set the Value of on ActivePower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePower;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePower::Set(command->mEndPointId, command->activePower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePower");
        }
    }
};
class SetElectricalMeasurementActivePowerMinAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerMinAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-min", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerMin, "Set the Value of on ActivePowerMin.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerMin");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerMin, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerMin;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerMin(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerMinAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerMinAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerMin::Set(command->mEndPointId,
                                                                                                           command->activePowerMin);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerMin");
        }
    }
};
class SetElectricalMeasurementActivePowerMaxAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerMaxAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-max", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerMax, "Set the Value of on ActivePowerMax.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerMax");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerMax, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerMax;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerMax(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerMaxAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerMaxAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerMax::Set(command->mEndPointId,
                                                                                                           command->activePowerMax);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerMax");
        }
    }
};
class SetElectricalMeasurementReactivePowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementReactivePowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reactive-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &reactivePower, "Set the Value of on ReactivePower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ReactivePower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReactivePower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t reactivePower;
    chip::EndpointId mEndPointId;

private:
    static void SetReactivePower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementReactivePowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementReactivePowerAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ReactivePower::Set(command->mEndPointId,
                                                                                                          command->reactivePower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ReactivePower");
        }
    }
};
class SetElectricalMeasurementApparentPowerAttributeCommand : public Command
{
public:
    SetElectricalMeasurementApparentPowerAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "apparent-power", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &apparentPower, "Set the Value of on ApparentPower.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ApparentPower");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetApparentPower, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t apparentPower;
    chip::EndpointId mEndPointId;

private:
    static void SetApparentPower(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementApparentPowerAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementApparentPowerAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ApparentPower::Set(command->mEndPointId,
                                                                                                          command->apparentPower);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ApparentPower");
        }
    }
};
class SetElectricalMeasurementPowerFactorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementPowerFactorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "power-factor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &powerFactor, "Set the Value of on PowerFactor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PowerFactor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPowerFactor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t powerFactor;
    chip::EndpointId mEndPointId;

private:
    static void SetPowerFactor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementPowerFactorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementPowerFactorAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::PowerFactor::Set(command->mEndPointId, command->powerFactor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PowerFactor");
        }
    }
};
class SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-voltage-measurement-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsVoltageMeasurementPeriod,
                    "Set the Value of on AverageRmsVoltageMeasurementPeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsVoltageMeasurementPeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsVoltageMeasurementPeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsVoltageMeasurementPeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsVoltageMeasurementPeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsVoltageMeasurementPeriod::Set(
            command->mEndPointId, command->averageRmsVoltageMeasurementPeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsVoltageMeasurementPeriod");
        }
    }
};
class SetElectricalMeasurementAverageRmsUnderVoltageCounterAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsUnderVoltageCounterAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-under-voltage-counter", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsUnderVoltageCounter,
                    "Set the Value of on AverageRmsUnderVoltageCounter.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsUnderVoltageCounter");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsUnderVoltageCounter, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsUnderVoltageCounter;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsUnderVoltageCounter(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsUnderVoltageCounterAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsUnderVoltageCounterAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsUnderVoltageCounter::Set(
            command->mEndPointId, command->averageRmsUnderVoltageCounter);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsUnderVoltageCounter");
        }
    }
};
class SetElectricalMeasurementRmsExtremeOverVoltagePeriodAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeOverVoltagePeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-over-voltage-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsExtremeOverVoltagePeriod,
                    "Set the Value of on RmsExtremeOverVoltagePeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeOverVoltagePeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeOverVoltagePeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsExtremeOverVoltagePeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeOverVoltagePeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeOverVoltagePeriodAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeOverVoltagePeriodAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeOverVoltagePeriod::Set(
            command->mEndPointId, command->rmsExtremeOverVoltagePeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeOverVoltagePeriod");
        }
    }
};
class SetElectricalMeasurementRmsExtremeUnderVoltagePeriodAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeUnderVoltagePeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-under-voltage-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsExtremeUnderVoltagePeriod,
                    "Set the Value of on RmsExtremeUnderVoltagePeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeUnderVoltagePeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeUnderVoltagePeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsExtremeUnderVoltagePeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeUnderVoltagePeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeUnderVoltagePeriodAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeUnderVoltagePeriodAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeUnderVoltagePeriod::Set(
            command->mEndPointId, command->rmsExtremeUnderVoltagePeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeUnderVoltagePeriod");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSagPeriodAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSagPeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-sag-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageSagPeriod, "Set the Value of on RmsVoltageSagPeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSagPeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSagPeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageSagPeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSagPeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSagPeriodAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSagPeriodAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSagPeriod::Set(
            command->mEndPointId, command->rmsVoltageSagPeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSagPeriod");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSwellPeriodAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSwellPeriodAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-swell-period", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageSwellPeriod, "Set the Value of on RmsVoltageSwellPeriod.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSwellPeriod");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSwellPeriod, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageSwellPeriod;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSwellPeriod(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSwellPeriodAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSwellPeriodAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSwellPeriod::Set(
            command->mEndPointId, command->rmsVoltageSwellPeriod);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSwellPeriod");
        }
    }
};
class SetElectricalMeasurementAcVoltageMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcVoltageMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-voltage-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acVoltageMultiplier, "Set the Value of on AcVoltageMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcVoltageMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcVoltageMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acVoltageMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetAcVoltageMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcVoltageMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcVoltageMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcVoltageMultiplier::Set(
            command->mEndPointId, command->acVoltageMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcVoltageMultiplier");
        }
    }
};
class SetElectricalMeasurementAcVoltageDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcVoltageDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-voltage-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acVoltageDivisor, "Set the Value of on AcVoltageDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcVoltageDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcVoltageDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acVoltageDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetAcVoltageDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcVoltageDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcVoltageDivisorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcVoltageDivisor::Set(
            command->mEndPointId, command->acVoltageDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcVoltageDivisor");
        }
    }
};
class SetElectricalMeasurementAcCurrentMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcCurrentMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-current-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acCurrentMultiplier, "Set the Value of on AcCurrentMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcCurrentMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcCurrentMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acCurrentMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetAcCurrentMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcCurrentMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcCurrentMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcCurrentMultiplier::Set(
            command->mEndPointId, command->acCurrentMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcCurrentMultiplier");
        }
    }
};
class SetElectricalMeasurementAcCurrentDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcCurrentDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-current-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acCurrentDivisor, "Set the Value of on AcCurrentDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcCurrentDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcCurrentDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acCurrentDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetAcCurrentDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcCurrentDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcCurrentDivisorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcCurrentDivisor::Set(
            command->mEndPointId, command->acCurrentDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcCurrentDivisor");
        }
    }
};
class SetElectricalMeasurementAcPowerMultiplierAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcPowerMultiplierAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-power-multiplier", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acPowerMultiplier, "Set the Value of on AcPowerMultiplier.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcPowerMultiplier");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcPowerMultiplier, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acPowerMultiplier;
    chip::EndpointId mEndPointId;

private:
    static void SetAcPowerMultiplier(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcPowerMultiplierAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcPowerMultiplierAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcPowerMultiplier::Set(
            command->mEndPointId, command->acPowerMultiplier);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcPowerMultiplier");
        }
    }
};
class SetElectricalMeasurementAcPowerDivisorAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcPowerDivisorAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-power-divisor", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acPowerDivisor, "Set the Value of on AcPowerDivisor.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcPowerDivisor");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcPowerDivisor, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acPowerDivisor;
    chip::EndpointId mEndPointId;

private:
    static void SetAcPowerDivisor(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcPowerDivisorAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcPowerDivisorAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcPowerDivisor::Set(command->mEndPointId,
                                                                                                           command->acPowerDivisor);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcPowerDivisor");
        }
    }
};
class SetElectricalMeasurementOverloadAlarmsMaskAttributeCommand : public Command
{
public:
    SetElectricalMeasurementOverloadAlarmsMaskAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "overload-alarms-mask", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &overloadAlarmsMask, "Set the Value of on OverloadAlarmsMask.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OverloadAlarmsMask");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOverloadAlarmsMask, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t overloadAlarmsMask;
    chip::EndpointId mEndPointId;

private:
    static void SetOverloadAlarmsMask(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementOverloadAlarmsMaskAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementOverloadAlarmsMaskAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::OverloadAlarmsMask::Set(
            command->mEndPointId, command->overloadAlarmsMask);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OverloadAlarmsMask");
        }
    }
};
class SetElectricalMeasurementVoltageOverloadAttributeCommand : public Command
{
public:
    SetElectricalMeasurementVoltageOverloadAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "voltage-overload", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &voltageOverload, "Set the Value of on VoltageOverload.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VoltageOverload");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVoltageOverload, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t voltageOverload;
    chip::EndpointId mEndPointId;

private:
    static void SetVoltageOverload(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementVoltageOverloadAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementVoltageOverloadAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::VoltageOverload::Set(
            command->mEndPointId, command->voltageOverload);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VoltageOverload");
        }
    }
};
class SetElectricalMeasurementCurrentOverloadAttributeCommand : public Command
{
public:
    SetElectricalMeasurementCurrentOverloadAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "current-overload", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &currentOverload, "Set the Value of on CurrentOverload.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CurrentOverload");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCurrentOverload, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t currentOverload;
    chip::EndpointId mEndPointId;

private:
    static void SetCurrentOverload(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementCurrentOverloadAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementCurrentOverloadAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::CurrentOverload::Set(
            command->mEndPointId, command->currentOverload);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CurrentOverload");
        }
    }
};
class SetElectricalMeasurementAcOverloadAlarmsMaskAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcOverloadAlarmsMaskAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-overload-alarms-mask", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &acOverloadAlarmsMask, "Set the Value of on AcOverloadAlarmsMask.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcOverloadAlarmsMask");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcOverloadAlarmsMask, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t acOverloadAlarmsMask;
    chip::EndpointId mEndPointId;

private:
    static void SetAcOverloadAlarmsMask(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcOverloadAlarmsMaskAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcOverloadAlarmsMaskAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcOverloadAlarmsMask::Set(
            command->mEndPointId, command->acOverloadAlarmsMask);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcOverloadAlarmsMask");
        }
    }
};
class SetElectricalMeasurementAcVoltageOverloadAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcVoltageOverloadAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-voltage-overload", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &acVoltageOverload, "Set the Value of on AcVoltageOverload.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcVoltageOverload");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcVoltageOverload, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t acVoltageOverload;
    chip::EndpointId mEndPointId;

private:
    static void SetAcVoltageOverload(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcVoltageOverloadAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcVoltageOverloadAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcVoltageOverload::Set(
            command->mEndPointId, command->acVoltageOverload);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcVoltageOverload");
        }
    }
};
class SetElectricalMeasurementAcCurrentOverloadAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcCurrentOverloadAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-current-overload", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &acCurrentOverload, "Set the Value of on AcCurrentOverload.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcCurrentOverload");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcCurrentOverload, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t acCurrentOverload;
    chip::EndpointId mEndPointId;

private:
    static void SetAcCurrentOverload(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcCurrentOverloadAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcCurrentOverloadAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcCurrentOverload::Set(
            command->mEndPointId, command->acCurrentOverload);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcCurrentOverload");
        }
    }
};
class SetElectricalMeasurementAcActivePowerOverloadAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcActivePowerOverloadAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-active-power-overload", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &acActivePowerOverload, "Set the Value of on AcActivePowerOverload.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcActivePowerOverload");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcActivePowerOverload, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t acActivePowerOverload;
    chip::EndpointId mEndPointId;

private:
    static void SetAcActivePowerOverload(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcActivePowerOverloadAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcActivePowerOverloadAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcActivePowerOverload::Set(
            command->mEndPointId, command->acActivePowerOverload);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcActivePowerOverload");
        }
    }
};
class SetElectricalMeasurementAcReactivePowerOverloadAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAcReactivePowerOverloadAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "ac-reactive-power-overload", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &acReactivePowerOverload,
                    "Set the Value of on AcReactivePowerOverload.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AcReactivePowerOverload");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAcReactivePowerOverload, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t acReactivePowerOverload;
    chip::EndpointId mEndPointId;

private:
    static void SetAcReactivePowerOverload(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAcReactivePowerOverloadAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAcReactivePowerOverloadAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AcReactivePowerOverload::Set(
            command->mEndPointId, command->acReactivePowerOverload);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AcReactivePowerOverload");
        }
    }
};
class SetElectricalMeasurementAverageRmsOverVoltageAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsOverVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-over-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &averageRmsOverVoltage, "Set the Value of on AverageRmsOverVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsOverVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsOverVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t averageRmsOverVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsOverVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsOverVoltageAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsOverVoltageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsOverVoltage::Set(
            command->mEndPointId, command->averageRmsOverVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsOverVoltage");
        }
    }
};
class SetElectricalMeasurementAverageRmsUnderVoltageAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsUnderVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-under-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &averageRmsUnderVoltage, "Set the Value of on AverageRmsUnderVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsUnderVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsUnderVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t averageRmsUnderVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsUnderVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsUnderVoltageAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsUnderVoltageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsUnderVoltage::Set(
            command->mEndPointId, command->averageRmsUnderVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsUnderVoltage");
        }
    }
};
class SetElectricalMeasurementRmsExtremeOverVoltageAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeOverVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-over-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &rmsExtremeOverVoltage, "Set the Value of on RmsExtremeOverVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeOverVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeOverVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t rmsExtremeOverVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeOverVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeOverVoltageAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeOverVoltageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeOverVoltage::Set(
            command->mEndPointId, command->rmsExtremeOverVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeOverVoltage");
        }
    }
};
class SetElectricalMeasurementRmsExtremeUnderVoltageAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeUnderVoltageAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-under-voltage", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &rmsExtremeUnderVoltage, "Set the Value of on RmsExtremeUnderVoltage.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeUnderVoltage");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeUnderVoltage, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t rmsExtremeUnderVoltage;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeUnderVoltage(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeUnderVoltageAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeUnderVoltageAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeUnderVoltage::Set(
            command->mEndPointId, command->rmsExtremeUnderVoltage);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeUnderVoltage");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSagAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSagAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-sag", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &rmsVoltageSag, "Set the Value of on RmsVoltageSag.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSag");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSag, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t rmsVoltageSag;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSag(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSagAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSagAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSag::Set(command->mEndPointId,
                                                                                                          command->rmsVoltageSag);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSag");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSwellAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSwellAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-swell", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &rmsVoltageSwell, "Set the Value of on RmsVoltageSwell.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSwell");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSwell, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t rmsVoltageSwell;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSwell(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSwellAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSwellAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSwell::Set(
            command->mEndPointId, command->rmsVoltageSwell);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSwell");
        }
    }
};
class SetElectricalMeasurementLineCurrentPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementLineCurrentPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "line-current-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &lineCurrentPhaseB, "Set the Value of on LineCurrentPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LineCurrentPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLineCurrentPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t lineCurrentPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetLineCurrentPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementLineCurrentPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementLineCurrentPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::LineCurrentPhaseB::Set(
            command->mEndPointId, command->lineCurrentPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LineCurrentPhaseB");
        }
    }
};
class SetElectricalMeasurementActiveCurrentPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActiveCurrentPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-current-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activeCurrentPhaseB, "Set the Value of on ActiveCurrentPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveCurrentPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveCurrentPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activeCurrentPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveCurrentPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActiveCurrentPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActiveCurrentPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActiveCurrentPhaseB::Set(
            command->mEndPointId, command->activeCurrentPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveCurrentPhaseB");
        }
    }
};
class SetElectricalMeasurementReactiveCurrentPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementReactiveCurrentPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reactive-current-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &reactiveCurrentPhaseB, "Set the Value of on ReactiveCurrentPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ReactiveCurrentPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReactiveCurrentPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t reactiveCurrentPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetReactiveCurrentPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementReactiveCurrentPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementReactiveCurrentPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ReactiveCurrentPhaseB::Set(
            command->mEndPointId, command->reactiveCurrentPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ReactiveCurrentPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsVoltagePhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltagePhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltagePhaseB, "Set the Value of on RmsVoltagePhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltagePhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltagePhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltagePhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltagePhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltagePhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltagePhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltagePhaseB::Set(
            command->mEndPointId, command->rmsVoltagePhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltagePhaseB");
        }
    }
};
class SetElectricalMeasurementRmsVoltageMinPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageMinPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-min-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageMinPhaseB, "Set the Value of on RmsVoltageMinPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageMinPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageMinPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageMinPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageMinPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageMinPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageMinPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageMinPhaseB::Set(
            command->mEndPointId, command->rmsVoltageMinPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageMinPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsVoltageMaxPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageMaxPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-max-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageMaxPhaseB, "Set the Value of on RmsVoltageMaxPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageMaxPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageMaxPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageMaxPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageMaxPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageMaxPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageMaxPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageMaxPhaseB::Set(
            command->mEndPointId, command->rmsVoltageMaxPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageMaxPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsCurrentPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentPhaseB, "Set the Value of on RmsCurrentPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentPhaseB::Set(
            command->mEndPointId, command->rmsCurrentPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsCurrentMinPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentMinPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-min-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentMinPhaseB, "Set the Value of on RmsCurrentMinPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentMinPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentMinPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentMinPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentMinPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentMinPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentMinPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentMinPhaseB::Set(
            command->mEndPointId, command->rmsCurrentMinPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentMinPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsCurrentMaxPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentMaxPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-max-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentMaxPhaseB, "Set the Value of on RmsCurrentMaxPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentMaxPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentMaxPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentMaxPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentMaxPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentMaxPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentMaxPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentMaxPhaseB::Set(
            command->mEndPointId, command->rmsCurrentMaxPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentMaxPhaseB");
        }
    }
};
class SetElectricalMeasurementActivePowerPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerPhaseB, "Set the Value of on ActivePowerPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerPhaseB::Set(
            command->mEndPointId, command->activePowerPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerPhaseB");
        }
    }
};
class SetElectricalMeasurementActivePowerMinPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerMinPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-min-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerMinPhaseB, "Set the Value of on ActivePowerMinPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerMinPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerMinPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerMinPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerMinPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerMinPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerMinPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerMinPhaseB::Set(
            command->mEndPointId, command->activePowerMinPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerMinPhaseB");
        }
    }
};
class SetElectricalMeasurementActivePowerMaxPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerMaxPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-max-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerMaxPhaseB, "Set the Value of on ActivePowerMaxPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerMaxPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerMaxPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerMaxPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerMaxPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerMaxPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerMaxPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerMaxPhaseB::Set(
            command->mEndPointId, command->activePowerMaxPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerMaxPhaseB");
        }
    }
};
class SetElectricalMeasurementReactivePowerPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementReactivePowerPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reactive-power-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &reactivePowerPhaseB, "Set the Value of on ReactivePowerPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ReactivePowerPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReactivePowerPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t reactivePowerPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetReactivePowerPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementReactivePowerPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementReactivePowerPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ReactivePowerPhaseB::Set(
            command->mEndPointId, command->reactivePowerPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ReactivePowerPhaseB");
        }
    }
};
class SetElectricalMeasurementApparentPowerPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementApparentPowerPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "apparent-power-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &apparentPowerPhaseB, "Set the Value of on ApparentPowerPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ApparentPowerPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetApparentPowerPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t apparentPowerPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetApparentPowerPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementApparentPowerPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementApparentPowerPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ApparentPowerPhaseB::Set(
            command->mEndPointId, command->apparentPowerPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ApparentPowerPhaseB");
        }
    }
};
class SetElectricalMeasurementPowerFactorPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementPowerFactorPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "power-factor-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &powerFactorPhaseB, "Set the Value of on PowerFactorPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PowerFactorPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPowerFactorPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t powerFactorPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetPowerFactorPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementPowerFactorPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementPowerFactorPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::PowerFactorPhaseB::Set(
            command->mEndPointId, command->powerFactorPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PowerFactorPhaseB");
        }
    }
};
class SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-voltage-measurement-period-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsVoltageMeasurementPeriodPhaseB,
                    "Set the Value of on AverageRmsVoltageMeasurementPeriodPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsVoltageMeasurementPeriodPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsVoltageMeasurementPeriodPhaseB,
                                                      reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsVoltageMeasurementPeriodPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsVoltageMeasurementPeriodPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseBAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsVoltageMeasurementPeriodPhaseB::Set(
                command->mEndPointId, command->averageRmsVoltageMeasurementPeriodPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsVoltageMeasurementPeriodPhaseB");
        }
    }
};
class SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-over-voltage-counter-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsOverVoltageCounterPhaseB,
                    "Set the Value of on AverageRmsOverVoltageCounterPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsOverVoltageCounterPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsOverVoltageCounterPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsOverVoltageCounterPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsOverVoltageCounterPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsOverVoltageCounterPhaseB::Set(
            command->mEndPointId, command->averageRmsOverVoltageCounterPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsOverVoltageCounterPhaseB");
        }
    }
};
class SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-under-voltage-counter-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsUnderVoltageCounterPhaseB,
                    "Set the Value of on AverageRmsUnderVoltageCounterPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsUnderVoltageCounterPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsUnderVoltageCounterPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsUnderVoltageCounterPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsUnderVoltageCounterPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsUnderVoltageCounterPhaseB::Set(
            command->mEndPointId, command->averageRmsUnderVoltageCounterPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsUnderVoltageCounterPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-over-voltage-period-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsExtremeOverVoltagePeriodPhaseB,
                    "Set the Value of on RmsExtremeOverVoltagePeriodPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeOverVoltagePeriodPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeOverVoltagePeriodPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsExtremeOverVoltagePeriodPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeOverVoltagePeriodPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeOverVoltagePeriodPhaseB::Set(
            command->mEndPointId, command->rmsExtremeOverVoltagePeriodPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeOverVoltagePeriodPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-under-voltage-period-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsExtremeUnderVoltagePeriodPhaseB,
                    "Set the Value of on RmsExtremeUnderVoltagePeriodPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeUnderVoltagePeriodPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeUnderVoltagePeriodPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsExtremeUnderVoltagePeriodPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeUnderVoltagePeriodPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeUnderVoltagePeriodPhaseB::Set(
            command->mEndPointId, command->rmsExtremeUnderVoltagePeriodPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeUnderVoltagePeriodPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSagPeriodPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSagPeriodPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-sag-period-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageSagPeriodPhaseB, "Set the Value of on RmsVoltageSagPeriodPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSagPeriodPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSagPeriodPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageSagPeriodPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSagPeriodPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSagPeriodPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSagPeriodPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSagPeriodPhaseB::Set(
            command->mEndPointId, command->rmsVoltageSagPeriodPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSagPeriodPhaseB");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSwellPeriodPhaseBAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSwellPeriodPhaseBAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-swell-period-phase-b", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageSwellPeriodPhaseB,
                    "Set the Value of on RmsVoltageSwellPeriodPhaseB.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSwellPeriodPhaseB");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSwellPeriodPhaseB, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageSwellPeriodPhaseB;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSwellPeriodPhaseB(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSwellPeriodPhaseBAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSwellPeriodPhaseBAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSwellPeriodPhaseB::Set(
            command->mEndPointId, command->rmsVoltageSwellPeriodPhaseB);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSwellPeriodPhaseB");
        }
    }
};
class SetElectricalMeasurementLineCurrentPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementLineCurrentPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "line-current-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &lineCurrentPhaseC, "Set the Value of on LineCurrentPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LineCurrentPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLineCurrentPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t lineCurrentPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetLineCurrentPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementLineCurrentPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementLineCurrentPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::LineCurrentPhaseC::Set(
            command->mEndPointId, command->lineCurrentPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LineCurrentPhaseC");
        }
    }
};
class SetElectricalMeasurementActiveCurrentPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActiveCurrentPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-current-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activeCurrentPhaseC, "Set the Value of on ActiveCurrentPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveCurrentPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveCurrentPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activeCurrentPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveCurrentPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActiveCurrentPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActiveCurrentPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActiveCurrentPhaseC::Set(
            command->mEndPointId, command->activeCurrentPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveCurrentPhaseC");
        }
    }
};
class SetElectricalMeasurementReactiveCurrentPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementReactiveCurrentPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reactive-current-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &reactiveCurrentPhaseC, "Set the Value of on ReactiveCurrentPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ReactiveCurrentPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReactiveCurrentPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t reactiveCurrentPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetReactiveCurrentPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementReactiveCurrentPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementReactiveCurrentPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ReactiveCurrentPhaseC::Set(
            command->mEndPointId, command->reactiveCurrentPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ReactiveCurrentPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsVoltagePhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltagePhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltagePhaseC, "Set the Value of on RmsVoltagePhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltagePhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltagePhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltagePhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltagePhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltagePhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltagePhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltagePhaseC::Set(
            command->mEndPointId, command->rmsVoltagePhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltagePhaseC");
        }
    }
};
class SetElectricalMeasurementRmsVoltageMinPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageMinPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-min-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageMinPhaseC, "Set the Value of on RmsVoltageMinPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageMinPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageMinPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageMinPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageMinPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageMinPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageMinPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageMinPhaseC::Set(
            command->mEndPointId, command->rmsVoltageMinPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageMinPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsVoltageMaxPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageMaxPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-max-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageMaxPhaseC, "Set the Value of on RmsVoltageMaxPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageMaxPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageMaxPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageMaxPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageMaxPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageMaxPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageMaxPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageMaxPhaseC::Set(
            command->mEndPointId, command->rmsVoltageMaxPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageMaxPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsCurrentPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentPhaseC, "Set the Value of on RmsCurrentPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentPhaseC::Set(
            command->mEndPointId, command->rmsCurrentPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsCurrentMinPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentMinPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-min-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentMinPhaseC, "Set the Value of on RmsCurrentMinPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentMinPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentMinPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentMinPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentMinPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentMinPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentMinPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentMinPhaseC::Set(
            command->mEndPointId, command->rmsCurrentMinPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentMinPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsCurrentMaxPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsCurrentMaxPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-current-max-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsCurrentMaxPhaseC, "Set the Value of on RmsCurrentMaxPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsCurrentMaxPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsCurrentMaxPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsCurrentMaxPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsCurrentMaxPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsCurrentMaxPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsCurrentMaxPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsCurrentMaxPhaseC::Set(
            command->mEndPointId, command->rmsCurrentMaxPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsCurrentMaxPhaseC");
        }
    }
};
class SetElectricalMeasurementActivePowerPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerPhaseC, "Set the Value of on ActivePowerPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerPhaseC::Set(
            command->mEndPointId, command->activePowerPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerPhaseC");
        }
    }
};
class SetElectricalMeasurementActivePowerMinPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerMinPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-min-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerMinPhaseC, "Set the Value of on ActivePowerMinPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerMinPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerMinPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerMinPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerMinPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerMinPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerMinPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerMinPhaseC::Set(
            command->mEndPointId, command->activePowerMinPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerMinPhaseC");
        }
    }
};
class SetElectricalMeasurementActivePowerMaxPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementActivePowerMaxPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-power-max-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &activePowerMaxPhaseC, "Set the Value of on ActivePowerMaxPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActivePowerMaxPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActivePowerMaxPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t activePowerMaxPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetActivePowerMaxPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementActivePowerMaxPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementActivePowerMaxPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ActivePowerMaxPhaseC::Set(
            command->mEndPointId, command->activePowerMaxPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActivePowerMaxPhaseC");
        }
    }
};
class SetElectricalMeasurementReactivePowerPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementReactivePowerPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "reactive-power-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &reactivePowerPhaseC, "Set the Value of on ReactivePowerPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ReactivePowerPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetReactivePowerPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t reactivePowerPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetReactivePowerPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementReactivePowerPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementReactivePowerPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ReactivePowerPhaseC::Set(
            command->mEndPointId, command->reactivePowerPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ReactivePowerPhaseC");
        }
    }
};
class SetElectricalMeasurementApparentPowerPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementApparentPowerPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "apparent-power-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &apparentPowerPhaseC, "Set the Value of on ApparentPowerPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ApparentPowerPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetApparentPowerPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t apparentPowerPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetApparentPowerPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementApparentPowerPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementApparentPowerPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ApparentPowerPhaseC::Set(
            command->mEndPointId, command->apparentPowerPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ApparentPowerPhaseC");
        }
    }
};
class SetElectricalMeasurementPowerFactorPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementPowerFactorPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "power-factor-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &powerFactorPhaseC, "Set the Value of on PowerFactorPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: PowerFactorPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetPowerFactorPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t powerFactorPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetPowerFactorPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementPowerFactorPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementPowerFactorPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::PowerFactorPhaseC::Set(
            command->mEndPointId, command->powerFactorPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute PowerFactorPhaseC");
        }
    }
};
class SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-voltage-measurement-period-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsVoltageMeasurementPeriodPhaseC,
                    "Set the Value of on AverageRmsVoltageMeasurementPeriodPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsVoltageMeasurementPeriodPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsVoltageMeasurementPeriodPhaseC,
                                                      reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsVoltageMeasurementPeriodPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsVoltageMeasurementPeriodPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseCAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsVoltageMeasurementPeriodPhaseC::Set(
                command->mEndPointId, command->averageRmsVoltageMeasurementPeriodPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsVoltageMeasurementPeriodPhaseC");
        }
    }
};
class SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-over-voltage-counter-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsOverVoltageCounterPhaseC,
                    "Set the Value of on AverageRmsOverVoltageCounterPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsOverVoltageCounterPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsOverVoltageCounterPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsOverVoltageCounterPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsOverVoltageCounterPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsOverVoltageCounterPhaseC::Set(
            command->mEndPointId, command->averageRmsOverVoltageCounterPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsOverVoltageCounterPhaseC");
        }
    }
};
class SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "average-rms-under-voltage-counter-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &averageRmsUnderVoltageCounterPhaseC,
                    "Set the Value of on AverageRmsUnderVoltageCounterPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: AverageRmsUnderVoltageCounterPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetAverageRmsUnderVoltageCounterPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t averageRmsUnderVoltageCounterPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetAverageRmsUnderVoltageCounterPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::AverageRmsUnderVoltageCounterPhaseC::Set(
            command->mEndPointId, command->averageRmsUnderVoltageCounterPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute AverageRmsUnderVoltageCounterPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-over-voltage-period-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsExtremeOverVoltagePeriodPhaseC,
                    "Set the Value of on RmsExtremeOverVoltagePeriodPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeOverVoltagePeriodPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeOverVoltagePeriodPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsExtremeOverVoltagePeriodPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeOverVoltagePeriodPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeOverVoltagePeriodPhaseC::Set(
            command->mEndPointId, command->rmsExtremeOverVoltagePeriodPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeOverVoltagePeriodPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-extreme-under-voltage-period-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsExtremeUnderVoltagePeriodPhaseC,
                    "Set the Value of on RmsExtremeUnderVoltagePeriodPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsExtremeUnderVoltagePeriodPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsExtremeUnderVoltagePeriodPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsExtremeUnderVoltagePeriodPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsExtremeUnderVoltagePeriodPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsExtremeUnderVoltagePeriodPhaseC::Set(
            command->mEndPointId, command->rmsExtremeUnderVoltagePeriodPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsExtremeUnderVoltagePeriodPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSagPeriodPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSagPeriodPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-sag-period-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageSagPeriodPhaseC, "Set the Value of on RmsVoltageSagPeriodPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSagPeriodPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSagPeriodPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageSagPeriodPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSagPeriodPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSagPeriodPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSagPeriodPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSagPeriodPhaseC::Set(
            command->mEndPointId, command->rmsVoltageSagPeriodPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSagPeriodPhaseC");
        }
    }
};
class SetElectricalMeasurementRmsVoltageSwellPeriodPhaseCAttributeCommand : public Command
{
public:
    SetElectricalMeasurementRmsVoltageSwellPeriodPhaseCAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "rms-voltage-swell-period-phase-c", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rmsVoltageSwellPeriodPhaseC,
                    "Set the Value of on RmsVoltageSwellPeriodPhaseC.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RmsVoltageSwellPeriodPhaseC");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRmsVoltageSwellPeriodPhaseC, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rmsVoltageSwellPeriodPhaseC;
    chip::EndpointId mEndPointId;

private:
    static void SetRmsVoltageSwellPeriodPhaseC(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementRmsVoltageSwellPeriodPhaseCAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementRmsVoltageSwellPeriodPhaseCAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::RmsVoltageSwellPeriodPhaseC::Set(
            command->mEndPointId, command->rmsVoltageSwellPeriodPhaseC);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RmsVoltageSwellPeriodPhaseC");
        }
    }
};
class SetElectricalMeasurementFeatureMapAttributeCommand : public Command
{
public:
    SetElectricalMeasurementFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementFeatureMapAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ElectricalMeasurement::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetElectricalMeasurementClusterRevisionAttributeCommand : public Command
{
public:
    SetElectricalMeasurementClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetElectricalMeasurementClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetElectricalMeasurementClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ElectricalMeasurement::Attributes::ClusterRevision::Set(
            command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetClientMonitoringIdleModeIntervalAttributeCommand : public Command
{
public:
    SetClientMonitoringIdleModeIntervalAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "idle-mode-interval", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &idleModeInterval, "Set the Value of on IdleModeInterval.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: IdleModeInterval");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetIdleModeInterval, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t idleModeInterval;
    chip::EndpointId mEndPointId;

private:
    static void SetIdleModeInterval(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetClientMonitoringIdleModeIntervalAttributeCommand * command =
            reinterpret_cast<SetClientMonitoringIdleModeIntervalAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ClientMonitoring::Attributes::IdleModeInterval::Set(command->mEndPointId,
                                                                                                        command->idleModeInterval);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute IdleModeInterval");
        }
    }
};
class SetClientMonitoringActiveModeIntervalAttributeCommand : public Command
{
public:
    SetClientMonitoringActiveModeIntervalAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-mode-interval", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &activeModeInterval, "Set the Value of on ActiveModeInterval.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveModeInterval");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveModeInterval, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t activeModeInterval;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveModeInterval(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetClientMonitoringActiveModeIntervalAttributeCommand * command =
            reinterpret_cast<SetClientMonitoringActiveModeIntervalAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ClientMonitoring::Attributes::ActiveModeInterval::Set(
            command->mEndPointId, command->activeModeInterval);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveModeInterval");
        }
    }
};
class SetClientMonitoringActiveModeThresholdAttributeCommand : public Command
{
public:
    SetClientMonitoringActiveModeThresholdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "active-mode-threshold", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &activeModeThreshold, "Set the Value of on ActiveModeThreshold.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ActiveModeThreshold");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetActiveModeThreshold, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t activeModeThreshold;
    chip::EndpointId mEndPointId;

private:
    static void SetActiveModeThreshold(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetClientMonitoringActiveModeThresholdAttributeCommand * command =
            reinterpret_cast<SetClientMonitoringActiveModeThresholdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::ClientMonitoring::Attributes::ActiveModeThreshold::Set(
            command->mEndPointId, command->activeModeThreshold);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ActiveModeThreshold");
        }
    }
};
class SetClientMonitoringFeatureMapAttributeCommand : public Command
{
public:
    SetClientMonitoringFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetClientMonitoringFeatureMapAttributeCommand * command =
            reinterpret_cast<SetClientMonitoringFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ClientMonitoring::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetClientMonitoringClusterRevisionAttributeCommand : public Command
{
public:
    SetClientMonitoringClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetClientMonitoringClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetClientMonitoringClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::ClientMonitoring::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetUnitTestingBooleanAttributeCommand : public Command
{
public:
    SetUnitTestingBooleanAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "boolean", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &boolean, "Set the Value of on Boolean.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Boolean");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBoolean, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool boolean;
    chip::EndpointId mEndPointId;

private:
    static void SetBoolean(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingBooleanAttributeCommand * command = reinterpret_cast<SetUnitTestingBooleanAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Boolean::Set(command->mEndPointId, command->boolean);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Boolean");
        }
    }
};
class SetUnitTestingBitmap8AttributeCommand : public Command
{
public:
    SetUnitTestingBitmap8AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bitmap8", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &bitmap8, "Set the Value of on Bitmap8.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Bitmap8");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBitmap8, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap> bitmap8;
    chip::EndpointId mEndPointId;

private:
    static void SetBitmap8(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingBitmap8AttributeCommand * command = reinterpret_cast<SetUnitTestingBitmap8AttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Bitmap8::Set(command->mEndPointId, command->bitmap8);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Bitmap8");
        }
    }
};
class SetUnitTestingBitmap16AttributeCommand : public Command
{
public:
    SetUnitTestingBitmap16AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bitmap16", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &bitmap16, "Set the Value of on Bitmap16.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Bitmap16");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBitmap16, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap> bitmap16;
    chip::EndpointId mEndPointId;

private:
    static void SetBitmap16(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingBitmap16AttributeCommand * command = reinterpret_cast<SetUnitTestingBitmap16AttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Bitmap16::Set(command->mEndPointId, command->bitmap16);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Bitmap16");
        }
    }
};
class SetUnitTestingBitmap32AttributeCommand : public Command
{
public:
    SetUnitTestingBitmap32AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bitmap32", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &bitmap32, "Set the Value of on Bitmap32.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Bitmap32");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBitmap32, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap> bitmap32;
    chip::EndpointId mEndPointId;

private:
    static void SetBitmap32(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingBitmap32AttributeCommand * command = reinterpret_cast<SetUnitTestingBitmap32AttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Bitmap32::Set(command->mEndPointId, command->bitmap32);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Bitmap32");
        }
    }
};
class SetUnitTestingBitmap64AttributeCommand : public Command
{
public:
    SetUnitTestingBitmap64AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "bitmap64", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &bitmap64, "Set the Value of on Bitmap64.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Bitmap64");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetBitmap64, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap> bitmap64;
    chip::EndpointId mEndPointId;

private:
    static void SetBitmap64(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingBitmap64AttributeCommand * command = reinterpret_cast<SetUnitTestingBitmap64AttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Bitmap64::Set(command->mEndPointId, command->bitmap64);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Bitmap64");
        }
    }
};
class SetUnitTestingInt8uAttributeCommand : public Command
{
public:
    SetUnitTestingInt8uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int8u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &int8u, "Set the Value of on Int8u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int8u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt8u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t int8u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt8u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt8uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt8uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int8u::Set(command->mEndPointId, command->int8u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int8u");
        }
    }
};
class SetUnitTestingInt16uAttributeCommand : public Command
{
public:
    SetUnitTestingInt16uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int16u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &int16u, "Set the Value of on Int16u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int16u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt16u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t int16u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt16u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt16uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt16uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int16u::Set(command->mEndPointId, command->int16u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int16u");
        }
    }
};
class SetUnitTestingInt24uAttributeCommand : public Command
{
public:
    SetUnitTestingInt24uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int24u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &int24u, "Set the Value of on Int24u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int24u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt24u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t int24u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt24u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt24uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt24uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int24u::Set(command->mEndPointId, command->int24u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int24u");
        }
    }
};
class SetUnitTestingInt32uAttributeCommand : public Command
{
public:
    SetUnitTestingInt32uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int32u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &int32u, "Set the Value of on Int32u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int32u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt32u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t int32u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt32u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt32uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt32uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int32u::Set(command->mEndPointId, command->int32u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int32u");
        }
    }
};
class SetUnitTestingInt40uAttributeCommand : public Command
{
public:
    SetUnitTestingInt40uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int40u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &int40u, "Set the Value of on Int40u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int40u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt40u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t int40u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt40u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt40uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt40uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int40u::Set(command->mEndPointId, command->int40u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int40u");
        }
    }
};
class SetUnitTestingInt48uAttributeCommand : public Command
{
public:
    SetUnitTestingInt48uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int48u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &int48u, "Set the Value of on Int48u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int48u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt48u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t int48u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt48u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt48uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt48uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int48u::Set(command->mEndPointId, command->int48u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int48u");
        }
    }
};
class SetUnitTestingInt56uAttributeCommand : public Command
{
public:
    SetUnitTestingInt56uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int56u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &int56u, "Set the Value of on Int56u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int56u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt56u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t int56u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt56u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt56uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt56uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int56u::Set(command->mEndPointId, command->int56u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int56u");
        }
    }
};
class SetUnitTestingInt64uAttributeCommand : public Command
{
public:
    SetUnitTestingInt64uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int64u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &int64u, "Set the Value of on Int64u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int64u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt64u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t int64u;
    chip::EndpointId mEndPointId;

private:
    static void SetInt64u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt64uAttributeCommand * command = reinterpret_cast<SetUnitTestingInt64uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int64u::Set(command->mEndPointId, command->int64u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int64u");
        }
    }
};
class SetUnitTestingInt8sAttributeCommand : public Command
{
public:
    SetUnitTestingInt8sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int8s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &int8s, "Set the Value of on Int8s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int8s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt8s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t int8s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt8s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt8sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt8sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int8s::Set(command->mEndPointId, command->int8s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int8s");
        }
    }
};
class SetUnitTestingInt16sAttributeCommand : public Command
{
public:
    SetUnitTestingInt16sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int16s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &int16s, "Set the Value of on Int16s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int16s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt16s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t int16s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt16s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt16sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt16sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int16s::Set(command->mEndPointId, command->int16s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int16s");
        }
    }
};
class SetUnitTestingInt24sAttributeCommand : public Command
{
public:
    SetUnitTestingInt24sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int24s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT32_MIN, INT32_MAX, &int24s, "Set the Value of on Int24s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int24s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt24s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int32_t int24s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt24s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt24sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt24sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int24s::Set(command->mEndPointId, command->int24s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int24s");
        }
    }
};
class SetUnitTestingInt32sAttributeCommand : public Command
{
public:
    SetUnitTestingInt32sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int32s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT32_MIN, INT32_MAX, &int32s, "Set the Value of on Int32s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int32s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt32s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int32_t int32s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt32s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt32sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt32sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int32s::Set(command->mEndPointId, command->int32s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int32s");
        }
    }
};
class SetUnitTestingInt40sAttributeCommand : public Command
{
public:
    SetUnitTestingInt40sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int40s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &int40s, "Set the Value of on Int40s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int40s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt40s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int64_t int40s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt40s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt40sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt40sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int40s::Set(command->mEndPointId, command->int40s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int40s");
        }
    }
};
class SetUnitTestingInt48sAttributeCommand : public Command
{
public:
    SetUnitTestingInt48sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int48s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &int48s, "Set the Value of on Int48s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int48s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt48s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int64_t int48s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt48s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt48sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt48sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int48s::Set(command->mEndPointId, command->int48s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int48s");
        }
    }
};
class SetUnitTestingInt56sAttributeCommand : public Command
{
public:
    SetUnitTestingInt56sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int56s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &int56s, "Set the Value of on Int56s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int56s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt56s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int64_t int56s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt56s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt56sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt56sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int56s::Set(command->mEndPointId, command->int56s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int56s");
        }
    }
};
class SetUnitTestingInt64sAttributeCommand : public Command
{
public:
    SetUnitTestingInt64sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "int64s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &int64s, "Set the Value of on Int64s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Int64s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetInt64s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int64_t int64s;
    chip::EndpointId mEndPointId;

private:
    static void SetInt64s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingInt64sAttributeCommand * command = reinterpret_cast<SetUnitTestingInt64sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Int64s::Set(command->mEndPointId, command->int64s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Int64s");
        }
    }
};
class SetUnitTestingEnum8AttributeCommand : public Command
{
public:
    SetUnitTestingEnum8AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enum8", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &enum8, "Set the Value of on Enum8.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Enum8");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnum8, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t enum8;
    chip::EndpointId mEndPointId;

private:
    static void SetEnum8(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingEnum8AttributeCommand * command = reinterpret_cast<SetUnitTestingEnum8AttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Enum8::Set(command->mEndPointId, command->enum8);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Enum8");
        }
    }
};
class SetUnitTestingEnum16AttributeCommand : public Command
{
public:
    SetUnitTestingEnum16AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enum16", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &enum16, "Set the Value of on Enum16.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Enum16");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnum16, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t enum16;
    chip::EndpointId mEndPointId;

private:
    static void SetEnum16(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingEnum16AttributeCommand * command = reinterpret_cast<SetUnitTestingEnum16AttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::Enum16::Set(command->mEndPointId, command->enum16);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Enum16");
        }
    }
};
class SetUnitTestingFloatSingleAttributeCommand : public Command
{
public:
    SetUnitTestingFloatSingleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "float-single", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &floatSingle,
                    "Set the Value of on FloatSingle.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FloatSingle");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFloatSingle, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    float floatSingle;
    chip::EndpointId mEndPointId;

private:
    static void SetFloatSingle(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingFloatSingleAttributeCommand * command =
            reinterpret_cast<SetUnitTestingFloatSingleAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::FloatSingle::Set(command->mEndPointId, command->floatSingle);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FloatSingle");
        }
    }
};
class SetUnitTestingFloatDoubleAttributeCommand : public Command
{
public:
    SetUnitTestingFloatDoubleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "float-double", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(),
                    &floatDouble, "Set the Value of on FloatDouble.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FloatDouble");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFloatDouble, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    double floatDouble;
    chip::EndpointId mEndPointId;

private:
    static void SetFloatDouble(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingFloatDoubleAttributeCommand * command =
            reinterpret_cast<SetUnitTestingFloatDoubleAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::FloatDouble::Set(command->mEndPointId, command->floatDouble);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FloatDouble");
        }
    }
};
class SetUnitTestingOctetStringAttributeCommand : public Command
{
public:
    SetUnitTestingOctetStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "octet-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &octetString, "Set the Value of on OctetString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: OctetString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetOctetString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::ByteSpan octetString;
    chip::EndpointId mEndPointId;

private:
    static void SetOctetString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingOctetStringAttributeCommand * command =
            reinterpret_cast<SetUnitTestingOctetStringAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::OctetString::Set(command->mEndPointId, command->octetString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute OctetString");
        }
    }
};
class SetUnitTestingLongOctetStringAttributeCommand : public Command
{
public:
    SetUnitTestingLongOctetStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "long-octet-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &longOctetString, "Set the Value of on LongOctetString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LongOctetString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLongOctetString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::ByteSpan longOctetString;
    chip::EndpointId mEndPointId;

private:
    static void SetLongOctetString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingLongOctetStringAttributeCommand * command =
            reinterpret_cast<SetUnitTestingLongOctetStringAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::LongOctetString::Set(command->mEndPointId, command->longOctetString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LongOctetString");
        }
    }
};
class SetUnitTestingCharStringAttributeCommand : public Command
{
public:
    SetUnitTestingCharStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "char-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &charString, "Set the Value of on CharString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: CharString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetCharString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan charString;
    chip::EndpointId mEndPointId;

private:
    static void SetCharString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingCharStringAttributeCommand * command = reinterpret_cast<SetUnitTestingCharStringAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::CharString::Set(command->mEndPointId, command->charString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute CharString");
        }
    }
};
class SetUnitTestingLongCharStringAttributeCommand : public Command
{
public:
    SetUnitTestingLongCharStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "long-char-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &longCharString, "Set the Value of on LongCharString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: LongCharString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetLongCharString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::CharSpan longCharString;
    chip::EndpointId mEndPointId;

private:
    static void SetLongCharString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingLongCharStringAttributeCommand * command =
            reinterpret_cast<SetUnitTestingLongCharStringAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::LongCharString::Set(command->mEndPointId, command->longCharString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute LongCharString");
        }
    }
};
class SetUnitTestingEpochUsAttributeCommand : public Command
{
public:
    SetUnitTestingEpochUsAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "epoch-us", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &epochUs, "Set the Value of on EpochUs.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EpochUs");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEpochUs, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint64_t epochUs;
    chip::EndpointId mEndPointId;

private:
    static void SetEpochUs(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingEpochUsAttributeCommand * command = reinterpret_cast<SetUnitTestingEpochUsAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::EpochUs::Set(command->mEndPointId, command->epochUs);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EpochUs");
        }
    }
};
class SetUnitTestingEpochSAttributeCommand : public Command
{
public:
    SetUnitTestingEpochSAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "epoch-s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &epochS, "Set the Value of on EpochS.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EpochS");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEpochS, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t epochS;
    chip::EndpointId mEndPointId;

private:
    static void SetEpochS(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingEpochSAttributeCommand * command = reinterpret_cast<SetUnitTestingEpochSAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::EpochS::Set(command->mEndPointId, command->epochS);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EpochS");
        }
    }
};
class SetUnitTestingVendorIdAttributeCommand : public Command
{
public:
    SetUnitTestingVendorIdAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "vendor-id", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &vendorId, "Set the Value of on VendorId.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: VendorId");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetVendorId, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::VendorId vendorId;
    chip::EndpointId mEndPointId;

private:
    static void SetVendorId(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingVendorIdAttributeCommand * command = reinterpret_cast<SetUnitTestingVendorIdAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::VendorId::Set(command->mEndPointId, command->vendorId);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute VendorId");
        }
    }
};
class SetUnitTestingEnumAttrAttributeCommand : public Command
{
public:
    SetUnitTestingEnumAttrAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "enum-attr", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &enumAttr, "Set the Value of on EnumAttr.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: EnumAttr");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetEnumAttr, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::Clusters::UnitTesting::SimpleEnum enumAttr;
    chip::EndpointId mEndPointId;

private:
    static void SetEnumAttr(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingEnumAttrAttributeCommand * command = reinterpret_cast<SetUnitTestingEnumAttrAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::EnumAttr::Set(command->mEndPointId, command->enumAttr);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute EnumAttr");
        }
    }
};
class SetUnitTestingRangeRestrictedInt8uAttributeCommand : public Command
{
public:
    SetUnitTestingRangeRestrictedInt8uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "range-restricted-int8u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &rangeRestrictedInt8u, "Set the Value of on RangeRestrictedInt8u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RangeRestrictedInt8u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRangeRestrictedInt8u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t rangeRestrictedInt8u;
    chip::EndpointId mEndPointId;

private:
    static void SetRangeRestrictedInt8u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingRangeRestrictedInt8uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingRangeRestrictedInt8uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::RangeRestrictedInt8u::Set(
            command->mEndPointId, command->rangeRestrictedInt8u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RangeRestrictedInt8u");
        }
    }
};
class SetUnitTestingRangeRestrictedInt8sAttributeCommand : public Command
{
public:
    SetUnitTestingRangeRestrictedInt8sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "range-restricted-int8s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &rangeRestrictedInt8s, "Set the Value of on RangeRestrictedInt8s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RangeRestrictedInt8s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRangeRestrictedInt8s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int8_t rangeRestrictedInt8s;
    chip::EndpointId mEndPointId;

private:
    static void SetRangeRestrictedInt8s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingRangeRestrictedInt8sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingRangeRestrictedInt8sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::RangeRestrictedInt8s::Set(
            command->mEndPointId, command->rangeRestrictedInt8s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RangeRestrictedInt8s");
        }
    }
};
class SetUnitTestingRangeRestrictedInt16uAttributeCommand : public Command
{
public:
    SetUnitTestingRangeRestrictedInt16uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "range-restricted-int16u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &rangeRestrictedInt16u, "Set the Value of on RangeRestrictedInt16u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RangeRestrictedInt16u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRangeRestrictedInt16u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t rangeRestrictedInt16u;
    chip::EndpointId mEndPointId;

private:
    static void SetRangeRestrictedInt16u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingRangeRestrictedInt16uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingRangeRestrictedInt16uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::RangeRestrictedInt16u::Set(
            command->mEndPointId, command->rangeRestrictedInt16u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RangeRestrictedInt16u");
        }
    }
};
class SetUnitTestingRangeRestrictedInt16sAttributeCommand : public Command
{
public:
    SetUnitTestingRangeRestrictedInt16sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "range-restricted-int16s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &rangeRestrictedInt16s, "Set the Value of on RangeRestrictedInt16s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: RangeRestrictedInt16s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetRangeRestrictedInt16s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    int16_t rangeRestrictedInt16s;
    chip::EndpointId mEndPointId;

private:
    static void SetRangeRestrictedInt16s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingRangeRestrictedInt16sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingRangeRestrictedInt16sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::RangeRestrictedInt16s::Set(
            command->mEndPointId, command->rangeRestrictedInt16s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute RangeRestrictedInt16s");
        }
    }
};
class SetUnitTestingTimedWriteBooleanAttributeCommand : public Command
{
public:
    SetUnitTestingTimedWriteBooleanAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "timed-write-boolean", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &timedWriteBoolean, "Set the Value of on TimedWriteBoolean.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: TimedWriteBoolean");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetTimedWriteBoolean, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool timedWriteBoolean;
    chip::EndpointId mEndPointId;

private:
    static void SetTimedWriteBoolean(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingTimedWriteBooleanAttributeCommand * command =
            reinterpret_cast<SetUnitTestingTimedWriteBooleanAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::TimedWriteBoolean::Set(command->mEndPointId, command->timedWriteBoolean);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute TimedWriteBoolean");
        }
    }
};
class SetUnitTestingGeneralErrorBooleanAttributeCommand : public Command
{
public:
    SetUnitTestingGeneralErrorBooleanAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "general-error-boolean", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &generalErrorBoolean, "Set the Value of on GeneralErrorBoolean.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: GeneralErrorBoolean");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetGeneralErrorBoolean, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool generalErrorBoolean;
    chip::EndpointId mEndPointId;

private:
    static void SetGeneralErrorBoolean(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingGeneralErrorBooleanAttributeCommand * command =
            reinterpret_cast<SetUnitTestingGeneralErrorBooleanAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::GeneralErrorBoolean::Set(command->mEndPointId,
                                                                                                      command->generalErrorBoolean);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute GeneralErrorBoolean");
        }
    }
};
class SetUnitTestingClusterErrorBooleanAttributeCommand : public Command
{
public:
    SetUnitTestingClusterErrorBooleanAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-error-boolean", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &clusterErrorBoolean, "Set the Value of on ClusterErrorBoolean.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterErrorBoolean");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterErrorBoolean, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool clusterErrorBoolean;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterErrorBoolean(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingClusterErrorBooleanAttributeCommand * command =
            reinterpret_cast<SetUnitTestingClusterErrorBooleanAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::ClusterErrorBoolean::Set(command->mEndPointId,
                                                                                                      command->clusterErrorBoolean);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterErrorBoolean");
        }
    }
};
class SetUnitTestingUnsupportedAttributeCommand : public Command
{
public:
    SetUnitTestingUnsupportedAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "unsupported", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &unsupported, "Set the Value of on Unsupported.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: Unsupported");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetUnsupported, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    bool unsupported;
    chip::EndpointId mEndPointId;

private:
    static void SetUnsupported(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingUnsupportedAttributeCommand * command =
            reinterpret_cast<SetUnitTestingUnsupportedAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::Unsupported::Set(command->mEndPointId, command->unsupported);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute Unsupported");
        }
    }
};
class SetUnitTestingNullableBooleanAttributeCommand : public Command
{
public:
    SetUnitTestingNullableBooleanAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-boolean", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, 1, &nullableBoolean, "Set the Value of on NullableBoolean.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableBoolean");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableBoolean, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<bool> nullableBoolean;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableBoolean(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableBooleanAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableBooleanAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableBoolean::Set(command->mEndPointId, command->nullableBoolean);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableBoolean");
        }
    }
};
class SetUnitTestingNullableBitmap8AttributeCommand : public Command
{
public:
    SetUnitTestingNullableBitmap8AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-bitmap8", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &nullableBitmap8, "Set the Value of on NullableBitmap8.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableBitmap8");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableBitmap8, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>> nullableBitmap8;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableBitmap8(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableBitmap8AttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableBitmap8AttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableBitmap8::Set(command->mEndPointId, command->nullableBitmap8);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableBitmap8");
        }
    }
};
class SetUnitTestingNullableBitmap16AttributeCommand : public Command
{
public:
    SetUnitTestingNullableBitmap16AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-bitmap16", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &nullableBitmap16, "Set the Value of on NullableBitmap16.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableBitmap16");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableBitmap16, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>> nullableBitmap16;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableBitmap16(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableBitmap16AttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableBitmap16AttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableBitmap16::Set(command->mEndPointId, command->nullableBitmap16);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableBitmap16");
        }
    }
};
class SetUnitTestingNullableBitmap32AttributeCommand : public Command
{
public:
    SetUnitTestingNullableBitmap32AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-bitmap32", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &nullableBitmap32, "Set the Value of on NullableBitmap32.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableBitmap32");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableBitmap32, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>> nullableBitmap32;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableBitmap32(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableBitmap32AttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableBitmap32AttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableBitmap32::Set(command->mEndPointId, command->nullableBitmap32);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableBitmap32");
        }
    }
};
class SetUnitTestingNullableBitmap64AttributeCommand : public Command
{
public:
    SetUnitTestingNullableBitmap64AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-bitmap64", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &nullableBitmap64, "Set the Value of on NullableBitmap64.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableBitmap64");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableBitmap64, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>> nullableBitmap64;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableBitmap64(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableBitmap64AttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableBitmap64AttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableBitmap64::Set(command->mEndPointId, command->nullableBitmap64);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableBitmap64");
        }
    }
};
class SetUnitTestingNullableInt8uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt8uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int8u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &nullableInt8u, "Set the Value of on NullableInt8u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt8u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt8u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> nullableInt8u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt8u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt8uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt8uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt8u::Set(command->mEndPointId, command->nullableInt8u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt8u");
        }
    }
};
class SetUnitTestingNullableInt16uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt16uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int16u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &nullableInt16u, "Set the Value of on NullableInt16u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt16u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt16u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> nullableInt16u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt16u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt16uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt16uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt16u::Set(command->mEndPointId, command->nullableInt16u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt16u");
        }
    }
};
class SetUnitTestingNullableInt24uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt24uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int24u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &nullableInt24u, "Set the Value of on NullableInt24u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt24u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt24u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> nullableInt24u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt24u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt24uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt24uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt24u::Set(command->mEndPointId, command->nullableInt24u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt24u");
        }
    }
};
class SetUnitTestingNullableInt32uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt32uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int32u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &nullableInt32u, "Set the Value of on NullableInt32u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt32u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt32u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint32_t> nullableInt32u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt32u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt32uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt32uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt32u::Set(command->mEndPointId, command->nullableInt32u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt32u");
        }
    }
};
class SetUnitTestingNullableInt40uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt40uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int40u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &nullableInt40u, "Set the Value of on NullableInt40u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt40u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt40u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> nullableInt40u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt40u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt40uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt40uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt40u::Set(command->mEndPointId, command->nullableInt40u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt40u");
        }
    }
};
class SetUnitTestingNullableInt48uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt48uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int48u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &nullableInt48u, "Set the Value of on NullableInt48u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt48u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt48u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> nullableInt48u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt48u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt48uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt48uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt48u::Set(command->mEndPointId, command->nullableInt48u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt48u");
        }
    }
};
class SetUnitTestingNullableInt56uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt56uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int56u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &nullableInt56u, "Set the Value of on NullableInt56u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt56u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt56u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> nullableInt56u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt56u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt56uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt56uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt56u::Set(command->mEndPointId, command->nullableInt56u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt56u");
        }
    }
};
class SetUnitTestingNullableInt64uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt64uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int64u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT64_MAX, &nullableInt64u, "Set the Value of on NullableInt64u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt64u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt64u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint64_t> nullableInt64u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt64u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt64uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt64uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt64u::Set(command->mEndPointId, command->nullableInt64u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt64u");
        }
    }
};
class SetUnitTestingNullableInt8sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt8sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int8s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &nullableInt8s, "Set the Value of on NullableInt8s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt8s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt8s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int8_t> nullableInt8s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt8s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt8sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt8sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt8s::Set(command->mEndPointId, command->nullableInt8s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt8s");
        }
    }
};
class SetUnitTestingNullableInt16sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt16sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int16s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &nullableInt16s, "Set the Value of on NullableInt16s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt16s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt16s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> nullableInt16s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt16s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt16sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt16sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt16s::Set(command->mEndPointId, command->nullableInt16s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt16s");
        }
    }
};
class SetUnitTestingNullableInt24sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt24sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int24s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT32_MIN, INT32_MAX, &nullableInt24s, "Set the Value of on NullableInt24s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt24s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt24s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int32_t> nullableInt24s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt24s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt24sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt24sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt24s::Set(command->mEndPointId, command->nullableInt24s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt24s");
        }
    }
};
class SetUnitTestingNullableInt32sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt32sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int32s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT32_MIN, INT32_MAX, &nullableInt32s, "Set the Value of on NullableInt32s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt32s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt32s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int32_t> nullableInt32s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt32s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt32sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt32sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt32s::Set(command->mEndPointId, command->nullableInt32s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt32s");
        }
    }
};
class SetUnitTestingNullableInt40sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt40sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int40s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &nullableInt40s, "Set the Value of on NullableInt40s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt40s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt40s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int64_t> nullableInt40s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt40s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt40sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt40sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt40s::Set(command->mEndPointId, command->nullableInt40s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt40s");
        }
    }
};
class SetUnitTestingNullableInt48sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt48sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int48s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &nullableInt48s, "Set the Value of on NullableInt48s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt48s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt48s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int64_t> nullableInt48s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt48s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt48sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt48sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt48s::Set(command->mEndPointId, command->nullableInt48s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt48s");
        }
    }
};
class SetUnitTestingNullableInt56sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt56sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int56s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &nullableInt56s, "Set the Value of on NullableInt56s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt56s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt56s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int64_t> nullableInt56s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt56s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt56sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt56sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt56s::Set(command->mEndPointId, command->nullableInt56s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt56s");
        }
    }
};
class SetUnitTestingNullableInt64sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableInt64sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-int64s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT64_MIN, INT64_MAX, &nullableInt64s, "Set the Value of on NullableInt64s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableInt64s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableInt64s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int64_t> nullableInt64s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableInt64s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableInt64sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableInt64sAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableInt64s::Set(command->mEndPointId, command->nullableInt64s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableInt64s");
        }
    }
};
class SetUnitTestingNullableEnum8AttributeCommand : public Command
{
public:
    SetUnitTestingNullableEnum8AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-enum8", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &nullableEnum8, "Set the Value of on NullableEnum8.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableEnum8");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableEnum8, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> nullableEnum8;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableEnum8(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableEnum8AttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableEnum8AttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableEnum8::Set(command->mEndPointId, command->nullableEnum8);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableEnum8");
        }
    }
};
class SetUnitTestingNullableEnum16AttributeCommand : public Command
{
public:
    SetUnitTestingNullableEnum16AttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-enum16", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &nullableEnum16, "Set the Value of on NullableEnum16.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableEnum16");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableEnum16, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> nullableEnum16;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableEnum16(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableEnum16AttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableEnum16AttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableEnum16::Set(command->mEndPointId, command->nullableEnum16);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableEnum16");
        }
    }
};
class SetUnitTestingNullableFloatSingleAttributeCommand : public Command
{
public:
    SetUnitTestingNullableFloatSingleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-float-single", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(),
                    &nullableFloatSingle, "Set the Value of on NullableFloatSingle.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableFloatSingle");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableFloatSingle, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<float> nullableFloatSingle;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableFloatSingle(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableFloatSingleAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableFloatSingleAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableFloatSingle::Set(command->mEndPointId,
                                                                                                      command->nullableFloatSingle);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableFloatSingle");
        }
    }
};
class SetUnitTestingNullableFloatDoubleAttributeCommand : public Command
{
public:
    SetUnitTestingNullableFloatDoubleAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-float-double", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(),
                    &nullableFloatDouble, "Set the Value of on NullableFloatDouble.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableFloatDouble");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableFloatDouble, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<double> nullableFloatDouble;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableFloatDouble(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableFloatDoubleAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableFloatDoubleAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableFloatDouble::Set(command->mEndPointId,
                                                                                                      command->nullableFloatDouble);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableFloatDouble");
        }
    }
};
class SetUnitTestingNullableOctetStringAttributeCommand : public Command
{
public:
    SetUnitTestingNullableOctetStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-octet-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &nullableOctetString, "Set the Value of on NullableOctetString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableOctetString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableOctetString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::ByteSpan> nullableOctetString;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableOctetString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableOctetStringAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableOctetStringAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableOctetString::Set(command->mEndPointId,
                                                                                                      command->nullableOctetString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableOctetString");
        }
    }
};
class SetUnitTestingNullableCharStringAttributeCommand : public Command
{
public:
    SetUnitTestingNullableCharStringAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-char-string", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", &nullableCharString, "Set the Value of on NullableCharString.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableCharString");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableCharString, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::CharSpan> nullableCharString;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableCharString(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableCharStringAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableCharStringAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableCharString::Set(command->mEndPointId,
                                                                                                     command->nullableCharString);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableCharString");
        }
    }
};
class SetUnitTestingNullableEnumAttrAttributeCommand : public Command
{
public:
    SetUnitTestingNullableEnumAttrAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-enum-attr", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &nullableEnumAttr, "Set the Value of on NullableEnumAttr.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableEnumAttr");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableEnumAttr, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::SimpleEnum> nullableEnumAttr;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableEnumAttr(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableEnumAttrAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableEnumAttrAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::NullableEnumAttr::Set(command->mEndPointId, command->nullableEnumAttr);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableEnumAttr");
        }
    }
};
class SetUnitTestingNullableRangeRestrictedInt8uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableRangeRestrictedInt8uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-range-restricted-int8u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &nullableRangeRestrictedInt8u,
                    "Set the Value of on NullableRangeRestrictedInt8u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableRangeRestrictedInt8u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableRangeRestrictedInt8u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint8_t> nullableRangeRestrictedInt8u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableRangeRestrictedInt8u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableRangeRestrictedInt8uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableRangeRestrictedInt8uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableRangeRestrictedInt8u::Set(
            command->mEndPointId, command->nullableRangeRestrictedInt8u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableRangeRestrictedInt8u");
        }
    }
};
class SetUnitTestingNullableRangeRestrictedInt8sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableRangeRestrictedInt8sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-range-restricted-int8s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT8_MIN, INT8_MAX, &nullableRangeRestrictedInt8s,
                    "Set the Value of on NullableRangeRestrictedInt8s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableRangeRestrictedInt8s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableRangeRestrictedInt8s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int8_t> nullableRangeRestrictedInt8s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableRangeRestrictedInt8s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableRangeRestrictedInt8sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableRangeRestrictedInt8sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableRangeRestrictedInt8s::Set(
            command->mEndPointId, command->nullableRangeRestrictedInt8s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableRangeRestrictedInt8s");
        }
    }
};
class SetUnitTestingNullableRangeRestrictedInt16uAttributeCommand : public Command
{
public:
    SetUnitTestingNullableRangeRestrictedInt16uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-range-restricted-int16u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &nullableRangeRestrictedInt16u,
                    "Set the Value of on NullableRangeRestrictedInt16u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableRangeRestrictedInt16u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableRangeRestrictedInt16u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<uint16_t> nullableRangeRestrictedInt16u;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableRangeRestrictedInt16u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableRangeRestrictedInt16uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableRangeRestrictedInt16uAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableRangeRestrictedInt16u::Set(
            command->mEndPointId, command->nullableRangeRestrictedInt16u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableRangeRestrictedInt16u");
        }
    }
};
class SetUnitTestingNullableRangeRestrictedInt16sAttributeCommand : public Command
{
public:
    SetUnitTestingNullableRangeRestrictedInt16sAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "nullable-range-restricted-int16s", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", INT16_MIN, INT16_MAX, &nullableRangeRestrictedInt16s,
                    "Set the Value of on NullableRangeRestrictedInt16s.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: NullableRangeRestrictedInt16s");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetNullableRangeRestrictedInt16s, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    chip::app::DataModel::Nullable<int16_t> nullableRangeRestrictedInt16s;
    chip::EndpointId mEndPointId;

private:
    static void SetNullableRangeRestrictedInt16s(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingNullableRangeRestrictedInt16sAttributeCommand * command =
            reinterpret_cast<SetUnitTestingNullableRangeRestrictedInt16sAttributeCommand *>(context);
        EmberAfStatus result = chip::app::Clusters::UnitTesting::Attributes::NullableRangeRestrictedInt16s::Set(
            command->mEndPointId, command->nullableRangeRestrictedInt16s);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute NullableRangeRestrictedInt16s");
        }
    }
};
class SetUnitTestingWriteOnlyInt8uAttributeCommand : public Command
{
public:
    SetUnitTestingWriteOnlyInt8uAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "write-only-int8u", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT8_MAX, &writeOnlyInt8u, "Set the Value of on WriteOnlyInt8u.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: WriteOnlyInt8u");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetWriteOnlyInt8u, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint8_t writeOnlyInt8u;
    chip::EndpointId mEndPointId;

private:
    static void SetWriteOnlyInt8u(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingWriteOnlyInt8uAttributeCommand * command =
            reinterpret_cast<SetUnitTestingWriteOnlyInt8uAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::WriteOnlyInt8u::Set(command->mEndPointId, command->writeOnlyInt8u);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute WriteOnlyInt8u");
        }
    }
};
class SetUnitTestingFeatureMapAttributeCommand : public Command
{
public:
    SetUnitTestingFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingFeatureMapAttributeCommand * command = reinterpret_cast<SetUnitTestingFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetUnitTestingClusterRevisionAttributeCommand : public Command
{
public:
    SetUnitTestingClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetUnitTestingClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetUnitTestingClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::UnitTesting::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};
class SetFaultInjectionFeatureMapAttributeCommand : public Command
{
public:
    SetFaultInjectionFeatureMapAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "feature-map", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT32_MAX, &featureMap, "Set the Value of on FeatureMap.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: FeatureMap");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetFeatureMap, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint32_t featureMap;
    chip::EndpointId mEndPointId;

private:
    static void SetFeatureMap(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFaultInjectionFeatureMapAttributeCommand * command =
            reinterpret_cast<SetFaultInjectionFeatureMapAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FaultInjection::Attributes::FeatureMap::Set(command->mEndPointId, command->featureMap);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute FeatureMap");
        }
    }
};
class SetFaultInjectionClusterRevisionAttributeCommand : public Command
{
public:
    SetFaultInjectionClusterRevisionAttributeCommand() : Command("set-attribute")
    {
        AddArgument("attribute-name", "cluster-revision", "The attribute name to write.");
        AddArgument("endpointID", 0, UINT16_MAX, &mEndPointId, "Set the Value for an end point.");
        AddArgument("atribute-value", 0, UINT16_MAX, &clusterRevision, "Set the Value of on ClusterRevision.");
    }

    /////////// Command Interface /////////
    CHIP_ERROR Run() override
    {
        ChipLogProgress(chipTool, "Setting Attribute Value: ClusterRevision");
        chip::DeviceLayer::PlatformMgr().ScheduleWork(SetClusterRevision, reinterpret_cast<intptr_t>(this));
        return CHIP_NO_ERROR;
    }

    void SetCommandExitStatus(CHIP_ERROR status) {}

    uint16_t clusterRevision;
    chip::EndpointId mEndPointId;

private:
    static void SetClusterRevision(intptr_t context)
    {
        VerifyOrReturn(context != 0, ChipLogError(NotSpecified, "SetOnOff - Invalid Class"));

        SetFaultInjectionClusterRevisionAttributeCommand * command =
            reinterpret_cast<SetFaultInjectionClusterRevisionAttributeCommand *>(context);
        EmberAfStatus result =
            chip::app::Clusters::FaultInjection::Attributes::ClusterRevision::Set(command->mEndPointId, command->clusterRevision);
        ChipLogProgress(AppServer, "Set command Ember AF Status: %d", result);
        if (EMBER_SUCCESS != result)
        {
            ChipLogError(AppServer, "Failed to set attribute ClusterRevision");
        }
    }
};

/*----------------------------------------------------------------------------*\
| Register all Set commands                                               |
\*----------------------------------------------------------------------------*/
void registeridentifySetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<SetIdentifyIdentifyTimeAttributeCommand>(),    //
        make_unique<SetIdentifyIdentifyTypeAttributeCommand>(),    //
        make_unique<SetIdentifyFeatureMapAttributeCommand>(),      //
        make_unique<SetIdentifyClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registergroupsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<SetGroupsNameSupportAttributeCommand>(),     //
        make_unique<SetGroupsFeatureMapAttributeCommand>(),      //
        make_unique<SetGroupsClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerscenesSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<SetScenesSceneCountAttributeCommand>(),       //
        make_unique<SetScenesCurrentSceneAttributeCommand>(),     //
        make_unique<SetScenesCurrentGroupAttributeCommand>(),     //
        make_unique<SetScenesSceneValidAttributeCommand>(),       //
        make_unique<SetScenesNameSupportAttributeCommand>(),      //
        make_unique<SetScenesLastConfiguredByAttributeCommand>(), //
        make_unique<SetScenesFeatureMapAttributeCommand>(),       //
        make_unique<SetScenesClusterRevisionAttributeCommand>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeronOffSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<SetOnOffOnOffAttributeCommand>(),              //
        make_unique<SetOnOffGlobalSceneControlAttributeCommand>(), //
        make_unique<SetOnOffOnTimeAttributeCommand>(),             //
        make_unique<SetOnOffOffWaitTimeAttributeCommand>(),        //
        make_unique<SetOnOffStartUpOnOffAttributeCommand>(),       //
        make_unique<SetOnOffFeatureMapAttributeCommand>(),         //
        make_unique<SetOnOffClusterRevisionAttributeCommand>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeronOffSwitchConfigurationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "OnOffSwitchConfiguration";

    commands_list clusterCommands = {
        make_unique<SetOnOffSwitchConfigurationSwitchTypeAttributeCommand>(),      //
        make_unique<SetOnOffSwitchConfigurationSwitchActionsAttributeCommand>(),   //
        make_unique<SetOnOffSwitchConfigurationFeatureMapAttributeCommand>(),      //
        make_unique<SetOnOffSwitchConfigurationClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerlevelControlSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "LevelControl";

    commands_list clusterCommands = {
        make_unique<SetLevelControlCurrentLevelAttributeCommand>(),        //
        make_unique<SetLevelControlRemainingTimeAttributeCommand>(),       //
        make_unique<SetLevelControlMinLevelAttributeCommand>(),            //
        make_unique<SetLevelControlMaxLevelAttributeCommand>(),            //
        make_unique<SetLevelControlCurrentFrequencyAttributeCommand>(),    //
        make_unique<SetLevelControlMinFrequencyAttributeCommand>(),        //
        make_unique<SetLevelControlMaxFrequencyAttributeCommand>(),        //
        make_unique<SetLevelControlOptionsAttributeCommand>(),             //
        make_unique<SetLevelControlOnOffTransitionTimeAttributeCommand>(), //
        make_unique<SetLevelControlOnLevelAttributeCommand>(),             //
        make_unique<SetLevelControlOnTransitionTimeAttributeCommand>(),    //
        make_unique<SetLevelControlOffTransitionTimeAttributeCommand>(),   //
        make_unique<SetLevelControlDefaultMoveRateAttributeCommand>(),     //
        make_unique<SetLevelControlStartUpCurrentLevelAttributeCommand>(), //
        make_unique<SetLevelControlFeatureMapAttributeCommand>(),          //
        make_unique<SetLevelControlClusterRevisionAttributeCommand>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerbinaryInputBasicSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "BinaryInputBasic";

    commands_list clusterCommands = {
        make_unique<SetBinaryInputBasicActiveTextAttributeCommand>(),      //
        make_unique<SetBinaryInputBasicDescriptionAttributeCommand>(),     //
        make_unique<SetBinaryInputBasicInactiveTextAttributeCommand>(),    //
        make_unique<SetBinaryInputBasicOutOfServiceAttributeCommand>(),    //
        make_unique<SetBinaryInputBasicPolarityAttributeCommand>(),        //
        make_unique<SetBinaryInputBasicPresentValueAttributeCommand>(),    //
        make_unique<SetBinaryInputBasicReliabilityAttributeCommand>(),     //
        make_unique<SetBinaryInputBasicStatusFlagsAttributeCommand>(),     //
        make_unique<SetBinaryInputBasicApplicationTypeAttributeCommand>(), //
        make_unique<SetBinaryInputBasicFeatureMapAttributeCommand>(),      //
        make_unique<SetBinaryInputBasicClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerpulseWidthModulationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "PulseWidthModulation";

    commands_list clusterCommands = {
        make_unique<SetPulseWidthModulationFeatureMapAttributeCommand>(),      //
        make_unique<SetPulseWidthModulationClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerdescriptorSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Descriptor";

    commands_list clusterCommands = {
        make_unique<SetDescriptorFeatureMapAttributeCommand>(),      //
        make_unique<SetDescriptorClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerbindingSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Binding";

    commands_list clusterCommands = {
        make_unique<SetBindingFeatureMapAttributeCommand>(),      //
        make_unique<SetBindingClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeraccessControlSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "AccessControl";

    commands_list clusterCommands = {
        make_unique<SetAccessControlSubjectsPerAccessControlEntryAttributeCommand>(), //
        make_unique<SetAccessControlTargetsPerAccessControlEntryAttributeCommand>(),  //
        make_unique<SetAccessControlAccessControlEntriesPerFabricAttributeCommand>(), //
        make_unique<SetAccessControlFeatureMapAttributeCommand>(),                    //
        make_unique<SetAccessControlClusterRevisionAttributeCommand>(),               //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeractionsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Actions";

    commands_list clusterCommands = {
        make_unique<SetActionsSetupURLAttributeCommand>(),        //
        make_unique<SetActionsFeatureMapAttributeCommand>(),      //
        make_unique<SetActionsClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerbasicInformationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "BasicInformation";

    commands_list clusterCommands = {
        make_unique<SetBasicInformationDataModelRevisionAttributeCommand>(),     //
        make_unique<SetBasicInformationVendorNameAttributeCommand>(),            //
        make_unique<SetBasicInformationVendorIDAttributeCommand>(),              //
        make_unique<SetBasicInformationProductNameAttributeCommand>(),           //
        make_unique<SetBasicInformationProductIDAttributeCommand>(),             //
        make_unique<SetBasicInformationNodeLabelAttributeCommand>(),             //
        make_unique<SetBasicInformationLocationAttributeCommand>(),              //
        make_unique<SetBasicInformationHardwareVersionAttributeCommand>(),       //
        make_unique<SetBasicInformationHardwareVersionStringAttributeCommand>(), //
        make_unique<SetBasicInformationSoftwareVersionAttributeCommand>(),       //
        make_unique<SetBasicInformationSoftwareVersionStringAttributeCommand>(), //
        make_unique<SetBasicInformationManufacturingDateAttributeCommand>(),     //
        make_unique<SetBasicInformationPartNumberAttributeCommand>(),            //
        make_unique<SetBasicInformationProductURLAttributeCommand>(),            //
        make_unique<SetBasicInformationProductLabelAttributeCommand>(),          //
        make_unique<SetBasicInformationSerialNumberAttributeCommand>(),          //
        make_unique<SetBasicInformationLocalConfigDisabledAttributeCommand>(),   //
        make_unique<SetBasicInformationReachableAttributeCommand>(),             //
        make_unique<SetBasicInformationUniqueIDAttributeCommand>(),              //
        make_unique<SetBasicInformationFeatureMapAttributeCommand>(),            //
        make_unique<SetBasicInformationClusterRevisionAttributeCommand>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerotaSoftwareUpdateProviderSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateProvider";

    commands_list clusterCommands = {
        make_unique<SetOtaSoftwareUpdateProviderFeatureMapAttributeCommand>(),      //
        make_unique<SetOtaSoftwareUpdateProviderClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerotaSoftwareUpdateRequestorSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateRequestor";

    commands_list clusterCommands = {
        make_unique<SetOtaSoftwareUpdateRequestorUpdatePossibleAttributeCommand>(),      //
        make_unique<SetOtaSoftwareUpdateRequestorUpdateStateAttributeCommand>(),         //
        make_unique<SetOtaSoftwareUpdateRequestorUpdateStateProgressAttributeCommand>(), //
        make_unique<SetOtaSoftwareUpdateRequestorFeatureMapAttributeCommand>(),          //
        make_unique<SetOtaSoftwareUpdateRequestorClusterRevisionAttributeCommand>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerlocalizationConfigurationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "LocalizationConfiguration";

    commands_list clusterCommands = {
        make_unique<SetLocalizationConfigurationActiveLocaleAttributeCommand>(),    //
        make_unique<SetLocalizationConfigurationFeatureMapAttributeCommand>(),      //
        make_unique<SetLocalizationConfigurationClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registertimeFormatLocalizationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "TimeFormatLocalization";

    commands_list clusterCommands = {
        make_unique<SetTimeFormatLocalizationHourFormatAttributeCommand>(),         //
        make_unique<SetTimeFormatLocalizationActiveCalendarTypeAttributeCommand>(), //
        make_unique<SetTimeFormatLocalizationFeatureMapAttributeCommand>(),         //
        make_unique<SetTimeFormatLocalizationClusterRevisionAttributeCommand>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerunitLocalizationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "UnitLocalization";

    commands_list clusterCommands = {
        make_unique<SetUnitLocalizationTemperatureUnitAttributeCommand>(), //
        make_unique<SetUnitLocalizationFeatureMapAttributeCommand>(),      //
        make_unique<SetUnitLocalizationClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerpowerSourceConfigurationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "PowerSourceConfiguration";

    commands_list clusterCommands = {
        make_unique<SetPowerSourceConfigurationFeatureMapAttributeCommand>(),      //
        make_unique<SetPowerSourceConfigurationClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerpowerSourceSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "PowerSource";

    commands_list clusterCommands = {
        make_unique<SetPowerSourceStatusAttributeCommand>(),                      //
        make_unique<SetPowerSourceOrderAttributeCommand>(),                       //
        make_unique<SetPowerSourceDescriptionAttributeCommand>(),                 //
        make_unique<SetPowerSourceWiredAssessedInputVoltageAttributeCommand>(),   //
        make_unique<SetPowerSourceWiredAssessedInputFrequencyAttributeCommand>(), //
        make_unique<SetPowerSourceWiredCurrentTypeAttributeCommand>(),            //
        make_unique<SetPowerSourceWiredAssessedCurrentAttributeCommand>(),        //
        make_unique<SetPowerSourceWiredNominalVoltageAttributeCommand>(),         //
        make_unique<SetPowerSourceWiredMaximumCurrentAttributeCommand>(),         //
        make_unique<SetPowerSourceWiredPresentAttributeCommand>(),                //
        make_unique<SetPowerSourceBatVoltageAttributeCommand>(),                  //
        make_unique<SetPowerSourceBatPercentRemainingAttributeCommand>(),         //
        make_unique<SetPowerSourceBatTimeRemainingAttributeCommand>(),            //
        make_unique<SetPowerSourceBatChargeLevelAttributeCommand>(),              //
        make_unique<SetPowerSourceBatReplacementNeededAttributeCommand>(),        //
        make_unique<SetPowerSourceBatReplaceabilityAttributeCommand>(),           //
        make_unique<SetPowerSourceBatPresentAttributeCommand>(),                  //
        make_unique<SetPowerSourceBatReplacementDescriptionAttributeCommand>(),   //
        make_unique<SetPowerSourceBatCommonDesignationAttributeCommand>(),        //
        make_unique<SetPowerSourceBatANSIDesignationAttributeCommand>(),          //
        make_unique<SetPowerSourceBatIECDesignationAttributeCommand>(),           //
        make_unique<SetPowerSourceBatApprovedChemistryAttributeCommand>(),        //
        make_unique<SetPowerSourceBatCapacityAttributeCommand>(),                 //
        make_unique<SetPowerSourceBatQuantityAttributeCommand>(),                 //
        make_unique<SetPowerSourceBatChargeStateAttributeCommand>(),              //
        make_unique<SetPowerSourceBatTimeToFullChargeAttributeCommand>(),         //
        make_unique<SetPowerSourceBatFunctionalWhileChargingAttributeCommand>(),  //
        make_unique<SetPowerSourceBatChargingCurrentAttributeCommand>(),          //
        make_unique<SetPowerSourceFeatureMapAttributeCommand>(),                  //
        make_unique<SetPowerSourceClusterRevisionAttributeCommand>(),             //
    };

    commands.Register(clusterName, clusterCommands);
}
void registergeneralCommissioningSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "GeneralCommissioning";

    commands_list clusterCommands = {
        make_unique<SetGeneralCommissioningBreadcrumbAttributeCommand>(),                   //
        make_unique<SetGeneralCommissioningRegulatoryConfigAttributeCommand>(),             //
        make_unique<SetGeneralCommissioningLocationCapabilityAttributeCommand>(),           //
        make_unique<SetGeneralCommissioningSupportsConcurrentConnectionAttributeCommand>(), //
        make_unique<SetGeneralCommissioningFeatureMapAttributeCommand>(),                   //
        make_unique<SetGeneralCommissioningClusterRevisionAttributeCommand>(),              //
    };

    commands.Register(clusterName, clusterCommands);
}
void registernetworkCommissioningSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "NetworkCommissioning";

    commands_list clusterCommands = {
        make_unique<SetNetworkCommissioningMaxNetworksAttributeCommand>(),           //
        make_unique<SetNetworkCommissioningScanMaxTimeSecondsAttributeCommand>(),    //
        make_unique<SetNetworkCommissioningConnectMaxTimeSecondsAttributeCommand>(), //
        make_unique<SetNetworkCommissioningInterfaceEnabledAttributeCommand>(),      //
        make_unique<SetNetworkCommissioningLastNetworkingStatusAttributeCommand>(),  //
        make_unique<SetNetworkCommissioningLastNetworkIDAttributeCommand>(),         //
        make_unique<SetNetworkCommissioningLastConnectErrorValueAttributeCommand>(), //
        make_unique<SetNetworkCommissioningFeatureMapAttributeCommand>(),            //
        make_unique<SetNetworkCommissioningClusterRevisionAttributeCommand>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerdiagnosticLogsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "DiagnosticLogs";

    commands_list clusterCommands = {
        make_unique<SetDiagnosticLogsFeatureMapAttributeCommand>(),      //
        make_unique<SetDiagnosticLogsClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registergeneralDiagnosticsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "GeneralDiagnostics";

    commands_list clusterCommands = {
        make_unique<SetGeneralDiagnosticsRebootCountAttributeCommand>(),              //
        make_unique<SetGeneralDiagnosticsUpTimeAttributeCommand>(),                   //
        make_unique<SetGeneralDiagnosticsTotalOperationalHoursAttributeCommand>(),    //
        make_unique<SetGeneralDiagnosticsBootReasonAttributeCommand>(),               //
        make_unique<SetGeneralDiagnosticsTestEventTriggersEnabledAttributeCommand>(), //
        make_unique<SetGeneralDiagnosticsFeatureMapAttributeCommand>(),               //
        make_unique<SetGeneralDiagnosticsClusterRevisionAttributeCommand>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registersoftwareDiagnosticsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "SoftwareDiagnostics";

    commands_list clusterCommands = {
        make_unique<SetSoftwareDiagnosticsCurrentHeapFreeAttributeCommand>(),          //
        make_unique<SetSoftwareDiagnosticsCurrentHeapUsedAttributeCommand>(),          //
        make_unique<SetSoftwareDiagnosticsCurrentHeapHighWatermarkAttributeCommand>(), //
        make_unique<SetSoftwareDiagnosticsFeatureMapAttributeCommand>(),               //
        make_unique<SetSoftwareDiagnosticsClusterRevisionAttributeCommand>(),          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerthreadNetworkDiagnosticsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ThreadNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<SetThreadNetworkDiagnosticsChannelAttributeCommand>(),                           //
        make_unique<SetThreadNetworkDiagnosticsRoutingRoleAttributeCommand>(),                       //
        make_unique<SetThreadNetworkDiagnosticsNetworkNameAttributeCommand>(),                       //
        make_unique<SetThreadNetworkDiagnosticsPanIdAttributeCommand>(),                             //
        make_unique<SetThreadNetworkDiagnosticsExtendedPanIdAttributeCommand>(),                     //
        make_unique<SetThreadNetworkDiagnosticsMeshLocalPrefixAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsOverrunCountAttributeCommand>(),                      //
        make_unique<SetThreadNetworkDiagnosticsPartitionIdAttributeCommand>(),                       //
        make_unique<SetThreadNetworkDiagnosticsWeightingAttributeCommand>(),                         //
        make_unique<SetThreadNetworkDiagnosticsDataVersionAttributeCommand>(),                       //
        make_unique<SetThreadNetworkDiagnosticsStableDataVersionAttributeCommand>(),                 //
        make_unique<SetThreadNetworkDiagnosticsLeaderRouterIdAttributeCommand>(),                    //
        make_unique<SetThreadNetworkDiagnosticsDetachedRoleCountAttributeCommand>(),                 //
        make_unique<SetThreadNetworkDiagnosticsChildRoleCountAttributeCommand>(),                    //
        make_unique<SetThreadNetworkDiagnosticsRouterRoleCountAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsLeaderRoleCountAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsAttachAttemptCountAttributeCommand>(),                //
        make_unique<SetThreadNetworkDiagnosticsPartitionIdChangeCountAttributeCommand>(),            //
        make_unique<SetThreadNetworkDiagnosticsBetterPartitionAttachAttemptCountAttributeCommand>(), //
        make_unique<SetThreadNetworkDiagnosticsParentChangeCountAttributeCommand>(),                 //
        make_unique<SetThreadNetworkDiagnosticsTxTotalCountAttributeCommand>(),                      //
        make_unique<SetThreadNetworkDiagnosticsTxUnicastCountAttributeCommand>(),                    //
        make_unique<SetThreadNetworkDiagnosticsTxBroadcastCountAttributeCommand>(),                  //
        make_unique<SetThreadNetworkDiagnosticsTxAckRequestedCountAttributeCommand>(),               //
        make_unique<SetThreadNetworkDiagnosticsTxAckedCountAttributeCommand>(),                      //
        make_unique<SetThreadNetworkDiagnosticsTxNoAckRequestedCountAttributeCommand>(),             //
        make_unique<SetThreadNetworkDiagnosticsTxDataCountAttributeCommand>(),                       //
        make_unique<SetThreadNetworkDiagnosticsTxDataPollCountAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsTxBeaconCountAttributeCommand>(),                     //
        make_unique<SetThreadNetworkDiagnosticsTxBeaconRequestCountAttributeCommand>(),              //
        make_unique<SetThreadNetworkDiagnosticsTxOtherCountAttributeCommand>(),                      //
        make_unique<SetThreadNetworkDiagnosticsTxRetryCountAttributeCommand>(),                      //
        make_unique<SetThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCountAttributeCommand>(),       //
        make_unique<SetThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCountAttributeCommand>(),     //
        make_unique<SetThreadNetworkDiagnosticsTxErrCcaCountAttributeCommand>(),                     //
        make_unique<SetThreadNetworkDiagnosticsTxErrAbortCountAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsTxErrBusyChannelCountAttributeCommand>(),             //
        make_unique<SetThreadNetworkDiagnosticsRxTotalCountAttributeCommand>(),                      //
        make_unique<SetThreadNetworkDiagnosticsRxUnicastCountAttributeCommand>(),                    //
        make_unique<SetThreadNetworkDiagnosticsRxBroadcastCountAttributeCommand>(),                  //
        make_unique<SetThreadNetworkDiagnosticsRxDataCountAttributeCommand>(),                       //
        make_unique<SetThreadNetworkDiagnosticsRxDataPollCountAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsRxBeaconCountAttributeCommand>(),                     //
        make_unique<SetThreadNetworkDiagnosticsRxBeaconRequestCountAttributeCommand>(),              //
        make_unique<SetThreadNetworkDiagnosticsRxOtherCountAttributeCommand>(),                      //
        make_unique<SetThreadNetworkDiagnosticsRxAddressFilteredCountAttributeCommand>(),            //
        make_unique<SetThreadNetworkDiagnosticsRxDestAddrFilteredCountAttributeCommand>(),           //
        make_unique<SetThreadNetworkDiagnosticsRxDuplicatedCountAttributeCommand>(),                 //
        make_unique<SetThreadNetworkDiagnosticsRxErrNoFrameCountAttributeCommand>(),                 //
        make_unique<SetThreadNetworkDiagnosticsRxErrUnknownNeighborCountAttributeCommand>(),         //
        make_unique<SetThreadNetworkDiagnosticsRxErrInvalidSrcAddrCountAttributeCommand>(),          //
        make_unique<SetThreadNetworkDiagnosticsRxErrSecCountAttributeCommand>(),                     //
        make_unique<SetThreadNetworkDiagnosticsRxErrFcsCountAttributeCommand>(),                     //
        make_unique<SetThreadNetworkDiagnosticsRxErrOtherCountAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsActiveTimestampAttributeCommand>(),                   //
        make_unique<SetThreadNetworkDiagnosticsPendingTimestampAttributeCommand>(),                  //
        make_unique<SetThreadNetworkDiagnosticsDelayAttributeCommand>(),                             //
        make_unique<SetThreadNetworkDiagnosticsChannelPage0MaskAttributeCommand>(),                  //
        make_unique<SetThreadNetworkDiagnosticsFeatureMapAttributeCommand>(),                        //
        make_unique<SetThreadNetworkDiagnosticsClusterRevisionAttributeCommand>(),                   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerwiFiNetworkDiagnosticsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "WiFiNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<SetWiFiNetworkDiagnosticsBssidAttributeCommand>(),                  //
        make_unique<SetWiFiNetworkDiagnosticsSecurityTypeAttributeCommand>(),           //
        make_unique<SetWiFiNetworkDiagnosticsWiFiVersionAttributeCommand>(),            //
        make_unique<SetWiFiNetworkDiagnosticsChannelNumberAttributeCommand>(),          //
        make_unique<SetWiFiNetworkDiagnosticsRssiAttributeCommand>(),                   //
        make_unique<SetWiFiNetworkDiagnosticsBeaconLostCountAttributeCommand>(),        //
        make_unique<SetWiFiNetworkDiagnosticsBeaconRxCountAttributeCommand>(),          //
        make_unique<SetWiFiNetworkDiagnosticsPacketMulticastRxCountAttributeCommand>(), //
        make_unique<SetWiFiNetworkDiagnosticsPacketMulticastTxCountAttributeCommand>(), //
        make_unique<SetWiFiNetworkDiagnosticsPacketUnicastRxCountAttributeCommand>(),   //
        make_unique<SetWiFiNetworkDiagnosticsPacketUnicastTxCountAttributeCommand>(),   //
        make_unique<SetWiFiNetworkDiagnosticsCurrentMaxRateAttributeCommand>(),         //
        make_unique<SetWiFiNetworkDiagnosticsOverrunCountAttributeCommand>(),           //
        make_unique<SetWiFiNetworkDiagnosticsFeatureMapAttributeCommand>(),             //
        make_unique<SetWiFiNetworkDiagnosticsClusterRevisionAttributeCommand>(),        //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerethernetNetworkDiagnosticsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "EthernetNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<SetEthernetNetworkDiagnosticsPHYRateAttributeCommand>(),         //
        make_unique<SetEthernetNetworkDiagnosticsFullDuplexAttributeCommand>(),      //
        make_unique<SetEthernetNetworkDiagnosticsPacketRxCountAttributeCommand>(),   //
        make_unique<SetEthernetNetworkDiagnosticsPacketTxCountAttributeCommand>(),   //
        make_unique<SetEthernetNetworkDiagnosticsTxErrCountAttributeCommand>(),      //
        make_unique<SetEthernetNetworkDiagnosticsCollisionCountAttributeCommand>(),  //
        make_unique<SetEthernetNetworkDiagnosticsOverrunCountAttributeCommand>(),    //
        make_unique<SetEthernetNetworkDiagnosticsCarrierDetectAttributeCommand>(),   //
        make_unique<SetEthernetNetworkDiagnosticsTimeSinceResetAttributeCommand>(),  //
        make_unique<SetEthernetNetworkDiagnosticsFeatureMapAttributeCommand>(),      //
        make_unique<SetEthernetNetworkDiagnosticsClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registertimeSynchronizationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "TimeSynchronization";

    commands_list clusterCommands = {
        make_unique<SetTimeSynchronizationUTCTimeAttributeCommand>(),           //
        make_unique<SetTimeSynchronizationGranularityAttributeCommand>(),       //
        make_unique<SetTimeSynchronizationTimeSourceAttributeCommand>(),        //
        make_unique<SetTimeSynchronizationTrustedTimeNodeIdAttributeCommand>(), //
        make_unique<SetTimeSynchronizationDefaultNtpAttributeCommand>(),        //
        make_unique<SetTimeSynchronizationLocalTimeAttributeCommand>(),         //
        make_unique<SetTimeSynchronizationTimeZoneDatabaseAttributeCommand>(),  //
        make_unique<SetTimeSynchronizationNtpServerPortAttributeCommand>(),     //
        make_unique<SetTimeSynchronizationFeatureMapAttributeCommand>(),        //
        make_unique<SetTimeSynchronizationClusterRevisionAttributeCommand>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerbridgedDeviceBasicInformationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "BridgedDeviceBasicInformation";

    commands_list clusterCommands = {
        make_unique<SetBridgedDeviceBasicInformationVendorNameAttributeCommand>(),            //
        make_unique<SetBridgedDeviceBasicInformationVendorIDAttributeCommand>(),              //
        make_unique<SetBridgedDeviceBasicInformationProductNameAttributeCommand>(),           //
        make_unique<SetBridgedDeviceBasicInformationNodeLabelAttributeCommand>(),             //
        make_unique<SetBridgedDeviceBasicInformationHardwareVersionAttributeCommand>(),       //
        make_unique<SetBridgedDeviceBasicInformationHardwareVersionStringAttributeCommand>(), //
        make_unique<SetBridgedDeviceBasicInformationSoftwareVersionAttributeCommand>(),       //
        make_unique<SetBridgedDeviceBasicInformationSoftwareVersionStringAttributeCommand>(), //
        make_unique<SetBridgedDeviceBasicInformationManufacturingDateAttributeCommand>(),     //
        make_unique<SetBridgedDeviceBasicInformationPartNumberAttributeCommand>(),            //
        make_unique<SetBridgedDeviceBasicInformationProductURLAttributeCommand>(),            //
        make_unique<SetBridgedDeviceBasicInformationProductLabelAttributeCommand>(),          //
        make_unique<SetBridgedDeviceBasicInformationSerialNumberAttributeCommand>(),          //
        make_unique<SetBridgedDeviceBasicInformationReachableAttributeCommand>(),             //
        make_unique<SetBridgedDeviceBasicInformationUniqueIDAttributeCommand>(),              //
        make_unique<SetBridgedDeviceBasicInformationFeatureMapAttributeCommand>(),            //
        make_unique<SetBridgedDeviceBasicInformationClusterRevisionAttributeCommand>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerswitchSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Switch";

    commands_list clusterCommands = {
        make_unique<SetSwitchNumberOfPositionsAttributeCommand>(), //
        make_unique<SetSwitchCurrentPositionAttributeCommand>(),   //
        make_unique<SetSwitchMultiPressMaxAttributeCommand>(),     //
        make_unique<SetSwitchFeatureMapAttributeCommand>(),        //
        make_unique<SetSwitchClusterRevisionAttributeCommand>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeradministratorCommissioningSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "AdministratorCommissioning";

    commands_list clusterCommands = {
        make_unique<SetAdministratorCommissioningWindowStatusAttributeCommand>(),     //
        make_unique<SetAdministratorCommissioningAdminFabricIndexAttributeCommand>(), //
        make_unique<SetAdministratorCommissioningAdminVendorIdAttributeCommand>(),    //
        make_unique<SetAdministratorCommissioningFeatureMapAttributeCommand>(),       //
        make_unique<SetAdministratorCommissioningClusterRevisionAttributeCommand>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeroperationalCredentialsSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "OperationalCredentials";

    commands_list clusterCommands = {
        make_unique<SetOperationalCredentialsSupportedFabricsAttributeCommand>(),    //
        make_unique<SetOperationalCredentialsCommissionedFabricsAttributeCommand>(), //
        make_unique<SetOperationalCredentialsCurrentFabricIndexAttributeCommand>(),  //
        make_unique<SetOperationalCredentialsFeatureMapAttributeCommand>(),          //
        make_unique<SetOperationalCredentialsClusterRevisionAttributeCommand>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registergroupKeyManagementSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "GroupKeyManagement";

    commands_list clusterCommands = {
        make_unique<SetGroupKeyManagementMaxGroupsPerFabricAttributeCommand>(),    //
        make_unique<SetGroupKeyManagementMaxGroupKeysPerFabricAttributeCommand>(), //
        make_unique<SetGroupKeyManagementFeatureMapAttributeCommand>(),            //
        make_unique<SetGroupKeyManagementClusterRevisionAttributeCommand>(),       //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerfixedLabelSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "FixedLabel";

    commands_list clusterCommands = {
        make_unique<SetFixedLabelFeatureMapAttributeCommand>(),      //
        make_unique<SetFixedLabelClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeruserLabelSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "UserLabel";

    commands_list clusterCommands = {
        make_unique<SetUserLabelFeatureMapAttributeCommand>(),      //
        make_unique<SetUserLabelClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerproxyConfigurationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ProxyConfiguration";

    commands_list clusterCommands = {
        make_unique<SetProxyConfigurationFeatureMapAttributeCommand>(),      //
        make_unique<SetProxyConfigurationClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerproxyDiscoverySetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ProxyDiscovery";

    commands_list clusterCommands = {
        make_unique<SetProxyDiscoveryFeatureMapAttributeCommand>(),      //
        make_unique<SetProxyDiscoveryClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerproxyValidSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ProxyValid";

    commands_list clusterCommands = {
        make_unique<SetProxyValidFeatureMapAttributeCommand>(),      //
        make_unique<SetProxyValidClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerbooleanStateSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "BooleanState";

    commands_list clusterCommands = {
        make_unique<SetBooleanStateStateValueAttributeCommand>(),      //
        make_unique<SetBooleanStateFeatureMapAttributeCommand>(),      //
        make_unique<SetBooleanStateClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registermodeSelectSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ModeSelect";

    commands_list clusterCommands = {
        make_unique<SetModeSelectDescriptionAttributeCommand>(),       //
        make_unique<SetModeSelectStandardNamespaceAttributeCommand>(), //
        make_unique<SetModeSelectCurrentModeAttributeCommand>(),       //
        make_unique<SetModeSelectStartUpModeAttributeCommand>(),       //
        make_unique<SetModeSelectOnModeAttributeCommand>(),            //
        make_unique<SetModeSelectFeatureMapAttributeCommand>(),        //
        make_unique<SetModeSelectClusterRevisionAttributeCommand>(),   //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerdoorLockSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<SetDoorLockLockStateAttributeCommand>(),                                //
        make_unique<SetDoorLockLockTypeAttributeCommand>(),                                 //
        make_unique<SetDoorLockActuatorEnabledAttributeCommand>(),                          //
        make_unique<SetDoorLockDoorStateAttributeCommand>(),                                //
        make_unique<SetDoorLockDoorOpenEventsAttributeCommand>(),                           //
        make_unique<SetDoorLockDoorClosedEventsAttributeCommand>(),                         //
        make_unique<SetDoorLockOpenPeriodAttributeCommand>(),                               //
        make_unique<SetDoorLockNumberOfTotalUsersSupportedAttributeCommand>(),              //
        make_unique<SetDoorLockNumberOfPINUsersSupportedAttributeCommand>(),                //
        make_unique<SetDoorLockNumberOfRFIDUsersSupportedAttributeCommand>(),               //
        make_unique<SetDoorLockNumberOfWeekDaySchedulesSupportedPerUserAttributeCommand>(), //
        make_unique<SetDoorLockNumberOfYearDaySchedulesSupportedPerUserAttributeCommand>(), //
        make_unique<SetDoorLockNumberOfHolidaySchedulesSupportedAttributeCommand>(),        //
        make_unique<SetDoorLockMaxPINCodeLengthAttributeCommand>(),                         //
        make_unique<SetDoorLockMinPINCodeLengthAttributeCommand>(),                         //
        make_unique<SetDoorLockMaxRFIDCodeLengthAttributeCommand>(),                        //
        make_unique<SetDoorLockMinRFIDCodeLengthAttributeCommand>(),                        //
        make_unique<SetDoorLockCredentialRulesSupportAttributeCommand>(),                   //
        make_unique<SetDoorLockNumberOfCredentialsSupportedPerUserAttributeCommand>(),      //
        make_unique<SetDoorLockLanguageAttributeCommand>(),                                 //
        make_unique<SetDoorLockLEDSettingsAttributeCommand>(),                              //
        make_unique<SetDoorLockAutoRelockTimeAttributeCommand>(),                           //
        make_unique<SetDoorLockSoundVolumeAttributeCommand>(),                              //
        make_unique<SetDoorLockOperatingModeAttributeCommand>(),                            //
        make_unique<SetDoorLockSupportedOperatingModesAttributeCommand>(),                  //
        make_unique<SetDoorLockDefaultConfigurationRegisterAttributeCommand>(),             //
        make_unique<SetDoorLockEnableLocalProgrammingAttributeCommand>(),                   //
        make_unique<SetDoorLockEnableOneTouchLockingAttributeCommand>(),                    //
        make_unique<SetDoorLockEnableInsideStatusLEDAttributeCommand>(),                    //
        make_unique<SetDoorLockEnablePrivacyModeButtonAttributeCommand>(),                  //
        make_unique<SetDoorLockLocalProgrammingFeaturesAttributeCommand>(),                 //
        make_unique<SetDoorLockWrongCodeEntryLimitAttributeCommand>(),                      //
        make_unique<SetDoorLockUserCodeTemporaryDisableTimeAttributeCommand>(),             //
        make_unique<SetDoorLockSendPINOverTheAirAttributeCommand>(),                        //
        make_unique<SetDoorLockRequirePINforRemoteOperationAttributeCommand>(),             //
        make_unique<SetDoorLockExpiringUserTimeoutAttributeCommand>(),                      //
        make_unique<SetDoorLockFeatureMapAttributeCommand>(),                               //
        make_unique<SetDoorLockClusterRevisionAttributeCommand>(),                          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerwindowCoveringSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "WindowCovering";

    commands_list clusterCommands = {
        make_unique<SetWindowCoveringTypeAttributeCommand>(),                             //
        make_unique<SetWindowCoveringPhysicalClosedLimitLiftAttributeCommand>(),          //
        make_unique<SetWindowCoveringPhysicalClosedLimitTiltAttributeCommand>(),          //
        make_unique<SetWindowCoveringCurrentPositionLiftAttributeCommand>(),              //
        make_unique<SetWindowCoveringCurrentPositionTiltAttributeCommand>(),              //
        make_unique<SetWindowCoveringNumberOfActuationsLiftAttributeCommand>(),           //
        make_unique<SetWindowCoveringNumberOfActuationsTiltAttributeCommand>(),           //
        make_unique<SetWindowCoveringConfigStatusAttributeCommand>(),                     //
        make_unique<SetWindowCoveringCurrentPositionLiftPercentageAttributeCommand>(),    //
        make_unique<SetWindowCoveringCurrentPositionTiltPercentageAttributeCommand>(),    //
        make_unique<SetWindowCoveringOperationalStatusAttributeCommand>(),                //
        make_unique<SetWindowCoveringTargetPositionLiftPercent100thsAttributeCommand>(),  //
        make_unique<SetWindowCoveringTargetPositionTiltPercent100thsAttributeCommand>(),  //
        make_unique<SetWindowCoveringEndProductTypeAttributeCommand>(),                   //
        make_unique<SetWindowCoveringCurrentPositionLiftPercent100thsAttributeCommand>(), //
        make_unique<SetWindowCoveringCurrentPositionTiltPercent100thsAttributeCommand>(), //
        make_unique<SetWindowCoveringInstalledOpenLimitLiftAttributeCommand>(),           //
        make_unique<SetWindowCoveringInstalledClosedLimitLiftAttributeCommand>(),         //
        make_unique<SetWindowCoveringInstalledOpenLimitTiltAttributeCommand>(),           //
        make_unique<SetWindowCoveringInstalledClosedLimitTiltAttributeCommand>(),         //
        make_unique<SetWindowCoveringModeAttributeCommand>(),                             //
        make_unique<SetWindowCoveringSafetyStatusAttributeCommand>(),                     //
        make_unique<SetWindowCoveringFeatureMapAttributeCommand>(),                       //
        make_unique<SetWindowCoveringClusterRevisionAttributeCommand>(),                  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerbarrierControlSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<SetBarrierControlBarrierMovingStateAttributeCommand>(),        //
        make_unique<SetBarrierControlBarrierSafetyStatusAttributeCommand>(),       //
        make_unique<SetBarrierControlBarrierCapabilitiesAttributeCommand>(),       //
        make_unique<SetBarrierControlBarrierOpenEventsAttributeCommand>(),         //
        make_unique<SetBarrierControlBarrierCloseEventsAttributeCommand>(),        //
        make_unique<SetBarrierControlBarrierCommandOpenEventsAttributeCommand>(),  //
        make_unique<SetBarrierControlBarrierCommandCloseEventsAttributeCommand>(), //
        make_unique<SetBarrierControlBarrierOpenPeriodAttributeCommand>(),         //
        make_unique<SetBarrierControlBarrierClosePeriodAttributeCommand>(),        //
        make_unique<SetBarrierControlBarrierPositionAttributeCommand>(),           //
        make_unique<SetBarrierControlFeatureMapAttributeCommand>(),                //
        make_unique<SetBarrierControlClusterRevisionAttributeCommand>(),           //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerpumpConfigurationAndControlSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "PumpConfigurationAndControl";

    commands_list clusterCommands = {
        make_unique<SetPumpConfigurationAndControlMaxPressureAttributeCommand>(),            //
        make_unique<SetPumpConfigurationAndControlMaxSpeedAttributeCommand>(),               //
        make_unique<SetPumpConfigurationAndControlMaxFlowAttributeCommand>(),                //
        make_unique<SetPumpConfigurationAndControlMinConstPressureAttributeCommand>(),       //
        make_unique<SetPumpConfigurationAndControlMaxConstPressureAttributeCommand>(),       //
        make_unique<SetPumpConfigurationAndControlMinCompPressureAttributeCommand>(),        //
        make_unique<SetPumpConfigurationAndControlMaxCompPressureAttributeCommand>(),        //
        make_unique<SetPumpConfigurationAndControlMinConstSpeedAttributeCommand>(),          //
        make_unique<SetPumpConfigurationAndControlMaxConstSpeedAttributeCommand>(),          //
        make_unique<SetPumpConfigurationAndControlMinConstFlowAttributeCommand>(),           //
        make_unique<SetPumpConfigurationAndControlMaxConstFlowAttributeCommand>(),           //
        make_unique<SetPumpConfigurationAndControlMinConstTempAttributeCommand>(),           //
        make_unique<SetPumpConfigurationAndControlMaxConstTempAttributeCommand>(),           //
        make_unique<SetPumpConfigurationAndControlPumpStatusAttributeCommand>(),             //
        make_unique<SetPumpConfigurationAndControlEffectiveOperationModeAttributeCommand>(), //
        make_unique<SetPumpConfigurationAndControlEffectiveControlModeAttributeCommand>(),   //
        make_unique<SetPumpConfigurationAndControlCapacityAttributeCommand>(),               //
        make_unique<SetPumpConfigurationAndControlSpeedAttributeCommand>(),                  //
        make_unique<SetPumpConfigurationAndControlLifetimeRunningHoursAttributeCommand>(),   //
        make_unique<SetPumpConfigurationAndControlPowerAttributeCommand>(),                  //
        make_unique<SetPumpConfigurationAndControlLifetimeEnergyConsumedAttributeCommand>(), //
        make_unique<SetPumpConfigurationAndControlOperationModeAttributeCommand>(),          //
        make_unique<SetPumpConfigurationAndControlControlModeAttributeCommand>(),            //
        make_unique<SetPumpConfigurationAndControlFeatureMapAttributeCommand>(),             //
        make_unique<SetPumpConfigurationAndControlClusterRevisionAttributeCommand>(),        //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerthermostatSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Thermostat";

    commands_list clusterCommands = {
        make_unique<SetThermostatLocalTemperatureAttributeCommand>(),                   //
        make_unique<SetThermostatOutdoorTemperatureAttributeCommand>(),                 //
        make_unique<SetThermostatOccupancyAttributeCommand>(),                          //
        make_unique<SetThermostatAbsMinHeatSetpointLimitAttributeCommand>(),            //
        make_unique<SetThermostatAbsMaxHeatSetpointLimitAttributeCommand>(),            //
        make_unique<SetThermostatAbsMinCoolSetpointLimitAttributeCommand>(),            //
        make_unique<SetThermostatAbsMaxCoolSetpointLimitAttributeCommand>(),            //
        make_unique<SetThermostatPICoolingDemandAttributeCommand>(),                    //
        make_unique<SetThermostatPIHeatingDemandAttributeCommand>(),                    //
        make_unique<SetThermostatHVACSystemTypeConfigurationAttributeCommand>(),        //
        make_unique<SetThermostatLocalTemperatureCalibrationAttributeCommand>(),        //
        make_unique<SetThermostatOccupiedCoolingSetpointAttributeCommand>(),            //
        make_unique<SetThermostatOccupiedHeatingSetpointAttributeCommand>(),            //
        make_unique<SetThermostatUnoccupiedCoolingSetpointAttributeCommand>(),          //
        make_unique<SetThermostatUnoccupiedHeatingSetpointAttributeCommand>(),          //
        make_unique<SetThermostatMinHeatSetpointLimitAttributeCommand>(),               //
        make_unique<SetThermostatMaxHeatSetpointLimitAttributeCommand>(),               //
        make_unique<SetThermostatMinCoolSetpointLimitAttributeCommand>(),               //
        make_unique<SetThermostatMaxCoolSetpointLimitAttributeCommand>(),               //
        make_unique<SetThermostatMinSetpointDeadBandAttributeCommand>(),                //
        make_unique<SetThermostatRemoteSensingAttributeCommand>(),                      //
        make_unique<SetThermostatControlSequenceOfOperationAttributeCommand>(),         //
        make_unique<SetThermostatSystemModeAttributeCommand>(),                         //
        make_unique<SetThermostatThermostatRunningModeAttributeCommand>(),              //
        make_unique<SetThermostatStartOfWeekAttributeCommand>(),                        //
        make_unique<SetThermostatNumberOfWeeklyTransitionsAttributeCommand>(),          //
        make_unique<SetThermostatNumberOfDailyTransitionsAttributeCommand>(),           //
        make_unique<SetThermostatTemperatureSetpointHoldAttributeCommand>(),            //
        make_unique<SetThermostatTemperatureSetpointHoldDurationAttributeCommand>(),    //
        make_unique<SetThermostatThermostatProgrammingOperationModeAttributeCommand>(), //
        make_unique<SetThermostatThermostatRunningStateAttributeCommand>(),             //
        make_unique<SetThermostatSetpointChangeSourceAttributeCommand>(),               //
        make_unique<SetThermostatSetpointChangeAmountAttributeCommand>(),               //
        make_unique<SetThermostatSetpointChangeSourceTimestampAttributeCommand>(),      //
        make_unique<SetThermostatOccupiedSetbackAttributeCommand>(),                    //
        make_unique<SetThermostatOccupiedSetbackMinAttributeCommand>(),                 //
        make_unique<SetThermostatOccupiedSetbackMaxAttributeCommand>(),                 //
        make_unique<SetThermostatUnoccupiedSetbackAttributeCommand>(),                  //
        make_unique<SetThermostatUnoccupiedSetbackMinAttributeCommand>(),               //
        make_unique<SetThermostatUnoccupiedSetbackMaxAttributeCommand>(),               //
        make_unique<SetThermostatEmergencyHeatDeltaAttributeCommand>(),                 //
        make_unique<SetThermostatACTypeAttributeCommand>(),                             //
        make_unique<SetThermostatACCapacityAttributeCommand>(),                         //
        make_unique<SetThermostatACRefrigerantTypeAttributeCommand>(),                  //
        make_unique<SetThermostatACCompressorTypeAttributeCommand>(),                   //
        make_unique<SetThermostatACErrorCodeAttributeCommand>(),                        //
        make_unique<SetThermostatACLouverPositionAttributeCommand>(),                   //
        make_unique<SetThermostatACCoilTemperatureAttributeCommand>(),                  //
        make_unique<SetThermostatACCapacityformatAttributeCommand>(),                   //
        make_unique<SetThermostatFeatureMapAttributeCommand>(),                         //
        make_unique<SetThermostatClusterRevisionAttributeCommand>(),                    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerfanControlSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "FanControl";

    commands_list clusterCommands = {
        make_unique<SetFanControlFanModeAttributeCommand>(),         //
        make_unique<SetFanControlFanModeSequenceAttributeCommand>(), //
        make_unique<SetFanControlPercentSettingAttributeCommand>(),  //
        make_unique<SetFanControlPercentCurrentAttributeCommand>(),  //
        make_unique<SetFanControlSpeedMaxAttributeCommand>(),        //
        make_unique<SetFanControlSpeedSettingAttributeCommand>(),    //
        make_unique<SetFanControlSpeedCurrentAttributeCommand>(),    //
        make_unique<SetFanControlRockSupportAttributeCommand>(),     //
        make_unique<SetFanControlRockSettingAttributeCommand>(),     //
        make_unique<SetFanControlWindSupportAttributeCommand>(),     //
        make_unique<SetFanControlWindSettingAttributeCommand>(),     //
        make_unique<SetFanControlFeatureMapAttributeCommand>(),      //
        make_unique<SetFanControlClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerthermostatUserInterfaceConfigurationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ThermostatUserInterfaceConfiguration";

    commands_list clusterCommands = {
        make_unique<SetThermostatUserInterfaceConfigurationTemperatureDisplayModeAttributeCommand>(),        //
        make_unique<SetThermostatUserInterfaceConfigurationKeypadLockoutAttributeCommand>(),                 //
        make_unique<SetThermostatUserInterfaceConfigurationScheduleProgrammingVisibilityAttributeCommand>(), //
        make_unique<SetThermostatUserInterfaceConfigurationFeatureMapAttributeCommand>(),                    //
        make_unique<SetThermostatUserInterfaceConfigurationClusterRevisionAttributeCommand>(),               //
    };

    commands.Register(clusterName, clusterCommands);
}
void registercolorControlSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<SetColorControlCurrentHueAttributeCommand>(),                      //
        make_unique<SetColorControlCurrentSaturationAttributeCommand>(),               //
        make_unique<SetColorControlRemainingTimeAttributeCommand>(),                   //
        make_unique<SetColorControlCurrentXAttributeCommand>(),                        //
        make_unique<SetColorControlCurrentYAttributeCommand>(),                        //
        make_unique<SetColorControlDriftCompensationAttributeCommand>(),               //
        make_unique<SetColorControlCompensationTextAttributeCommand>(),                //
        make_unique<SetColorControlColorTemperatureMiredsAttributeCommand>(),          //
        make_unique<SetColorControlColorModeAttributeCommand>(),                       //
        make_unique<SetColorControlOptionsAttributeCommand>(),                         //
        make_unique<SetColorControlNumberOfPrimariesAttributeCommand>(),               //
        make_unique<SetColorControlPrimary1XAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary1YAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary1IntensityAttributeCommand>(),               //
        make_unique<SetColorControlPrimary2XAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary2YAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary2IntensityAttributeCommand>(),               //
        make_unique<SetColorControlPrimary3XAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary3YAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary3IntensityAttributeCommand>(),               //
        make_unique<SetColorControlPrimary4XAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary4YAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary4IntensityAttributeCommand>(),               //
        make_unique<SetColorControlPrimary5XAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary5YAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary5IntensityAttributeCommand>(),               //
        make_unique<SetColorControlPrimary6XAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary6YAttributeCommand>(),                       //
        make_unique<SetColorControlPrimary6IntensityAttributeCommand>(),               //
        make_unique<SetColorControlWhitePointXAttributeCommand>(),                     //
        make_unique<SetColorControlWhitePointYAttributeCommand>(),                     //
        make_unique<SetColorControlColorPointRXAttributeCommand>(),                    //
        make_unique<SetColorControlColorPointRYAttributeCommand>(),                    //
        make_unique<SetColorControlColorPointRIntensityAttributeCommand>(),            //
        make_unique<SetColorControlColorPointGXAttributeCommand>(),                    //
        make_unique<SetColorControlColorPointGYAttributeCommand>(),                    //
        make_unique<SetColorControlColorPointGIntensityAttributeCommand>(),            //
        make_unique<SetColorControlColorPointBXAttributeCommand>(),                    //
        make_unique<SetColorControlColorPointBYAttributeCommand>(),                    //
        make_unique<SetColorControlColorPointBIntensityAttributeCommand>(),            //
        make_unique<SetColorControlEnhancedCurrentHueAttributeCommand>(),              //
        make_unique<SetColorControlEnhancedColorModeAttributeCommand>(),               //
        make_unique<SetColorControlColorLoopActiveAttributeCommand>(),                 //
        make_unique<SetColorControlColorLoopDirectionAttributeCommand>(),              //
        make_unique<SetColorControlColorLoopTimeAttributeCommand>(),                   //
        make_unique<SetColorControlColorLoopStartEnhancedHueAttributeCommand>(),       //
        make_unique<SetColorControlColorLoopStoredEnhancedHueAttributeCommand>(),      //
        make_unique<SetColorControlColorCapabilitiesAttributeCommand>(),               //
        make_unique<SetColorControlColorTempPhysicalMinMiredsAttributeCommand>(),      //
        make_unique<SetColorControlColorTempPhysicalMaxMiredsAttributeCommand>(),      //
        make_unique<SetColorControlCoupleColorTempToLevelMinMiredsAttributeCommand>(), //
        make_unique<SetColorControlStartUpColorTemperatureMiredsAttributeCommand>(),   //
        make_unique<SetColorControlFeatureMapAttributeCommand>(),                      //
        make_unique<SetColorControlClusterRevisionAttributeCommand>(),                 //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerballastConfigurationSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "BallastConfiguration";

    commands_list clusterCommands = {
        make_unique<SetBallastConfigurationPhysicalMinLevelAttributeCommand>(),        //
        make_unique<SetBallastConfigurationPhysicalMaxLevelAttributeCommand>(),        //
        make_unique<SetBallastConfigurationBallastStatusAttributeCommand>(),           //
        make_unique<SetBallastConfigurationMinLevelAttributeCommand>(),                //
        make_unique<SetBallastConfigurationMaxLevelAttributeCommand>(),                //
        make_unique<SetBallastConfigurationIntrinsicBallastFactorAttributeCommand>(),  //
        make_unique<SetBallastConfigurationBallastFactorAdjustmentAttributeCommand>(), //
        make_unique<SetBallastConfigurationLampQuantityAttributeCommand>(),            //
        make_unique<SetBallastConfigurationLampTypeAttributeCommand>(),                //
        make_unique<SetBallastConfigurationLampManufacturerAttributeCommand>(),        //
        make_unique<SetBallastConfigurationLampRatedHoursAttributeCommand>(),          //
        make_unique<SetBallastConfigurationLampBurnHoursAttributeCommand>(),           //
        make_unique<SetBallastConfigurationLampAlarmModeAttributeCommand>(),           //
        make_unique<SetBallastConfigurationLampBurnHoursTripPointAttributeCommand>(),  //
        make_unique<SetBallastConfigurationFeatureMapAttributeCommand>(),              //
        make_unique<SetBallastConfigurationClusterRevisionAttributeCommand>(),         //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerilluminanceMeasurementSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "IlluminanceMeasurement";

    commands_list clusterCommands = {
        make_unique<SetIlluminanceMeasurementMeasuredValueAttributeCommand>(),    //
        make_unique<SetIlluminanceMeasurementMinMeasuredValueAttributeCommand>(), //
        make_unique<SetIlluminanceMeasurementMaxMeasuredValueAttributeCommand>(), //
        make_unique<SetIlluminanceMeasurementToleranceAttributeCommand>(),        //
        make_unique<SetIlluminanceMeasurementLightSensorTypeAttributeCommand>(),  //
        make_unique<SetIlluminanceMeasurementFeatureMapAttributeCommand>(),       //
        make_unique<SetIlluminanceMeasurementClusterRevisionAttributeCommand>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registertemperatureMeasurementSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<SetTemperatureMeasurementMeasuredValueAttributeCommand>(),    //
        make_unique<SetTemperatureMeasurementMinMeasuredValueAttributeCommand>(), //
        make_unique<SetTemperatureMeasurementMaxMeasuredValueAttributeCommand>(), //
        make_unique<SetTemperatureMeasurementToleranceAttributeCommand>(),        //
        make_unique<SetTemperatureMeasurementFeatureMapAttributeCommand>(),       //
        make_unique<SetTemperatureMeasurementClusterRevisionAttributeCommand>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerpressureMeasurementSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "PressureMeasurement";

    commands_list clusterCommands = {
        make_unique<SetPressureMeasurementMeasuredValueAttributeCommand>(),    //
        make_unique<SetPressureMeasurementMinMeasuredValueAttributeCommand>(), //
        make_unique<SetPressureMeasurementMaxMeasuredValueAttributeCommand>(), //
        make_unique<SetPressureMeasurementToleranceAttributeCommand>(),        //
        make_unique<SetPressureMeasurementScaledValueAttributeCommand>(),      //
        make_unique<SetPressureMeasurementMinScaledValueAttributeCommand>(),   //
        make_unique<SetPressureMeasurementMaxScaledValueAttributeCommand>(),   //
        make_unique<SetPressureMeasurementScaledToleranceAttributeCommand>(),  //
        make_unique<SetPressureMeasurementScaleAttributeCommand>(),            //
        make_unique<SetPressureMeasurementFeatureMapAttributeCommand>(),       //
        make_unique<SetPressureMeasurementClusterRevisionAttributeCommand>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerflowMeasurementSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "FlowMeasurement";

    commands_list clusterCommands = {
        make_unique<SetFlowMeasurementMeasuredValueAttributeCommand>(),    //
        make_unique<SetFlowMeasurementMinMeasuredValueAttributeCommand>(), //
        make_unique<SetFlowMeasurementMaxMeasuredValueAttributeCommand>(), //
        make_unique<SetFlowMeasurementToleranceAttributeCommand>(),        //
        make_unique<SetFlowMeasurementFeatureMapAttributeCommand>(),       //
        make_unique<SetFlowMeasurementClusterRevisionAttributeCommand>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerrelativeHumidityMeasurementSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "RelativeHumidityMeasurement";

    commands_list clusterCommands = {
        make_unique<SetRelativeHumidityMeasurementMeasuredValueAttributeCommand>(),    //
        make_unique<SetRelativeHumidityMeasurementMinMeasuredValueAttributeCommand>(), //
        make_unique<SetRelativeHumidityMeasurementMaxMeasuredValueAttributeCommand>(), //
        make_unique<SetRelativeHumidityMeasurementToleranceAttributeCommand>(),        //
        make_unique<SetRelativeHumidityMeasurementFeatureMapAttributeCommand>(),       //
        make_unique<SetRelativeHumidityMeasurementClusterRevisionAttributeCommand>(),  //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeroccupancySensingSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "OccupancySensing";

    commands_list clusterCommands = {
        make_unique<SetOccupancySensingOccupancyAttributeCommand>(),                                    //
        make_unique<SetOccupancySensingOccupancySensorTypeAttributeCommand>(),                          //
        make_unique<SetOccupancySensingOccupancySensorTypeBitmapAttributeCommand>(),                    //
        make_unique<SetOccupancySensingPIROccupiedToUnoccupiedDelayAttributeCommand>(),                 //
        make_unique<SetOccupancySensingPIRUnoccupiedToOccupiedDelayAttributeCommand>(),                 //
        make_unique<SetOccupancySensingPIRUnoccupiedToOccupiedThresholdAttributeCommand>(),             //
        make_unique<SetOccupancySensingUltrasonicOccupiedToUnoccupiedDelayAttributeCommand>(),          //
        make_unique<SetOccupancySensingUltrasonicUnoccupiedToOccupiedDelayAttributeCommand>(),          //
        make_unique<SetOccupancySensingUltrasonicUnoccupiedToOccupiedThresholdAttributeCommand>(),      //
        make_unique<SetOccupancySensingPhysicalContactOccupiedToUnoccupiedDelayAttributeCommand>(),     //
        make_unique<SetOccupancySensingPhysicalContactUnoccupiedToOccupiedDelayAttributeCommand>(),     //
        make_unique<SetOccupancySensingPhysicalContactUnoccupiedToOccupiedThresholdAttributeCommand>(), //
        make_unique<SetOccupancySensingFeatureMapAttributeCommand>(),                                   //
        make_unique<SetOccupancySensingClusterRevisionAttributeCommand>(),                              //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerwakeOnLanSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "WakeOnLan";

    commands_list clusterCommands = {
        make_unique<SetWakeOnLanMACAddressAttributeCommand>(),      //
        make_unique<SetWakeOnLanFeatureMapAttributeCommand>(),      //
        make_unique<SetWakeOnLanClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerchannelSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "Channel";

    commands_list clusterCommands = {
        make_unique<SetChannelFeatureMapAttributeCommand>(),      //
        make_unique<SetChannelClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registertargetNavigatorSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "TargetNavigator";

    commands_list clusterCommands = {
        make_unique<SetTargetNavigatorCurrentTargetAttributeCommand>(),   //
        make_unique<SetTargetNavigatorFeatureMapAttributeCommand>(),      //
        make_unique<SetTargetNavigatorClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registermediaPlaybackSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "MediaPlayback";

    commands_list clusterCommands = {
        make_unique<SetMediaPlaybackCurrentStateAttributeCommand>(),    //
        make_unique<SetMediaPlaybackStartTimeAttributeCommand>(),       //
        make_unique<SetMediaPlaybackDurationAttributeCommand>(),        //
        make_unique<SetMediaPlaybackPlaybackSpeedAttributeCommand>(),   //
        make_unique<SetMediaPlaybackSeekRangeEndAttributeCommand>(),    //
        make_unique<SetMediaPlaybackSeekRangeStartAttributeCommand>(),  //
        make_unique<SetMediaPlaybackFeatureMapAttributeCommand>(),      //
        make_unique<SetMediaPlaybackClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registermediaInputSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "MediaInput";

    commands_list clusterCommands = {
        make_unique<SetMediaInputCurrentInputAttributeCommand>(),    //
        make_unique<SetMediaInputFeatureMapAttributeCommand>(),      //
        make_unique<SetMediaInputClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerlowPowerSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "LowPower";

    commands_list clusterCommands = {
        make_unique<SetLowPowerFeatureMapAttributeCommand>(),      //
        make_unique<SetLowPowerClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerkeypadInputSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "KeypadInput";

    commands_list clusterCommands = {
        make_unique<SetKeypadInputFeatureMapAttributeCommand>(),      //
        make_unique<SetKeypadInputClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registercontentLauncherSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ContentLauncher";

    commands_list clusterCommands = {
        make_unique<SetContentLauncherSupportedStreamingProtocolsAttributeCommand>(), //
        make_unique<SetContentLauncherFeatureMapAttributeCommand>(),                  //
        make_unique<SetContentLauncherClusterRevisionAttributeCommand>(),             //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeraudioOutputSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "AudioOutput";

    commands_list clusterCommands = {
        make_unique<SetAudioOutputCurrentOutputAttributeCommand>(),   //
        make_unique<SetAudioOutputFeatureMapAttributeCommand>(),      //
        make_unique<SetAudioOutputClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerapplicationLauncherSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ApplicationLauncher";

    commands_list clusterCommands = {
        make_unique<SetApplicationLauncherFeatureMapAttributeCommand>(),      //
        make_unique<SetApplicationLauncherClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerapplicationBasicSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ApplicationBasic";

    commands_list clusterCommands = {
        make_unique<SetApplicationBasicVendorNameAttributeCommand>(),         //
        make_unique<SetApplicationBasicVendorIDAttributeCommand>(),           //
        make_unique<SetApplicationBasicApplicationNameAttributeCommand>(),    //
        make_unique<SetApplicationBasicProductIDAttributeCommand>(),          //
        make_unique<SetApplicationBasicStatusAttributeCommand>(),             //
        make_unique<SetApplicationBasicApplicationVersionAttributeCommand>(), //
        make_unique<SetApplicationBasicFeatureMapAttributeCommand>(),         //
        make_unique<SetApplicationBasicClusterRevisionAttributeCommand>(),    //
    };

    commands.Register(clusterName, clusterCommands);
}
void registeraccountLoginSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "AccountLogin";

    commands_list clusterCommands = {
        make_unique<SetAccountLoginFeatureMapAttributeCommand>(),      //
        make_unique<SetAccountLoginClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerelectricalMeasurementSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ElectricalMeasurement";

    commands_list clusterCommands = {
        make_unique<SetElectricalMeasurementMeasurementTypeAttributeCommand>(),                          //
        make_unique<SetElectricalMeasurementDcVoltageAttributeCommand>(),                                //
        make_unique<SetElectricalMeasurementDcVoltageMinAttributeCommand>(),                             //
        make_unique<SetElectricalMeasurementDcVoltageMaxAttributeCommand>(),                             //
        make_unique<SetElectricalMeasurementDcCurrentAttributeCommand>(),                                //
        make_unique<SetElectricalMeasurementDcCurrentMinAttributeCommand>(),                             //
        make_unique<SetElectricalMeasurementDcCurrentMaxAttributeCommand>(),                             //
        make_unique<SetElectricalMeasurementDcPowerAttributeCommand>(),                                  //
        make_unique<SetElectricalMeasurementDcPowerMinAttributeCommand>(),                               //
        make_unique<SetElectricalMeasurementDcPowerMaxAttributeCommand>(),                               //
        make_unique<SetElectricalMeasurementDcVoltageMultiplierAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementDcVoltageDivisorAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementDcCurrentMultiplierAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementDcCurrentDivisorAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementDcPowerMultiplierAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementDcPowerDivisorAttributeCommand>(),                           //
        make_unique<SetElectricalMeasurementAcFrequencyAttributeCommand>(),                              //
        make_unique<SetElectricalMeasurementAcFrequencyMinAttributeCommand>(),                           //
        make_unique<SetElectricalMeasurementAcFrequencyMaxAttributeCommand>(),                           //
        make_unique<SetElectricalMeasurementNeutralCurrentAttributeCommand>(),                           //
        make_unique<SetElectricalMeasurementTotalActivePowerAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementTotalReactivePowerAttributeCommand>(),                       //
        make_unique<SetElectricalMeasurementTotalApparentPowerAttributeCommand>(),                       //
        make_unique<SetElectricalMeasurementMeasured1stHarmonicCurrentAttributeCommand>(),               //
        make_unique<SetElectricalMeasurementMeasured3rdHarmonicCurrentAttributeCommand>(),               //
        make_unique<SetElectricalMeasurementMeasured5thHarmonicCurrentAttributeCommand>(),               //
        make_unique<SetElectricalMeasurementMeasured7thHarmonicCurrentAttributeCommand>(),               //
        make_unique<SetElectricalMeasurementMeasured9thHarmonicCurrentAttributeCommand>(),               //
        make_unique<SetElectricalMeasurementMeasured11thHarmonicCurrentAttributeCommand>(),              //
        make_unique<SetElectricalMeasurementMeasuredPhase1stHarmonicCurrentAttributeCommand>(),          //
        make_unique<SetElectricalMeasurementMeasuredPhase3rdHarmonicCurrentAttributeCommand>(),          //
        make_unique<SetElectricalMeasurementMeasuredPhase5thHarmonicCurrentAttributeCommand>(),          //
        make_unique<SetElectricalMeasurementMeasuredPhase7thHarmonicCurrentAttributeCommand>(),          //
        make_unique<SetElectricalMeasurementMeasuredPhase9thHarmonicCurrentAttributeCommand>(),          //
        make_unique<SetElectricalMeasurementMeasuredPhase11thHarmonicCurrentAttributeCommand>(),         //
        make_unique<SetElectricalMeasurementAcFrequencyMultiplierAttributeCommand>(),                    //
        make_unique<SetElectricalMeasurementAcFrequencyDivisorAttributeCommand>(),                       //
        make_unique<SetElectricalMeasurementPowerMultiplierAttributeCommand>(),                          //
        make_unique<SetElectricalMeasurementPowerDivisorAttributeCommand>(),                             //
        make_unique<SetElectricalMeasurementHarmonicCurrentMultiplierAttributeCommand>(),                //
        make_unique<SetElectricalMeasurementPhaseHarmonicCurrentMultiplierAttributeCommand>(),           //
        make_unique<SetElectricalMeasurementInstantaneousVoltageAttributeCommand>(),                     //
        make_unique<SetElectricalMeasurementInstantaneousLineCurrentAttributeCommand>(),                 //
        make_unique<SetElectricalMeasurementInstantaneousActiveCurrentAttributeCommand>(),               //
        make_unique<SetElectricalMeasurementInstantaneousReactiveCurrentAttributeCommand>(),             //
        make_unique<SetElectricalMeasurementInstantaneousPowerAttributeCommand>(),                       //
        make_unique<SetElectricalMeasurementRmsVoltageAttributeCommand>(),                               //
        make_unique<SetElectricalMeasurementRmsVoltageMinAttributeCommand>(),                            //
        make_unique<SetElectricalMeasurementRmsVoltageMaxAttributeCommand>(),                            //
        make_unique<SetElectricalMeasurementRmsCurrentAttributeCommand>(),                               //
        make_unique<SetElectricalMeasurementRmsCurrentMinAttributeCommand>(),                            //
        make_unique<SetElectricalMeasurementRmsCurrentMaxAttributeCommand>(),                            //
        make_unique<SetElectricalMeasurementActivePowerAttributeCommand>(),                              //
        make_unique<SetElectricalMeasurementActivePowerMinAttributeCommand>(),                           //
        make_unique<SetElectricalMeasurementActivePowerMaxAttributeCommand>(),                           //
        make_unique<SetElectricalMeasurementReactivePowerAttributeCommand>(),                            //
        make_unique<SetElectricalMeasurementApparentPowerAttributeCommand>(),                            //
        make_unique<SetElectricalMeasurementPowerFactorAttributeCommand>(),                              //
        make_unique<SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodAttributeCommand>(),       //
        make_unique<SetElectricalMeasurementAverageRmsUnderVoltageCounterAttributeCommand>(),            //
        make_unique<SetElectricalMeasurementRmsExtremeOverVoltagePeriodAttributeCommand>(),              //
        make_unique<SetElectricalMeasurementRmsExtremeUnderVoltagePeriodAttributeCommand>(),             //
        make_unique<SetElectricalMeasurementRmsVoltageSagPeriodAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementRmsVoltageSwellPeriodAttributeCommand>(),                    //
        make_unique<SetElectricalMeasurementAcVoltageMultiplierAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementAcVoltageDivisorAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementAcCurrentMultiplierAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementAcCurrentDivisorAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementAcPowerMultiplierAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementAcPowerDivisorAttributeCommand>(),                           //
        make_unique<SetElectricalMeasurementOverloadAlarmsMaskAttributeCommand>(),                       //
        make_unique<SetElectricalMeasurementVoltageOverloadAttributeCommand>(),                          //
        make_unique<SetElectricalMeasurementCurrentOverloadAttributeCommand>(),                          //
        make_unique<SetElectricalMeasurementAcOverloadAlarmsMaskAttributeCommand>(),                     //
        make_unique<SetElectricalMeasurementAcVoltageOverloadAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementAcCurrentOverloadAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementAcActivePowerOverloadAttributeCommand>(),                    //
        make_unique<SetElectricalMeasurementAcReactivePowerOverloadAttributeCommand>(),                  //
        make_unique<SetElectricalMeasurementAverageRmsOverVoltageAttributeCommand>(),                    //
        make_unique<SetElectricalMeasurementAverageRmsUnderVoltageAttributeCommand>(),                   //
        make_unique<SetElectricalMeasurementRmsExtremeOverVoltageAttributeCommand>(),                    //
        make_unique<SetElectricalMeasurementRmsExtremeUnderVoltageAttributeCommand>(),                   //
        make_unique<SetElectricalMeasurementRmsVoltageSagAttributeCommand>(),                            //
        make_unique<SetElectricalMeasurementRmsVoltageSwellAttributeCommand>(),                          //
        make_unique<SetElectricalMeasurementLineCurrentPhaseBAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementActiveCurrentPhaseBAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementReactiveCurrentPhaseBAttributeCommand>(),                    //
        make_unique<SetElectricalMeasurementRmsVoltagePhaseBAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementRmsVoltageMinPhaseBAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementRmsVoltageMaxPhaseBAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementRmsCurrentPhaseBAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementRmsCurrentMinPhaseBAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementRmsCurrentMaxPhaseBAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementActivePowerPhaseBAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementActivePowerMinPhaseBAttributeCommand>(),                     //
        make_unique<SetElectricalMeasurementActivePowerMaxPhaseBAttributeCommand>(),                     //
        make_unique<SetElectricalMeasurementReactivePowerPhaseBAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementApparentPowerPhaseBAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementPowerFactorPhaseBAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseBAttributeCommand>(), //
        make_unique<SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseBAttributeCommand>(),       //
        make_unique<SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseBAttributeCommand>(),      //
        make_unique<SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseBAttributeCommand>(),        //
        make_unique<SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseBAttributeCommand>(),       //
        make_unique<SetElectricalMeasurementRmsVoltageSagPeriodPhaseBAttributeCommand>(),                //
        make_unique<SetElectricalMeasurementRmsVoltageSwellPeriodPhaseBAttributeCommand>(),              //
        make_unique<SetElectricalMeasurementLineCurrentPhaseCAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementActiveCurrentPhaseCAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementReactiveCurrentPhaseCAttributeCommand>(),                    //
        make_unique<SetElectricalMeasurementRmsVoltagePhaseCAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementRmsVoltageMinPhaseCAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementRmsVoltageMaxPhaseCAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementRmsCurrentPhaseCAttributeCommand>(),                         //
        make_unique<SetElectricalMeasurementRmsCurrentMinPhaseCAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementRmsCurrentMaxPhaseCAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementActivePowerPhaseCAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementActivePowerMinPhaseCAttributeCommand>(),                     //
        make_unique<SetElectricalMeasurementActivePowerMaxPhaseCAttributeCommand>(),                     //
        make_unique<SetElectricalMeasurementReactivePowerPhaseCAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementApparentPowerPhaseCAttributeCommand>(),                      //
        make_unique<SetElectricalMeasurementPowerFactorPhaseCAttributeCommand>(),                        //
        make_unique<SetElectricalMeasurementAverageRmsVoltageMeasurementPeriodPhaseCAttributeCommand>(), //
        make_unique<SetElectricalMeasurementAverageRmsOverVoltageCounterPhaseCAttributeCommand>(),       //
        make_unique<SetElectricalMeasurementAverageRmsUnderVoltageCounterPhaseCAttributeCommand>(),      //
        make_unique<SetElectricalMeasurementRmsExtremeOverVoltagePeriodPhaseCAttributeCommand>(),        //
        make_unique<SetElectricalMeasurementRmsExtremeUnderVoltagePeriodPhaseCAttributeCommand>(),       //
        make_unique<SetElectricalMeasurementRmsVoltageSagPeriodPhaseCAttributeCommand>(),                //
        make_unique<SetElectricalMeasurementRmsVoltageSwellPeriodPhaseCAttributeCommand>(),              //
        make_unique<SetElectricalMeasurementFeatureMapAttributeCommand>(),                               //
        make_unique<SetElectricalMeasurementClusterRevisionAttributeCommand>(),                          //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerclientMonitoringSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "ClientMonitoring";

    commands_list clusterCommands = {
        make_unique<SetClientMonitoringIdleModeIntervalAttributeCommand>(),    //
        make_unique<SetClientMonitoringActiveModeIntervalAttributeCommand>(),  //
        make_unique<SetClientMonitoringActiveModeThresholdAttributeCommand>(), //
        make_unique<SetClientMonitoringFeatureMapAttributeCommand>(),          //
        make_unique<SetClientMonitoringClusterRevisionAttributeCommand>(),     //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerunitTestingSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "UnitTesting";

    commands_list clusterCommands = {
        make_unique<SetUnitTestingBooleanAttributeCommand>(),                       //
        make_unique<SetUnitTestingBitmap8AttributeCommand>(),                       //
        make_unique<SetUnitTestingBitmap16AttributeCommand>(),                      //
        make_unique<SetUnitTestingBitmap32AttributeCommand>(),                      //
        make_unique<SetUnitTestingBitmap64AttributeCommand>(),                      //
        make_unique<SetUnitTestingInt8uAttributeCommand>(),                         //
        make_unique<SetUnitTestingInt16uAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt24uAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt32uAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt40uAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt48uAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt56uAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt64uAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt8sAttributeCommand>(),                         //
        make_unique<SetUnitTestingInt16sAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt24sAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt32sAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt40sAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt48sAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt56sAttributeCommand>(),                        //
        make_unique<SetUnitTestingInt64sAttributeCommand>(),                        //
        make_unique<SetUnitTestingEnum8AttributeCommand>(),                         //
        make_unique<SetUnitTestingEnum16AttributeCommand>(),                        //
        make_unique<SetUnitTestingFloatSingleAttributeCommand>(),                   //
        make_unique<SetUnitTestingFloatDoubleAttributeCommand>(),                   //
        make_unique<SetUnitTestingOctetStringAttributeCommand>(),                   //
        make_unique<SetUnitTestingLongOctetStringAttributeCommand>(),               //
        make_unique<SetUnitTestingCharStringAttributeCommand>(),                    //
        make_unique<SetUnitTestingLongCharStringAttributeCommand>(),                //
        make_unique<SetUnitTestingEpochUsAttributeCommand>(),                       //
        make_unique<SetUnitTestingEpochSAttributeCommand>(),                        //
        make_unique<SetUnitTestingVendorIdAttributeCommand>(),                      //
        make_unique<SetUnitTestingEnumAttrAttributeCommand>(),                      //
        make_unique<SetUnitTestingRangeRestrictedInt8uAttributeCommand>(),          //
        make_unique<SetUnitTestingRangeRestrictedInt8sAttributeCommand>(),          //
        make_unique<SetUnitTestingRangeRestrictedInt16uAttributeCommand>(),         //
        make_unique<SetUnitTestingRangeRestrictedInt16sAttributeCommand>(),         //
        make_unique<SetUnitTestingTimedWriteBooleanAttributeCommand>(),             //
        make_unique<SetUnitTestingGeneralErrorBooleanAttributeCommand>(),           //
        make_unique<SetUnitTestingClusterErrorBooleanAttributeCommand>(),           //
        make_unique<SetUnitTestingUnsupportedAttributeCommand>(),                   //
        make_unique<SetUnitTestingNullableBooleanAttributeCommand>(),               //
        make_unique<SetUnitTestingNullableBitmap8AttributeCommand>(),               //
        make_unique<SetUnitTestingNullableBitmap16AttributeCommand>(),              //
        make_unique<SetUnitTestingNullableBitmap32AttributeCommand>(),              //
        make_unique<SetUnitTestingNullableBitmap64AttributeCommand>(),              //
        make_unique<SetUnitTestingNullableInt8uAttributeCommand>(),                 //
        make_unique<SetUnitTestingNullableInt16uAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt24uAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt32uAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt40uAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt48uAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt56uAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt64uAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt8sAttributeCommand>(),                 //
        make_unique<SetUnitTestingNullableInt16sAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt24sAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt32sAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt40sAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt48sAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt56sAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableInt64sAttributeCommand>(),                //
        make_unique<SetUnitTestingNullableEnum8AttributeCommand>(),                 //
        make_unique<SetUnitTestingNullableEnum16AttributeCommand>(),                //
        make_unique<SetUnitTestingNullableFloatSingleAttributeCommand>(),           //
        make_unique<SetUnitTestingNullableFloatDoubleAttributeCommand>(),           //
        make_unique<SetUnitTestingNullableOctetStringAttributeCommand>(),           //
        make_unique<SetUnitTestingNullableCharStringAttributeCommand>(),            //
        make_unique<SetUnitTestingNullableEnumAttrAttributeCommand>(),              //
        make_unique<SetUnitTestingNullableRangeRestrictedInt8uAttributeCommand>(),  //
        make_unique<SetUnitTestingNullableRangeRestrictedInt8sAttributeCommand>(),  //
        make_unique<SetUnitTestingNullableRangeRestrictedInt16uAttributeCommand>(), //
        make_unique<SetUnitTestingNullableRangeRestrictedInt16sAttributeCommand>(), //
        make_unique<SetUnitTestingWriteOnlyInt8uAttributeCommand>(),                //
        make_unique<SetUnitTestingFeatureMapAttributeCommand>(),                    //
        make_unique<SetUnitTestingClusterRevisionAttributeCommand>(),               //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerfaultInjectionSetAttributesCommands(Commands & commands)
{
    const char * clusterName = "FaultInjection";

    commands_list clusterCommands = {
        make_unique<SetFaultInjectionFeatureMapAttributeCommand>(),      //
        make_unique<SetFaultInjectionClusterRevisionAttributeCommand>(), //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerSetAttributeCommands(Commands & commands)
{
    registeridentifySetAttributesCommands(commands);
    registergroupsSetAttributesCommands(commands);
    registerscenesSetAttributesCommands(commands);
    registeronOffSetAttributesCommands(commands);
    registeronOffSwitchConfigurationSetAttributesCommands(commands);
    registerlevelControlSetAttributesCommands(commands);
    registerbinaryInputBasicSetAttributesCommands(commands);
    registerpulseWidthModulationSetAttributesCommands(commands);
    registerdescriptorSetAttributesCommands(commands);
    registerbindingSetAttributesCommands(commands);
    registeraccessControlSetAttributesCommands(commands);
    registeractionsSetAttributesCommands(commands);
    registerbasicInformationSetAttributesCommands(commands);
    registerotaSoftwareUpdateProviderSetAttributesCommands(commands);
    registerotaSoftwareUpdateRequestorSetAttributesCommands(commands);
    registerlocalizationConfigurationSetAttributesCommands(commands);
    registertimeFormatLocalizationSetAttributesCommands(commands);
    registerunitLocalizationSetAttributesCommands(commands);
    registerpowerSourceConfigurationSetAttributesCommands(commands);
    registerpowerSourceSetAttributesCommands(commands);
    registergeneralCommissioningSetAttributesCommands(commands);
    registernetworkCommissioningSetAttributesCommands(commands);
    registerdiagnosticLogsSetAttributesCommands(commands);
    registergeneralDiagnosticsSetAttributesCommands(commands);
    registersoftwareDiagnosticsSetAttributesCommands(commands);
    registerthreadNetworkDiagnosticsSetAttributesCommands(commands);
    registerwiFiNetworkDiagnosticsSetAttributesCommands(commands);
    registerethernetNetworkDiagnosticsSetAttributesCommands(commands);
    registertimeSynchronizationSetAttributesCommands(commands);
    registerbridgedDeviceBasicInformationSetAttributesCommands(commands);
    registerswitchSetAttributesCommands(commands);
    registeradministratorCommissioningSetAttributesCommands(commands);
    registeroperationalCredentialsSetAttributesCommands(commands);
    registergroupKeyManagementSetAttributesCommands(commands);
    registerfixedLabelSetAttributesCommands(commands);
    registeruserLabelSetAttributesCommands(commands);
    registerproxyConfigurationSetAttributesCommands(commands);
    registerproxyDiscoverySetAttributesCommands(commands);
    registerproxyValidSetAttributesCommands(commands);
    registerbooleanStateSetAttributesCommands(commands);
    registermodeSelectSetAttributesCommands(commands);
    registerdoorLockSetAttributesCommands(commands);
    registerwindowCoveringSetAttributesCommands(commands);
    registerbarrierControlSetAttributesCommands(commands);
    registerpumpConfigurationAndControlSetAttributesCommands(commands);
    registerthermostatSetAttributesCommands(commands);
    registerfanControlSetAttributesCommands(commands);
    registerthermostatUserInterfaceConfigurationSetAttributesCommands(commands);
    registercolorControlSetAttributesCommands(commands);
    registerballastConfigurationSetAttributesCommands(commands);
    registerilluminanceMeasurementSetAttributesCommands(commands);
    registertemperatureMeasurementSetAttributesCommands(commands);
    registerpressureMeasurementSetAttributesCommands(commands);
    registerflowMeasurementSetAttributesCommands(commands);
    registerrelativeHumidityMeasurementSetAttributesCommands(commands);
    registeroccupancySensingSetAttributesCommands(commands);
    registerwakeOnLanSetAttributesCommands(commands);
    registerchannelSetAttributesCommands(commands);
    registertargetNavigatorSetAttributesCommands(commands);
    registermediaPlaybackSetAttributesCommands(commands);
    registermediaInputSetAttributesCommands(commands);
    registerlowPowerSetAttributesCommands(commands);
    registerkeypadInputSetAttributesCommands(commands);
    registercontentLauncherSetAttributesCommands(commands);
    registeraudioOutputSetAttributesCommands(commands);
    registerapplicationLauncherSetAttributesCommands(commands);
    registerapplicationBasicSetAttributesCommands(commands);
    registeraccountLoginSetAttributesCommands(commands);
    registerelectricalMeasurementSetAttributesCommands(commands);
    registerclientMonitoringSetAttributesCommands(commands);
    registerunitTestingSetAttributesCommands(commands);
    registerfaultInjectionSetAttributesCommands(commands);
}